// Code generated by protoc-gen-go. DO NOT EDIT.
// source: medifor/v1/pipeline.proto

package mediforproto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SortKey int32

const (
	SortKey_SCORE SortKey = 0
	SortKey_META  SortKey = 1
)

var SortKey_name = map[int32]string{
	0: "SCORE",
	1: "META",
}

var SortKey_value = map[string]int32{
	"SCORE": 0,
	"META":  1,
}

func (x SortKey) String() string {
	return proto.EnumName(SortKey_name, int32(x))
}

func (SortKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{0}
}

type FusionThresholdType int32

const (
	FusionThresholdType_FUSION_NO_THRESHOLD FusionThresholdType = 0
	FusionThresholdType_FUSION_LT_THRESHOLD FusionThresholdType = 1
	FusionThresholdType_FUSION_GT_THRESHOLD FusionThresholdType = 2
)

var FusionThresholdType_name = map[int32]string{
	0: "FUSION_NO_THRESHOLD",
	1: "FUSION_LT_THRESHOLD",
	2: "FUSION_GT_THRESHOLD",
}

var FusionThresholdType_value = map[string]int32{
	"FUSION_NO_THRESHOLD": 0,
	"FUSION_LT_THRESHOLD": 1,
	"FUSION_GT_THRESHOLD": 2,
}

func (x FusionThresholdType) String() string {
	return proto.EnumName(FusionThresholdType_name, int32(x))
}

func (FusionThresholdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{1}
}

// SortCol identifies the column to sort by and whether to sort in ascending order
// Next tag: 6
type SortCol struct {
	// Column to sort on
	Key SortKey `protobuf:"varint,1,opt,name=key,proto3,enum=mediforproto.SortKey" json:"key,omitempty"`
	// Bool for sorting in ascending order (if false sorts in descending order)
	IsAsc bool `protobuf:"varint,2,opt,name=is_asc,json=isAsc,proto3" json:"is_asc,omitempty"`
	// What type to cast the key into if necessary
	TypeCast string `protobuf:"bytes,3,opt,name=type_cast,json=typeCast,proto3" json:"type_cast,omitempty"`
	// Metadata key to sort by if using metadata
	MetaKey              string   `protobuf:"bytes,4,opt,name=meta_key,json=metaKey,proto3" json:"meta_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SortCol) Reset()         { *m = SortCol{} }
func (m *SortCol) String() string { return proto.CompactTextString(m) }
func (*SortCol) ProtoMessage()    {}
func (*SortCol) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{0}
}

func (m *SortCol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SortCol.Unmarshal(m, b)
}
func (m *SortCol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SortCol.Marshal(b, m, deterministic)
}
func (m *SortCol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortCol.Merge(m, src)
}
func (m *SortCol) XXX_Size() int {
	return xxx_messageInfo_SortCol.Size(m)
}
func (m *SortCol) XXX_DiscardUnknown() {
	xxx_messageInfo_SortCol.DiscardUnknown(m)
}

var xxx_messageInfo_SortCol proto.InternalMessageInfo

func (m *SortCol) GetKey() SortKey {
	if m != nil {
		return m.Key
	}
	return SortKey_SCORE
}

func (m *SortCol) GetIsAsc() bool {
	if m != nil {
		return m.IsAsc
	}
	return false
}

func (m *SortCol) GetTypeCast() string {
	if m != nil {
		return m.TypeCast
	}
	return ""
}

func (m *SortCol) GetMetaKey() string {
	if m != nil {
		return m.MetaKey
	}
	return ""
}

// DetectionRequest contains a MediFor detection object as well as a list of
// analytic ids and fusion ids. TODO: if none specified, default to all?
// Next Tag: 9
type DetectionRequest struct {
	// An optional ID for this detection. If not provided, one will be assigned.
	// Must be unique from any other provided ID: a collision will prevent
	// this request from being fulfilled.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// A Detection proto with just the important request parts filled out.
	Request *Detection `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// The analytics to run.
	AnalyticId []string `protobuf:"bytes,2,rep,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
	// Fusers to run automatically when all analytics are done.
	FuserId []string `protobuf:"bytes,8,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Tags to apply to this detection. When in doubt, use user_tags instead.
	Tags map[string]string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// User tags to apply to this detection. When in doubt, use this one.
	UserTags map[string]string `protobuf:"bytes,6,rep,name=user_tags,json=userTags,proto3" json:"user_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Metadata table as needed. Pass-through.
	Meta map[string]string `protobuf:"bytes,7,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Timeout in seconds after which an analytic worker will die waiting for the
	// analytic to respond. Default is "no timeout" (0 seconds).
	AnalyticTimeoutSec   int64    `protobuf:"varint,5,opt,name=analytic_timeout_sec,json=analyticTimeoutSec,proto3" json:"analytic_timeout_sec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionRequest) Reset()         { *m = DetectionRequest{} }
func (m *DetectionRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionRequest) ProtoMessage()    {}
func (*DetectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{1}
}

func (m *DetectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionRequest.Unmarshal(m, b)
}
func (m *DetectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionRequest.Marshal(b, m, deterministic)
}
func (m *DetectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionRequest.Merge(m, src)
}
func (m *DetectionRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionRequest.Size(m)
}
func (m *DetectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionRequest proto.InternalMessageInfo

func (m *DetectionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionRequest) GetRequest() *Detection {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DetectionRequest) GetAnalyticId() []string {
	if m != nil {
		return m.AnalyticId
	}
	return nil
}

func (m *DetectionRequest) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *DetectionRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionRequest) GetUserTags() map[string]string {
	if m != nil {
		return m.UserTags
	}
	return nil
}

func (m *DetectionRequest) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DetectionRequest) GetAnalyticTimeoutSec() int64 {
	if m != nil {
		return m.AnalyticTimeoutSec
	}
	return 0
}

// AnalyticDetectionInfo provides details on the status of a detection being
// performed by a given analytic.
// Next ID: 5
type AnalyticDetectionInfo struct {
	// The analytic that produced this result.
	AnalyticId string `protobuf:"bytes,1,opt,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
	// Current processing stage for the entire detection event (all analytics) if
	// in progress, or PT_STAGE_FINISHED if completed. When complete, the status
	// field will have a non-default value.
	Stage DetectionStage `protobuf:"varint,2,opt,name=stage,proto3,enum=mediforproto.DetectionStage" json:"stage,omitempty"`
	// Final status when we are in PT_STAGE_FINISHED.
	Status DetectionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=mediforproto.DetectionStatus" json:"status,omitempty"`
	// The Detection with the result and status filled out (and the request).
	// If the response and status are empty (default), then it is not finished.
	Detection            *Detection `protobuf:"bytes,4,opt,name=detection,proto3" json:"detection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AnalyticDetectionInfo) Reset()         { *m = AnalyticDetectionInfo{} }
func (m *AnalyticDetectionInfo) String() string { return proto.CompactTextString(m) }
func (*AnalyticDetectionInfo) ProtoMessage()    {}
func (*AnalyticDetectionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{2}
}

func (m *AnalyticDetectionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnalyticDetectionInfo.Unmarshal(m, b)
}
func (m *AnalyticDetectionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnalyticDetectionInfo.Marshal(b, m, deterministic)
}
func (m *AnalyticDetectionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyticDetectionInfo.Merge(m, src)
}
func (m *AnalyticDetectionInfo) XXX_Size() int {
	return xxx_messageInfo_AnalyticDetectionInfo.Size(m)
}
func (m *AnalyticDetectionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyticDetectionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyticDetectionInfo proto.InternalMessageInfo

func (m *AnalyticDetectionInfo) GetAnalyticId() string {
	if m != nil {
		return m.AnalyticId
	}
	return ""
}

func (m *AnalyticDetectionInfo) GetStage() DetectionStage {
	if m != nil {
		return m.Stage
	}
	return DetectionStage_DETECTION_STAGE_NONE
}

func (m *AnalyticDetectionInfo) GetStatus() DetectionStatus {
	if m != nil {
		return m.Status
	}
	return DetectionStatus_DETECTION_STATUS_NONE
}

func (m *AnalyticDetectionInfo) GetDetection() *Detection {
	if m != nil {
		return m.Detection
	}
	return nil
}

// DetectionInfo provides details on a given detection event specified by the id.
// Next Tag: 11
type DetectionInfo struct {
	// The detection event ID.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Results for individual analytics.
	AnalyticInfo []*AnalyticDetectionInfo `protobuf:"bytes,2,rep,name=analytic_info,json=analyticInfo,proto3" json:"analytic_info,omitempty"`
	// Results for fusion analytics
	FusionInfo []*FuserFusionInfo `protobuf:"bytes,8,rep,name=fusion_info,json=fusionInfo,proto3" json:"fusion_info,omitempty"`
	// Tags for the requested detection.
	Tags     map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UserTags map[string]string `protobuf:"bytes,6,rep,name=user_tags,json=userTags,proto3" json:"user_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta     map[string]string `protobuf:"bytes,7,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A fused score, if requested.
	HasFused   bool    `protobuf:"varint,4,opt,name=has_fused,json=hasFused,proto3" json:"has_fused,omitempty"`
	FusedScore float64 `protobuf:"fixed64,5,opt,name=fused_score,json=fusedScore,proto3" json:"fused_score,omitempty"`
	// Progress indicator across all analytics.
	AnalyticsTotal       int32    `protobuf:"varint,9,opt,name=analytics_total,json=analyticsTotal,proto3" json:"analytics_total,omitempty"`
	AnalyticsFinished    int32    `protobuf:"varint,10,opt,name=analytics_finished,json=analyticsFinished,proto3" json:"analytics_finished,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionInfo) Reset()         { *m = DetectionInfo{} }
func (m *DetectionInfo) String() string { return proto.CompactTextString(m) }
func (*DetectionInfo) ProtoMessage()    {}
func (*DetectionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{3}
}

func (m *DetectionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionInfo.Unmarshal(m, b)
}
func (m *DetectionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionInfo.Marshal(b, m, deterministic)
}
func (m *DetectionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionInfo.Merge(m, src)
}
func (m *DetectionInfo) XXX_Size() int {
	return xxx_messageInfo_DetectionInfo.Size(m)
}
func (m *DetectionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionInfo proto.InternalMessageInfo

func (m *DetectionInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionInfo) GetAnalyticInfo() []*AnalyticDetectionInfo {
	if m != nil {
		return m.AnalyticInfo
	}
	return nil
}

func (m *DetectionInfo) GetFusionInfo() []*FuserFusionInfo {
	if m != nil {
		return m.FusionInfo
	}
	return nil
}

func (m *DetectionInfo) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionInfo) GetUserTags() map[string]string {
	if m != nil {
		return m.UserTags
	}
	return nil
}

func (m *DetectionInfo) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DetectionInfo) GetHasFused() bool {
	if m != nil {
		return m.HasFused
	}
	return false
}

func (m *DetectionInfo) GetFusedScore() float64 {
	if m != nil {
		return m.FusedScore
	}
	return 0
}

func (m *DetectionInfo) GetAnalyticsTotal() int32 {
	if m != nil {
		return m.AnalyticsTotal
	}
	return 0
}

func (m *DetectionInfo) GetAnalyticsFinished() int32 {
	if m != nil {
		return m.AnalyticsFinished
	}
	return 0
}

// DetectionInfoRequest contains the ID of an individual detection event.
type DetectionInfoRequest struct {
	// The ID of the detection, as returned by Detect or GetDetectionList.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// If specified, fused scores will be returned as well.
	WantFused            bool     `protobuf:"varint,2,opt,name=want_fused,json=wantFused,proto3" json:"want_fused,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionInfoRequest) Reset()         { *m = DetectionInfoRequest{} }
func (m *DetectionInfoRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionInfoRequest) ProtoMessage()    {}
func (*DetectionInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{4}
}

func (m *DetectionInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionInfoRequest.Unmarshal(m, b)
}
func (m *DetectionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionInfoRequest.Marshal(b, m, deterministic)
}
func (m *DetectionInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionInfoRequest.Merge(m, src)
}
func (m *DetectionInfoRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionInfoRequest.Size(m)
}
func (m *DetectionInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionInfoRequest proto.InternalMessageInfo

func (m *DetectionInfoRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionInfoRequest) GetWantFused() bool {
	if m != nil {
		return m.WantFused
	}
	return false
}

// Next Tag: 10
type DetectionListRequest struct {
	// If specified (can be empty), all listed tags (both key and value) must be
	// simultaneously present for a detection ID to be returned.
	Tags map[string]string `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If specified, only returns results from the given list of detection IDs.
	// Good for returning a single detection or one of a few. Not great for very
	// long lists (thousands).
	DetectionIds []string `protobuf:"bytes,7,rep,name=detection_ids,json=detectionIds,proto3" json:"detection_ids,omitempty"`
	// Specify that detection info objects should have fusion scores.
	WantFused bool `protobuf:"varint,4,opt,name=want_fused,json=wantFused,proto3" json:"want_fused,omitempty"`
	// A series of keys to sort on, with the first key being the primary sort key
	// and following ones being seconday, tertiary, etc...
	OrderBy []*SortCol `protobuf:"bytes,5,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// Fusion ID on which to sort by fusion score.
	FuserId string `protobuf:"bytes,6,opt,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Fusion score threshold, if needed. Only used if the threshold type is not the default value (no threshold).
	FusionThresholdType  FusionThresholdType `protobuf:"varint,8,opt,name=fusion_threshold_type,json=fusionThresholdType,proto3,enum=mediforproto.FusionThresholdType" json:"fusion_threshold_type,omitempty"`
	FusionThresholdValue float32             `protobuf:"fixed32,9,opt,name=fusion_threshold_value,json=fusionThresholdValue,proto3" json:"fusion_threshold_value,omitempty"`
	// Maximum number of items in the response. Optional.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// If a token was returned in the response, this can be used to continue
	// where the previous response left off.
	PageToken            string   `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionListRequest) Reset()         { *m = DetectionListRequest{} }
func (m *DetectionListRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionListRequest) ProtoMessage()    {}
func (*DetectionListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{5}
}

func (m *DetectionListRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionListRequest.Unmarshal(m, b)
}
func (m *DetectionListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionListRequest.Marshal(b, m, deterministic)
}
func (m *DetectionListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionListRequest.Merge(m, src)
}
func (m *DetectionListRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionListRequest.Size(m)
}
func (m *DetectionListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionListRequest proto.InternalMessageInfo

func (m *DetectionListRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionListRequest) GetDetectionIds() []string {
	if m != nil {
		return m.DetectionIds
	}
	return nil
}

func (m *DetectionListRequest) GetWantFused() bool {
	if m != nil {
		return m.WantFused
	}
	return false
}

func (m *DetectionListRequest) GetOrderBy() []*SortCol {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *DetectionListRequest) GetFuserId() string {
	if m != nil {
		return m.FuserId
	}
	return ""
}

func (m *DetectionListRequest) GetFusionThresholdType() FusionThresholdType {
	if m != nil {
		return m.FusionThresholdType
	}
	return FusionThresholdType_FUSION_NO_THRESHOLD
}

func (m *DetectionListRequest) GetFusionThresholdValue() float32 {
	if m != nil {
		return m.FusionThresholdValue
	}
	return 0
}

func (m *DetectionListRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *DetectionListRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// DetectionList provides a list of DetectionInfo objects.
// Next Tag: 4
type DetectionList struct {
	Detections []*DetectionInfo `protobuf:"bytes,1,rep,name=detections,proto3" json:"detections,omitempty"`
	// Total detections in the filtered list.
	Total int32 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	// If this is non-empty, there are more results to be returned. Pass it into
	// a DetectionListRequest to obtain remaining results.
	PageToken            string   `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionList) Reset()         { *m = DetectionList{} }
func (m *DetectionList) String() string { return proto.CompactTextString(m) }
func (*DetectionList) ProtoMessage()    {}
func (*DetectionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{6}
}

func (m *DetectionList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionList.Unmarshal(m, b)
}
func (m *DetectionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionList.Marshal(b, m, deterministic)
}
func (m *DetectionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionList.Merge(m, src)
}
func (m *DetectionList) XXX_Size() int {
	return xxx_messageInfo_DetectionList.Size(m)
}
func (m *DetectionList) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionList.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionList proto.InternalMessageInfo

func (m *DetectionList) GetDetections() []*DetectionInfo {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *DetectionList) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DetectionList) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// FusionRequest contains a fusion object or a list of detectionIDs to be fused.
// Next ID: 7
type FusionRequest struct {
	// An optional ID for this fusion. If not provided, one will be assigned.
	// Must be unique from any other provided ID: a collision will prevent
	// this request from being fulfilled.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A Fusion Proto containing the original probe as well as the detection objects from
	// each analytic that ran over that probe.
	Request *Fusion `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	// IDs for the fusion analytics
	FuserId []string `protobuf:"bytes,4,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Tags to apply to this fusion.  To be inserted into the database as json.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// DetectionID for the probes on which to perform fusion if no request is specified
	DetectionId string `protobuf:"bytes,5,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	// Output directory to use ONLY if building request from a detection ID
	DetectionIdOutDir    string   `protobuf:"bytes,6,opt,name=detection_id_out_dir,json=detectionIdOutDir,proto3" json:"detection_id_out_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FusionRequest) Reset()         { *m = FusionRequest{} }
func (m *FusionRequest) String() string { return proto.CompactTextString(m) }
func (*FusionRequest) ProtoMessage()    {}
func (*FusionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{7}
}

func (m *FusionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FusionRequest.Unmarshal(m, b)
}
func (m *FusionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FusionRequest.Marshal(b, m, deterministic)
}
func (m *FusionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FusionRequest.Merge(m, src)
}
func (m *FusionRequest) XXX_Size() int {
	return xxx_messageInfo_FusionRequest.Size(m)
}
func (m *FusionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FusionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FusionRequest proto.InternalMessageInfo

func (m *FusionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FusionRequest) GetRequest() *Fusion {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *FusionRequest) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *FusionRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FusionRequest) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

func (m *FusionRequest) GetDetectionIdOutDir() string {
	if m != nil {
		return m.DetectionIdOutDir
	}
	return ""
}

// AnalyticDetectionInfo provides details on the status of a detection being
// performed by a given analytic.
// Next ID: 5
type FuserFusionInfo struct {
	// The fusion algorithmc that produced this result.
	FuserId string `protobuf:"bytes,1,opt,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Current processing stage for the entire detection event (all analytics) if
	// in progress, or PT_STAGE_FINISHED if completed. When complete, the status
	// field will have a non-default value.
	Stage DetectionStage `protobuf:"varint,2,opt,name=stage,proto3,enum=mediforproto.DetectionStage" json:"stage,omitempty"`
	// Final status when we are in PT_STAGE_FINISHED.
	Status DetectionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=mediforproto.DetectionStatus" json:"status,omitempty"`
	// The Fusion with the result and status filled out (and the request).
	// If the response and status are empty (default), then it is not finished.
	Fusion               *Fusion  `protobuf:"bytes,4,opt,name=fusion,proto3" json:"fusion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuserFusionInfo) Reset()         { *m = FuserFusionInfo{} }
func (m *FuserFusionInfo) String() string { return proto.CompactTextString(m) }
func (*FuserFusionInfo) ProtoMessage()    {}
func (*FuserFusionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{8}
}

func (m *FuserFusionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuserFusionInfo.Unmarshal(m, b)
}
func (m *FuserFusionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuserFusionInfo.Marshal(b, m, deterministic)
}
func (m *FuserFusionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuserFusionInfo.Merge(m, src)
}
func (m *FuserFusionInfo) XXX_Size() int {
	return xxx_messageInfo_FuserFusionInfo.Size(m)
}
func (m *FuserFusionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FuserFusionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FuserFusionInfo proto.InternalMessageInfo

func (m *FuserFusionInfo) GetFuserId() string {
	if m != nil {
		return m.FuserId
	}
	return ""
}

func (m *FuserFusionInfo) GetStage() DetectionStage {
	if m != nil {
		return m.Stage
	}
	return DetectionStage_DETECTION_STAGE_NONE
}

func (m *FuserFusionInfo) GetStatus() DetectionStatus {
	if m != nil {
		return m.Status
	}
	return DetectionStatus_DETECTION_STATUS_NONE
}

func (m *FuserFusionInfo) GetFusion() *Fusion {
	if m != nil {
		return m.Fusion
	}
	return nil
}

// FusionInfo provides details on a given fusion event specified by the ID.
type FusionInfo struct {
	// Fusion event ID.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Results for individual fusion analytics.
	FusionInfos []*FuserFusionInfo `protobuf:"bytes,2,rep,name=fusion_infos,json=fusionInfos,proto3" json:"fusion_infos,omitempty"`
	// Tags for the requested fusion.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A fused score, if requested.
	HasFused             bool     `protobuf:"varint,4,opt,name=has_fused,json=hasFused,proto3" json:"has_fused,omitempty"`
	FusedScore           float64  `protobuf:"fixed64,5,opt,name=fused_score,json=fusedScore,proto3" json:"fused_score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FusionInfo) Reset()         { *m = FusionInfo{} }
func (m *FusionInfo) String() string { return proto.CompactTextString(m) }
func (*FusionInfo) ProtoMessage()    {}
func (*FusionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{9}
}

func (m *FusionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FusionInfo.Unmarshal(m, b)
}
func (m *FusionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FusionInfo.Marshal(b, m, deterministic)
}
func (m *FusionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FusionInfo.Merge(m, src)
}
func (m *FusionInfo) XXX_Size() int {
	return xxx_messageInfo_FusionInfo.Size(m)
}
func (m *FusionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FusionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FusionInfo proto.InternalMessageInfo

func (m *FusionInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FusionInfo) GetFusionInfos() []*FuserFusionInfo {
	if m != nil {
		return m.FusionInfos
	}
	return nil
}

func (m *FusionInfo) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FusionInfo) GetHasFused() bool {
	if m != nil {
		return m.HasFused
	}
	return false
}

func (m *FusionInfo) GetFusedScore() float64 {
	if m != nil {
		return m.FusedScore
	}
	return 0
}

type FuseAllIDsRequest struct {
	FuserId              []string `protobuf:"bytes,1,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	OutDir               string   `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseAllIDsRequest) Reset()         { *m = FuseAllIDsRequest{} }
func (m *FuseAllIDsRequest) String() string { return proto.CompactTextString(m) }
func (*FuseAllIDsRequest) ProtoMessage()    {}
func (*FuseAllIDsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{10}
}

func (m *FuseAllIDsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseAllIDsRequest.Unmarshal(m, b)
}
func (m *FuseAllIDsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseAllIDsRequest.Marshal(b, m, deterministic)
}
func (m *FuseAllIDsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseAllIDsRequest.Merge(m, src)
}
func (m *FuseAllIDsRequest) XXX_Size() int {
	return xxx_messageInfo_FuseAllIDsRequest.Size(m)
}
func (m *FuseAllIDsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseAllIDsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseAllIDsRequest proto.InternalMessageInfo

func (m *FuseAllIDsRequest) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *FuseAllIDsRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

type FuseAllIDsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseAllIDsResponse) Reset()         { *m = FuseAllIDsResponse{} }
func (m *FuseAllIDsResponse) String() string { return proto.CompactTextString(m) }
func (*FuseAllIDsResponse) ProtoMessage()    {}
func (*FuseAllIDsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{11}
}

func (m *FuseAllIDsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseAllIDsResponse.Unmarshal(m, b)
}
func (m *FuseAllIDsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseAllIDsResponse.Marshal(b, m, deterministic)
}
func (m *FuseAllIDsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseAllIDsResponse.Merge(m, src)
}
func (m *FuseAllIDsResponse) XXX_Size() int {
	return xxx_messageInfo_FuseAllIDsResponse.Size(m)
}
func (m *FuseAllIDsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseAllIDsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FuseAllIDsResponse proto.InternalMessageInfo

// UpdateDetectionTagsRequest contains new tags to replace or merge with existing tags.
// Next Tag: 5
type UpdateDetectionTagsRequest struct {
	// The detection ID to update.
	DetectionId string `protobuf:"bytes,1,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	// If true, replaces all user tags with the given tag set. Default is to
	// merge (replacing any duplicates, but leaving unmentioned tag keys alone).
	// Ignores delete_tags if set.
	Replace bool `protobuf:"varint,2,opt,name=replace,proto3" json:"replace,omitempty"`
	// Tags to use in the request. Only updates user tags, not bare system tags.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Tag keys to delete. Only used if replace is false.
	DeleteTags           []string `protobuf:"bytes,4,rep,name=delete_tags,json=deleteTags,proto3" json:"delete_tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDetectionTagsRequest) Reset()         { *m = UpdateDetectionTagsRequest{} }
func (m *UpdateDetectionTagsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateDetectionTagsRequest) ProtoMessage()    {}
func (*UpdateDetectionTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{12}
}

func (m *UpdateDetectionTagsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateDetectionTagsRequest.Unmarshal(m, b)
}
func (m *UpdateDetectionTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateDetectionTagsRequest.Marshal(b, m, deterministic)
}
func (m *UpdateDetectionTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDetectionTagsRequest.Merge(m, src)
}
func (m *UpdateDetectionTagsRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateDetectionTagsRequest.Size(m)
}
func (m *UpdateDetectionTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDetectionTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDetectionTagsRequest proto.InternalMessageInfo

func (m *UpdateDetectionTagsRequest) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

func (m *UpdateDetectionTagsRequest) GetReplace() bool {
	if m != nil {
		return m.Replace
	}
	return false
}

func (m *UpdateDetectionTagsRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *UpdateDetectionTagsRequest) GetDeleteTags() []string {
	if m != nil {
		return m.DeleteTags
	}
	return nil
}

// DetectionTagInfoRequest asks for high-level information about detection tags.
type DetectionTagInfoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionTagInfoRequest) Reset()         { *m = DetectionTagInfoRequest{} }
func (m *DetectionTagInfoRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionTagInfoRequest) ProtoMessage()    {}
func (*DetectionTagInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{13}
}

func (m *DetectionTagInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionTagInfoRequest.Unmarshal(m, b)
}
func (m *DetectionTagInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionTagInfoRequest.Marshal(b, m, deterministic)
}
func (m *DetectionTagInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionTagInfoRequest.Merge(m, src)
}
func (m *DetectionTagInfoRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionTagInfoRequest.Size(m)
}
func (m *DetectionTagInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionTagInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionTagInfoRequest proto.InternalMessageInfo

// DetectionTagInfo contains high-level information about detection tags.
type DetectionTagInfo struct {
	// Contains mapping from "key=value" to number of times that specific key/value pair is found.
	TagCounts map[string]int32 `protobuf:"bytes,1,rep,name=tag_counts,json=tagCounts,proto3" json:"tag_counts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Contains mapping from "key=value" in *user tags* to number of times they appear.
	// Note that this can have overlap with system tags, and it will report these separately.
	UserTagCounts        map[string]int32 `protobuf:"bytes,2,rep,name=user_tag_counts,json=userTagCounts,proto3" json:"user_tag_counts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DetectionTagInfo) Reset()         { *m = DetectionTagInfo{} }
func (m *DetectionTagInfo) String() string { return proto.CompactTextString(m) }
func (*DetectionTagInfo) ProtoMessage()    {}
func (*DetectionTagInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{14}
}

func (m *DetectionTagInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionTagInfo.Unmarshal(m, b)
}
func (m *DetectionTagInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionTagInfo.Marshal(b, m, deterministic)
}
func (m *DetectionTagInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionTagInfo.Merge(m, src)
}
func (m *DetectionTagInfo) XXX_Size() int {
	return xxx_messageInfo_DetectionTagInfo.Size(m)
}
func (m *DetectionTagInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionTagInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionTagInfo proto.InternalMessageInfo

func (m *DetectionTagInfo) GetTagCounts() map[string]int32 {
	if m != nil {
		return m.TagCounts
	}
	return nil
}

func (m *DetectionTagInfo) GetUserTagCounts() map[string]int32 {
	if m != nil {
		return m.UserTagCounts
	}
	return nil
}

type DeleteDetectionRequest struct {
	DetectionId          string   `protobuf:"bytes,1,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteDetectionRequest) Reset()         { *m = DeleteDetectionRequest{} }
func (m *DeleteDetectionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteDetectionRequest) ProtoMessage()    {}
func (*DeleteDetectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{15}
}

func (m *DeleteDetectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteDetectionRequest.Unmarshal(m, b)
}
func (m *DeleteDetectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteDetectionRequest.Marshal(b, m, deterministic)
}
func (m *DeleteDetectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDetectionRequest.Merge(m, src)
}
func (m *DeleteDetectionRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteDetectionRequest.Size(m)
}
func (m *DeleteDetectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDetectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDetectionRequest proto.InternalMessageInfo

func (m *DeleteDetectionRequest) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

func init() {
	proto.RegisterEnum("mediforproto.SortKey", SortKey_name, SortKey_value)
	proto.RegisterEnum("mediforproto.FusionThresholdType", FusionThresholdType_name, FusionThresholdType_value)
	proto.RegisterType((*SortCol)(nil), "mediforproto.SortCol")
	proto.RegisterType((*DetectionRequest)(nil), "mediforproto.DetectionRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionRequest.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionRequest.TagsEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionRequest.UserTagsEntry")
	proto.RegisterType((*AnalyticDetectionInfo)(nil), "mediforproto.AnalyticDetectionInfo")
	proto.RegisterType((*DetectionInfo)(nil), "mediforproto.DetectionInfo")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionInfo.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionInfo.TagsEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionInfo.UserTagsEntry")
	proto.RegisterType((*DetectionInfoRequest)(nil), "mediforproto.DetectionInfoRequest")
	proto.RegisterType((*DetectionListRequest)(nil), "mediforproto.DetectionListRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionListRequest.TagsEntry")
	proto.RegisterType((*DetectionList)(nil), "mediforproto.DetectionList")
	proto.RegisterType((*FusionRequest)(nil), "mediforproto.FusionRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.FusionRequest.TagsEntry")
	proto.RegisterType((*FuserFusionInfo)(nil), "mediforproto.FuserFusionInfo")
	proto.RegisterType((*FusionInfo)(nil), "mediforproto.FusionInfo")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.FusionInfo.TagsEntry")
	proto.RegisterType((*FuseAllIDsRequest)(nil), "mediforproto.FuseAllIDsRequest")
	proto.RegisterType((*FuseAllIDsResponse)(nil), "mediforproto.FuseAllIDsResponse")
	proto.RegisterType((*UpdateDetectionTagsRequest)(nil), "mediforproto.UpdateDetectionTagsRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.UpdateDetectionTagsRequest.TagsEntry")
	proto.RegisterType((*DetectionTagInfoRequest)(nil), "mediforproto.DetectionTagInfoRequest")
	proto.RegisterType((*DetectionTagInfo)(nil), "mediforproto.DetectionTagInfo")
	proto.RegisterMapType((map[string]int32)(nil), "mediforproto.DetectionTagInfo.TagCountsEntry")
	proto.RegisterMapType((map[string]int32)(nil), "mediforproto.DetectionTagInfo.UserTagCountsEntry")
	proto.RegisterType((*DeleteDetectionRequest)(nil), "mediforproto.DeleteDetectionRequest")
}

func init() { proto.RegisterFile("medifor/v1/pipeline.proto", fileDescriptor_49bc7aaef7d70e21) }

var fileDescriptor_49bc7aaef7d70e21 = []byte{
	// 1431 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xdd, 0x6e, 0xdb, 0xc6,
	0x12, 0x0e, 0xf5, 0x4b, 0x8e, 0x2c, 0xdb, 0x59, 0xcb, 0x31, 0x23, 0x9f, 0x24, 0x0a, 0x73, 0x82,
	0xe8, 0x04, 0x89, 0x93, 0xe8, 0x9c, 0x9c, 0x34, 0x4d, 0x5a, 0xc4, 0xb1, 0xe5, 0x44, 0x88, 0x13,
	0x17, 0x94, 0x5c, 0xa0, 0x40, 0x00, 0x96, 0x11, 0x57, 0x36, 0x11, 0x99, 0x54, 0xb9, 0xab, 0x14,
	0xca, 0x5d, 0x1f, 0xa0, 0x6f, 0xd2, 0xab, 0xde, 0x15, 0xbd, 0xee, 0x3b, 0x14, 0x7d, 0x85, 0x3e,
	0x42, 0x6f, 0x8a, 0xdd, 0x25, 0xa9, 0x25, 0x25, 0xd1, 0x89, 0x0b, 0x14, 0xe8, 0x1d, 0x77, 0x66,
	0xf6, 0xdb, 0xd9, 0x99, 0x6f, 0x66, 0x96, 0x70, 0xf1, 0x04, 0x3b, 0xee, 0xc0, 0x0f, 0xee, 0xbc,
	0xbb, 0x77, 0x67, 0xe4, 0x8e, 0xf0, 0xd0, 0xf5, 0xf0, 0xd6, 0x28, 0xf0, 0xa9, 0x8f, 0x96, 0x42,
	0x15, 0x5f, 0xd5, 0x65, 0x43, 0xdb, 0xb3, 0x87, 0x13, 0xea, 0xf6, 0x85, 0x61, 0x7d, 0x43, 0x52,
	0x0d, 0xc6, 0xc4, 0xf5, 0x3d, 0xa1, 0x30, 0xbe, 0x53, 0xa0, 0xdc, 0xf5, 0x03, 0xba, 0xe3, 0x0f,
	0xd1, 0x0d, 0xc8, 0xbf, 0xc5, 0x13, 0x5d, 0x69, 0x28, 0xcd, 0xe5, 0xd6, 0xfa, 0x96, 0x8c, 0xbd,
	0xc5, 0x6c, 0x5e, 0xe0, 0x89, 0xc9, 0x2c, 0xd0, 0x3a, 0x94, 0x5c, 0x62, 0xd9, 0xa4, 0xaf, 0xe7,
	0x1a, 0x4a, 0x53, 0x35, 0x8b, 0x2e, 0xd9, 0x26, 0x7d, 0xb4, 0x09, 0x1a, 0x9d, 0x8c, 0xb0, 0xd5,
	0xb7, 0x09, 0xd5, 0xf3, 0x0d, 0xa5, 0xa9, 0x99, 0x2a, 0x13, 0xec, 0xd8, 0x84, 0xa2, 0x8b, 0xa0,
	0x9e, 0x60, 0x6a, 0x5b, 0xec, 0x84, 0x02, 0xd7, 0x95, 0xd9, 0xfa, 0x05, 0x9e, 0x18, 0x3f, 0x15,
	0x60, 0x75, 0x17, 0x53, 0xdc, 0xa7, 0xae, 0xef, 0x99, 0xf8, 0x9b, 0x31, 0x26, 0x14, 0x2d, 0x43,
	0xce, 0x75, 0x42, 0x94, 0x9c, 0xeb, 0xa0, 0x7b, 0x50, 0x0e, 0x84, 0x8a, 0x3b, 0x58, 0x69, 0x6d,
	0x24, 0x1d, 0x9c, 0x02, 0x44, 0x76, 0xe8, 0x0a, 0x54, 0xa2, 0x30, 0x58, 0xae, 0xa3, 0xe7, 0x1a,
	0xf9, 0xa6, 0x66, 0x42, 0x24, 0xea, 0x38, 0xcc, 0xa7, 0xc1, 0x98, 0xe0, 0x80, 0x69, 0x55, 0xae,
	0x2d, 0xf3, 0x75, 0xc7, 0x41, 0x8f, 0xa1, 0x40, 0xed, 0x23, 0xa2, 0x17, 0x1a, 0xf9, 0x66, 0xa5,
	0xd5, 0x5c, 0x74, 0x96, 0x38, 0x69, 0xab, 0x67, 0x1f, 0x91, 0xb6, 0x47, 0x83, 0x89, 0xc9, 0x77,
	0xa1, 0x0e, 0x68, 0x1c, 0x97, 0x43, 0x94, 0x38, 0xc4, 0xad, 0x53, 0x20, 0x0e, 0x09, 0x0e, 0xa6,
	0x30, 0xea, 0x38, 0x5c, 0x32, 0x47, 0x58, 0x9c, 0xf4, 0xf2, 0x07, 0x39, 0xf2, 0x12, 0x53, 0x3b,
	0x74, 0x84, 0xed, 0x42, 0x77, 0xa1, 0x16, 0x87, 0x80, 0xba, 0x27, 0xd8, 0x1f, 0x53, 0x8b, 0xe0,
	0xbe, 0x5e, 0x6c, 0x28, 0xcd, 0xbc, 0x89, 0x22, 0x5d, 0x4f, 0xa8, 0xba, 0xb8, 0x5f, 0x7f, 0x00,
	0x5a, 0xec, 0x06, 0x5a, 0x9d, 0x32, 0x42, 0x13, 0xa9, 0xaf, 0x41, 0xf1, 0x9d, 0x3d, 0x1c, 0x63,
	0x9e, 0x79, 0xcd, 0x14, 0x8b, 0x4f, 0x73, 0x9f, 0x28, 0xf5, 0x47, 0x50, 0x4d, 0xdc, 0xe1, 0xa3,
	0x36, 0x3f, 0x00, 0x2d, 0x76, 0xfd, 0x63, 0x36, 0x1a, 0xbf, 0x29, 0xb0, 0xbe, 0x1d, 0xde, 0x22,
	0x8e, 0x46, 0xc7, 0x1b, 0xf8, 0xe9, 0xec, 0x0b, 0x34, 0x39, 0xfb, 0x2d, 0x28, 0x12, 0x6a, 0x1f,
	0x09, 0xd0, 0xe5, 0xd6, 0xbf, 0x16, 0x84, 0xb6, 0xcb, 0x6c, 0x4c, 0x61, 0x8a, 0xee, 0x43, 0x89,
	0x50, 0x9b, 0x8e, 0x09, 0x67, 0xe6, 0x72, 0xeb, 0xd2, 0xe2, 0x4d, 0x74, 0x4c, 0xcc, 0xd0, 0x18,
	0xdd, 0x07, 0xcd, 0x89, 0x54, 0x9c, 0xfd, 0x19, 0xf4, 0x9d, 0x5a, 0x1a, 0x3f, 0x14, 0xa1, 0x9a,
	0xbc, 0x94, 0xa8, 0x0a, 0x25, 0xae, 0x8a, 0xe7, 0x50, 0x9d, 0x5e, 0xd2, 0x1b, 0xf8, 0x9c, 0xe4,
	0x95, 0xd6, 0xb5, 0x24, 0xf8, 0xdc, 0x00, 0x99, 0x4b, 0x71, 0x2c, 0x18, 0xf2, 0xe7, 0x50, 0x11,
	0x8d, 0x41, 0xe0, 0xa8, 0x1c, 0x27, 0x75, 0xbd, 0x3d, 0xc6, 0xca, 0x3d, 0x6e, 0xc5, 0x11, 0x60,
	0x10, 0x7f, 0xa3, 0x87, 0x61, 0xc1, 0xe4, 0xf9, 0xc6, 0xeb, 0x0b, 0x6e, 0xc7, 0x4c, 0x67, 0xaa,
	0x65, 0x6f, 0xb6, 0x5a, 0xfe, 0x93, 0xb5, 0x7f, 0x51, 0xa9, 0x3c, 0x4c, 0x94, 0x4a, 0xa6, 0x0b,
	0xe9, 0x3a, 0xd9, 0x04, 0xed, 0xd8, 0x26, 0x16, 0xab, 0x7e, 0x87, 0x27, 0x48, 0x35, 0xd5, 0x63,
	0x9b, 0xb0, 0x0b, 0x3b, 0x8c, 0x49, 0x5c, 0x61, 0x91, 0xbe, 0x1f, 0x60, 0x5e, 0x3b, 0x0a, 0xbf,
	0x3b, 0x76, 0xba, 0x4c, 0x82, 0x6e, 0xc0, 0x4a, 0x14, 0x4b, 0x62, 0x51, 0x9f, 0xda, 0x43, 0x5d,
	0x6b, 0x28, 0xcd, 0xa2, 0xb9, 0x1c, 0x8b, 0x7b, 0x4c, 0x8a, 0x6e, 0x03, 0x9a, 0x1a, 0x0e, 0x5c,
	0xcf, 0x25, 0xc7, 0xd8, 0xd1, 0x81, 0xdb, 0x9e, 0x8f, 0x35, 0x7b, 0xa1, 0xe2, 0x9f, 0x56, 0x8b,
	0x6d, 0xa8, 0x25, 0x19, 0x96, 0x68, 0xe5, 0x53, 0xd2, 0x5e, 0x02, 0xf8, 0xd6, 0xf6, 0x68, 0x18,
	0x6d, 0x31, 0x42, 0x34, 0x26, 0xe1, 0xe1, 0x36, 0x7e, 0xcf, 0x4b, 0x38, 0xfb, 0x2e, 0xa1, 0x11,
	0xce, 0x93, 0x90, 0x62, 0x4a, 0x66, 0x43, 0x95, 0x76, 0xcc, 0x30, 0xed, 0x1a, 0x54, 0xe3, 0xea,
	0xb2, 0x5c, 0x87, 0x70, 0xaa, 0x68, 0xe6, 0x52, 0x2c, 0xec, 0x38, 0x24, 0xe5, 0x5e, 0x21, 0xe5,
	0x1e, 0xba, 0x0b, 0xaa, 0x1f, 0x38, 0x38, 0xb0, 0xde, 0x4c, 0xf4, 0x22, 0xf7, 0x64, 0xce, 0xa8,
	0xdc, 0xf1, 0x87, 0x66, 0x99, 0x9b, 0x3d, 0x9d, 0x24, 0xc6, 0x4c, 0x49, 0x8c, 0xbe, 0x68, 0xcc,
	0x1c, 0xc2, 0x7a, 0x58, 0x75, 0xf4, 0x38, 0xc0, 0xe4, 0xd8, 0x1f, 0x3a, 0x16, 0x1b, 0x99, 0xba,
	0xca, 0xdb, 0xcb, 0xd5, 0x99, 0xfa, 0x73, 0x7d, 0xaf, 0x17, 0x59, 0xf6, 0x26, 0x23, 0x6c, 0xae,
	0x0d, 0x66, 0x85, 0xe8, 0x7f, 0x70, 0x61, 0x06, 0x56, 0x24, 0x8d, 0xf1, 0x32, 0x67, 0xd6, 0x52,
	0x9b, 0xbe, 0x64, 0x3a, 0x56, 0x04, 0x23, 0xfb, 0x08, 0x5b, 0xc4, 0x7d, 0x2f, 0xb2, 0x5b, 0x34,
	0x55, 0x26, 0xe8, 0xba, 0xef, 0x31, 0x8b, 0x0a, 0x57, 0x52, 0xff, 0x2d, 0xf6, 0xc2, 0xb9, 0xcc,
	0xcd, 0x7b, 0x4c, 0x70, 0x66, 0xaa, 0xb2, 0x07, 0x48, 0x35, 0x91, 0x3b, 0xf4, 0x08, 0x20, 0xce,
	0x47, 0x94, 0xec, 0xcd, 0x8c, 0x62, 0x36, 0x25, 0x73, 0x76, 0x90, 0x28, 0xc0, 0x3c, 0xf7, 0x5f,
	0x2c, 0x52, 0xce, 0xe7, 0x52, 0xce, 0x1b, 0x3f, 0xe6, 0xa0, 0x2a, 0x62, 0xbb, 0x88, 0xb2, 0x5b,
	0xd3, 0xd7, 0x47, 0x8e, 0xb7, 0xef, 0xda, 0xbc, 0xcc, 0x4c, 0x9f, 0x1e, 0x72, 0xca, 0x0b, 0xc9,
	0x97, 0x45, 0x66, 0xa3, 0x4c, 0x78, 0x31, 0x43, 0xdf, 0xab, 0xb0, 0x24, 0xd3, 0x97, 0x77, 0x22,
	0xcd, 0xac, 0x48, 0xec, 0x45, 0x77, 0xa0, 0x26, 0x9b, 0x58, 0x6c, 0xe0, 0x3b, 0x6e, 0x10, 0xf2,
	0xee, 0xbc, 0x64, 0x7a, 0x30, 0xa6, 0xbb, 0x6e, 0x70, 0xf6, 0xc4, 0xfd, 0xa2, 0xc0, 0x4a, 0x6a,
	0x20, 0x24, 0xae, 0xad, 0x24, 0x99, 0xfe, 0x37, 0x4e, 0xdb, 0x5b, 0x50, 0x12, 0xfc, 0x0e, 0x47,
	0xed, 0xfc, 0x5c, 0x85, 0x36, 0xc6, 0xf7, 0x39, 0x00, 0xe9, 0x0a, 0xe9, 0xcc, 0x3f, 0x81, 0x25,
	0x69, 0x2e, 0x92, 0x70, 0xc0, 0x9e, 0x32, 0x18, 0x2b, 0xd3, 0xc1, 0x48, 0xd0, 0xff, 0x13, 0x09,
	0x37, 0xe6, 0x39, 0x33, 0x77, 0x2c, 0xfe, 0xa5, 0x99, 0x74, 0xf6, 0xbc, 0x3e, 0x83, 0xf3, 0xec,
	0x88, 0xed, 0xe1, 0xb0, 0xb3, 0x4b, 0xcc, 0x39, 0x7c, 0x56, 0x92, 0x7c, 0xde, 0x80, 0x72, 0x44,
	0x32, 0x81, 0x55, 0xf2, 0x39, 0xb3, 0x8c, 0x1a, 0x20, 0x19, 0x88, 0x8c, 0x7c, 0x8f, 0x60, 0xe3,
	0x0f, 0x05, 0xea, 0x87, 0x23, 0xc7, 0xa6, 0x38, 0x4e, 0x1f, 0xf3, 0x33, 0x3a, 0x28, 0x4d, 0x71,
	0x65, 0x96, 0xe2, 0x3a, 0xab, 0xc5, 0xd1, 0xd0, 0xee, 0xe3, 0x70, 0x76, 0x44, 0x4b, 0xb4, 0x97,
	0x88, 0x74, 0x2b, 0x19, 0xe9, 0xc5, 0x87, 0xce, 0x44, 0xfe, 0x0a, 0x54, 0x1c, 0x3c, 0xc4, 0x14,
	0x5b, 0xf1, 0x3f, 0x80, 0xc6, 0xba, 0x0c, 0x13, 0x31, 0xdb, 0xb3, 0x07, 0xf7, 0x22, 0x6c, 0xc8,
	0x1e, 0x48, 0x53, 0xd2, 0xf8, 0x39, 0x27, 0xfd, 0x05, 0x85, 0x3a, 0xb4, 0x0f, 0x40, 0xed, 0x23,
	0xab, 0xef, 0x8f, 0x3d, 0x1a, 0xf5, 0xc2, 0xdb, 0x0b, 0xaa, 0x20, 0xdc, 0xc3, 0x6e, 0xb3, 0xc3,
	0xed, 0xc5, 0x95, 0x34, 0x1a, 0xad, 0xd1, 0x57, 0xb0, 0x12, 0x3d, 0xb4, 0x22, 0x48, 0x41, 0xe7,
	0x7b, 0xa7, 0x40, 0x86, 0x8f, 0x09, 0x19, 0xb6, 0x3a, 0x96, 0x65, 0xf5, 0xc7, 0xb0, 0x9c, 0x34,
	0x38, 0x2d, 0x2c, 0x45, 0xf9, 0xc9, 0xf1, 0x04, 0xd0, 0xec, 0x11, 0x1f, 0x83, 0x60, 0x3c, 0x82,
	0x0b, 0xbb, 0x3c, 0x3f, 0x33, 0x3f, 0x92, 0xa7, 0x33, 0xea, 0xe6, 0x65, 0xf1, 0x0f, 0xfc, 0x02,
	0x4f, 0x90, 0x06, 0xc5, 0xee, 0xce, 0x81, 0xd9, 0x5e, 0x3d, 0x87, 0x54, 0x28, 0xbc, 0x6c, 0xf7,
	0xb6, 0x57, 0x95, 0x9b, 0x5f, 0xc3, 0xda, 0x9c, 0xd1, 0x8b, 0x36, 0x60, 0x6d, 0xef, 0xb0, 0xdb,
	0x39, 0x78, 0x65, 0xbd, 0x3a, 0xb0, 0x7a, 0xcf, 0xcd, 0x76, 0xf7, 0xf9, 0xc1, 0xfe, 0xee, 0xea,
	0x39, 0x49, 0xb1, 0xdf, 0x93, 0x14, 0x8a, 0xa4, 0x78, 0x26, 0x2b, 0x72, 0xad, 0x5f, 0x8b, 0xa0,
	0x7e, 0x11, 0xfe, 0xdb, 0xa3, 0x36, 0x94, 0xc4, 0x2d, 0xd0, 0xe5, 0xec, 0xdf, 0xbd, 0x7a, 0xd6,
	0x58, 0x44, 0x5d, 0x58, 0x7d, 0x86, 0x69, 0x52, 0x66, 0x64, 0xcd, 0xd1, 0x33, 0x80, 0xf2, 0x81,
	0x6d, 0x9c, 0xfe, 0x12, 0x5b, 0x08, 0xca, 0x01, 0xf6, 0x61, 0x25, 0x95, 0x3c, 0xf4, 0xef, 0xb4,
	0xfd, 0xbc, 0xdc, 0xd6, 0xd7, 0x92, 0x56, 0xed, 0x93, 0x11, 0x9d, 0xa0, 0xcf, 0xa0, 0xc0, 0xfa,
	0x0e, 0xda, 0xcc, 0x18, 0xad, 0x75, 0x7d, 0x51, 0x1b, 0x46, 0xdb, 0xa0, 0xb2, 0xed, 0x4f, 0x27,
	0x9d, 0xdd, 0xb3, 0x42, 0x1c, 0xf0, 0x89, 0x12, 0x76, 0x3e, 0x74, 0x65, 0x76, 0x56, 0x24, 0x9a,
	0x6b, 0xbd, 0xb1, 0xd8, 0x40, 0x34, 0x4d, 0xf4, 0x1a, 0xd6, 0xe6, 0xb4, 0x2f, 0xd4, 0xfc, 0xd0,
	0x0e, 0x97, 0x9d, 0xd3, 0xd7, 0xb0, 0x26, 0xe7, 0x34, 0xea, 0x3d, 0xd7, 0xb3, 0x9b, 0x42, 0x04,
	0x7d, 0x39, 0xdb, 0xec, 0x4d, 0x89, 0xcb, 0xff, 0xfb, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x53,
	0x1c, 0xbc, 0x27, 0xc7, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PipelineClient is the client API for Pipeline service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PipelineClient interface {
	Detect(ctx context.Context, in *DetectionRequest, opts ...grpc.CallOption) (*DetectionInfo, error)
	GetDetectionInfo(ctx context.Context, in *DetectionInfoRequest, opts ...grpc.CallOption) (*DetectionInfo, error)
	GetDetectionList(ctx context.Context, in *DetectionListRequest, opts ...grpc.CallOption) (*DetectionList, error)
	DeleteDetection(ctx context.Context, in *DeleteDetectionRequest, opts ...grpc.CallOption) (*Empty, error)
	Fuse(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error)
	FuseByID(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error)
	FuseAllIDs(ctx context.Context, in *FuseAllIDsRequest, opts ...grpc.CallOption) (*FuseAllIDsResponse, error)
	UpdateDetectionTags(ctx context.Context, in *UpdateDetectionTagsRequest, opts ...grpc.CallOption) (*DetectionInfo, error)
	GetDetectionTagInfo(ctx context.Context, in *DetectionTagInfoRequest, opts ...grpc.CallOption) (*DetectionTagInfo, error)
}

type pipelineClient struct {
	cc *grpc.ClientConn
}

func NewPipelineClient(cc *grpc.ClientConn) PipelineClient {
	return &pipelineClient{cc}
}

func (c *pipelineClient) Detect(ctx context.Context, in *DetectionRequest, opts ...grpc.CallOption) (*DetectionInfo, error) {
	out := new(DetectionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetDetectionInfo(ctx context.Context, in *DetectionInfoRequest, opts ...grpc.CallOption) (*DetectionInfo, error) {
	out := new(DetectionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetDetectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetDetectionList(ctx context.Context, in *DetectionListRequest, opts ...grpc.CallOption) (*DetectionList, error) {
	out := new(DetectionList)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetDetectionList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) DeleteDetection(ctx context.Context, in *DeleteDetectionRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/DeleteDetection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) Fuse(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error) {
	out := new(FusionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/Fuse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) FuseByID(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error) {
	out := new(FusionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/FuseByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) FuseAllIDs(ctx context.Context, in *FuseAllIDsRequest, opts ...grpc.CallOption) (*FuseAllIDsResponse, error) {
	out := new(FuseAllIDsResponse)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/FuseAllIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) UpdateDetectionTags(ctx context.Context, in *UpdateDetectionTagsRequest, opts ...grpc.CallOption) (*DetectionInfo, error) {
	out := new(DetectionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/UpdateDetectionTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetDetectionTagInfo(ctx context.Context, in *DetectionTagInfoRequest, opts ...grpc.CallOption) (*DetectionTagInfo, error) {
	out := new(DetectionTagInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetDetectionTagInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PipelineServer is the server API for Pipeline service.
type PipelineServer interface {
	Detect(context.Context, *DetectionRequest) (*DetectionInfo, error)
	GetDetectionInfo(context.Context, *DetectionInfoRequest) (*DetectionInfo, error)
	GetDetectionList(context.Context, *DetectionListRequest) (*DetectionList, error)
	DeleteDetection(context.Context, *DeleteDetectionRequest) (*Empty, error)
	Fuse(context.Context, *FusionRequest) (*FusionInfo, error)
	FuseByID(context.Context, *FusionRequest) (*FusionInfo, error)
	FuseAllIDs(context.Context, *FuseAllIDsRequest) (*FuseAllIDsResponse, error)
	UpdateDetectionTags(context.Context, *UpdateDetectionTagsRequest) (*DetectionInfo, error)
	GetDetectionTagInfo(context.Context, *DetectionTagInfoRequest) (*DetectionTagInfo, error)
}

func RegisterPipelineServer(s *grpc.Server, srv PipelineServer) {
	s.RegisterService(&_Pipeline_serviceDesc, srv)
}

func _Pipeline_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).Detect(ctx, req.(*DetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetDetectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetDetectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetDetectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetDetectionInfo(ctx, req.(*DetectionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetDetectionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetDetectionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetDetectionList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetDetectionList(ctx, req.(*DetectionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_DeleteDetection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).DeleteDetection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/DeleteDetection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).DeleteDetection(ctx, req.(*DeleteDetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_Fuse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).Fuse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/Fuse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).Fuse(ctx, req.(*FusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_FuseByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).FuseByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/FuseByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).FuseByID(ctx, req.(*FusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_FuseAllIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseAllIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).FuseAllIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/FuseAllIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).FuseAllIDs(ctx, req.(*FuseAllIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_UpdateDetectionTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDetectionTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).UpdateDetectionTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/UpdateDetectionTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).UpdateDetectionTags(ctx, req.(*UpdateDetectionTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetDetectionTagInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionTagInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetDetectionTagInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetDetectionTagInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetDetectionTagInfo(ctx, req.(*DetectionTagInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pipeline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mediforproto.Pipeline",
	HandlerType: (*PipelineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Detect",
			Handler:    _Pipeline_Detect_Handler,
		},
		{
			MethodName: "GetDetectionInfo",
			Handler:    _Pipeline_GetDetectionInfo_Handler,
		},
		{
			MethodName: "GetDetectionList",
			Handler:    _Pipeline_GetDetectionList_Handler,
		},
		{
			MethodName: "DeleteDetection",
			Handler:    _Pipeline_DeleteDetection_Handler,
		},
		{
			MethodName: "Fuse",
			Handler:    _Pipeline_Fuse_Handler,
		},
		{
			MethodName: "FuseByID",
			Handler:    _Pipeline_FuseByID_Handler,
		},
		{
			MethodName: "FuseAllIDs",
			Handler:    _Pipeline_FuseAllIDs_Handler,
		},
		{
			MethodName: "UpdateDetectionTags",
			Handler:    _Pipeline_UpdateDetectionTags_Handler,
		},
		{
			MethodName: "GetDetectionTagInfo",
			Handler:    _Pipeline_GetDetectionTagInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "medifor/v1/pipeline.proto",
}
