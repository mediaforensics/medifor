// Code generated by protoc-gen-go. DO NOT EDIT.
// source: analytic.proto

package mediforproto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ManipulationType int32

const (
	ManipulationType_MANIP_UNKNOWN            ManipulationType = 0
	ManipulationType_MANIP_FILTER             ManipulationType = 1
	ManipulationType_MANIP_ADJUST_COLOR       ManipulationType = 2
	ManipulationType_MANIP_REMOVE             ManipulationType = 3
	ManipulationType_MANIP_CONTENT_AWARE_FILL ManipulationType = 4
	ManipulationType_MANIP_PAINTBRUSH_TOOL    ManipulationType = 5
	ManipulationType_MANIP_PATCH_TOOL         ManipulationType = 6
	ManipulationType_MANIP_BLUR               ManipulationType = 7
	ManipulationType_MANIP_SPLICE             ManipulationType = 8
	ManipulationType_MANIP_CLONE              ManipulationType = 9
	ManipulationType_MANIP_CROP               ManipulationType = 10
	ManipulationType_MANIP_FLIP               ManipulationType = 11
	ManipulationType_MANIP_RESIZE             ManipulationType = 12
	ManipulationType_MANIP_SEAM_CARVING       ManipulationType = 13
	ManipulationType_MANIP_ROTATE             ManipulationType = 14
	ManipulationType_MANIP_SKEW               ManipulationType = 15
	ManipulationType_MANIP_WARP               ManipulationType = 16
	ManipulationType_MANIP_METADATA           ManipulationType = 17
	ManipulationType_MANIP_ANTIFORENSICS      ManipulationType = 18
	ManipulationType_MANIP_IMAGE_RECAPTURE    ManipulationType = 19
	ManipulationType_MANIP_CGI                ManipulationType = 20
	ManipulationType_MANIP_FRAME_INSERTION    ManipulationType = 21
	ManipulationType_MANIP_FRAME_DROP         ManipulationType = 22
	ManipulationType_MANIP_AUDIO              ManipulationType = 23
	ManipulationType_MANIP_DOUBLE_JPG         ManipulationType = 24
	ManipulationType_MANIP_OTHER              ManipulationType = 25
)

var ManipulationType_name = map[int32]string{
	0:  "MANIP_UNKNOWN",
	1:  "MANIP_FILTER",
	2:  "MANIP_ADJUST_COLOR",
	3:  "MANIP_REMOVE",
	4:  "MANIP_CONTENT_AWARE_FILL",
	5:  "MANIP_PAINTBRUSH_TOOL",
	6:  "MANIP_PATCH_TOOL",
	7:  "MANIP_BLUR",
	8:  "MANIP_SPLICE",
	9:  "MANIP_CLONE",
	10: "MANIP_CROP",
	11: "MANIP_FLIP",
	12: "MANIP_RESIZE",
	13: "MANIP_SEAM_CARVING",
	14: "MANIP_ROTATE",
	15: "MANIP_SKEW",
	16: "MANIP_WARP",
	17: "MANIP_METADATA",
	18: "MANIP_ANTIFORENSICS",
	19: "MANIP_IMAGE_RECAPTURE",
	20: "MANIP_CGI",
	21: "MANIP_FRAME_INSERTION",
	22: "MANIP_FRAME_DROP",
	23: "MANIP_AUDIO",
	24: "MANIP_DOUBLE_JPG",
	25: "MANIP_OTHER",
}

var ManipulationType_value = map[string]int32{
	"MANIP_UNKNOWN":            0,
	"MANIP_FILTER":             1,
	"MANIP_ADJUST_COLOR":       2,
	"MANIP_REMOVE":             3,
	"MANIP_CONTENT_AWARE_FILL": 4,
	"MANIP_PAINTBRUSH_TOOL":    5,
	"MANIP_PATCH_TOOL":         6,
	"MANIP_BLUR":               7,
	"MANIP_SPLICE":             8,
	"MANIP_CLONE":              9,
	"MANIP_CROP":               10,
	"MANIP_FLIP":               11,
	"MANIP_RESIZE":             12,
	"MANIP_SEAM_CARVING":       13,
	"MANIP_ROTATE":             14,
	"MANIP_SKEW":               15,
	"MANIP_WARP":               16,
	"MANIP_METADATA":           17,
	"MANIP_ANTIFORENSICS":      18,
	"MANIP_IMAGE_RECAPTURE":    19,
	"MANIP_CGI":                20,
	"MANIP_FRAME_INSERTION":    21,
	"MANIP_FRAME_DROP":         22,
	"MANIP_AUDIO":              23,
	"MANIP_DOUBLE_JPG":         24,
	"MANIP_OTHER":              25,
}

func (x ManipulationType) String() string {
	return proto.EnumName(ManipulationType_name, int32(x))
}

func (ManipulationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{0}
}

type SpecificityType int32

const (
	SpecificityType_SPEC_GLOBAL   SpecificityType = 0
	SpecificityType_SPEC_FRAME    SpecificityType = 1
	SpecificityType_SPEC_PIXEL    SpecificityType = 2
	SpecificityType_SPEC_METADATA SpecificityType = 3
)

var SpecificityType_name = map[int32]string{
	0: "SPEC_GLOBAL",
	1: "SPEC_FRAME",
	2: "SPEC_PIXEL",
	3: "SPEC_METADATA",
}

var SpecificityType_value = map[string]int32{
	"SPEC_GLOBAL":   0,
	"SPEC_FRAME":    1,
	"SPEC_PIXEL":    2,
	"SPEC_METADATA": 3,
}

func (x SpecificityType) String() string {
	return proto.EnumName(SpecificityType_name, int32(x))
}

func (SpecificityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{1}
}

type DetectionStage int32

const (
	DetectionStage_DETECTION_STAGE_NONE     DetectionStage = 0
	DetectionStage_DETECTION_STAGE_QUEUED   DetectionStage = 1
	DetectionStage_DETECTION_STAGE_CLAIMED  DetectionStage = 2
	DetectionStage_DETECTION_STAGE_FINISHED DetectionStage = 3
)

var DetectionStage_name = map[int32]string{
	0: "DETECTION_STAGE_NONE",
	1: "DETECTION_STAGE_QUEUED",
	2: "DETECTION_STAGE_CLAIMED",
	3: "DETECTION_STAGE_FINISHED",
}

var DetectionStage_value = map[string]int32{
	"DETECTION_STAGE_NONE":     0,
	"DETECTION_STAGE_QUEUED":   1,
	"DETECTION_STAGE_CLAIMED":  2,
	"DETECTION_STAGE_FINISHED": 3,
}

func (x DetectionStage) String() string {
	return proto.EnumName(DetectionStage_name, int32(x))
}

func (DetectionStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{2}
}

type DetectionStatus int32

const (
	DetectionStatus_DETECTION_STATUS_NONE    DetectionStatus = 0
	DetectionStatus_DETECTION_STATUS_SUCCESS DetectionStatus = 1
	DetectionStatus_DETECTION_STATUS_FAILURE DetectionStatus = 2
)

var DetectionStatus_name = map[int32]string{
	0: "DETECTION_STATUS_NONE",
	1: "DETECTION_STATUS_SUCCESS",
	2: "DETECTION_STATUS_FAILURE",
}

var DetectionStatus_value = map[string]int32{
	"DETECTION_STATUS_NONE":    0,
	"DETECTION_STATUS_SUCCESS": 1,
	"DETECTION_STATUS_FAILURE": 2,
}

func (x DetectionStatus) String() string {
	return proto.EnumName(DetectionStatus_name, int32(x))
}

func (DetectionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{3}
}

type OptOutType int32

const (
	// Nothing was opted out (everything processed). The default value.
	OptOutType_OPT_OUT_NONE OptOutType = 0
	// Everything was opted out. No procesing was attempted. Note that this
	// should *not* be used to indicate "we tried but got an error". This is
	// a "look before you leap" value, indicating "we noticed that there
	// was no point in trying in the first place". A legitimate use of this
	// might be to indicate that the image's mime type is unknown, for example.
	OptOutType_OPT_OUT_ALL OptOutType = 1
	// No score will be provided for this image, but *localization information
	// will*. Use this if you know where things look suspicious, but don't
	// think you can produce a score.
	OptOutType_OPT_OUT_DETECTION OptOutType = 2
	// No masks will be provided for this image.
	OptOutType_OPT_OUT_LOCALIZATION OptOutType = 3
)

var OptOutType_name = map[int32]string{
	0: "OPT_OUT_NONE",
	1: "OPT_OUT_ALL",
	2: "OPT_OUT_DETECTION",
	3: "OPT_OUT_LOCALIZATION",
}

var OptOutType_value = map[string]int32{
	"OPT_OUT_NONE":         0,
	"OPT_OUT_ALL":          1,
	"OPT_OUT_DETECTION":    2,
	"OPT_OUT_LOCALIZATION": 3,
}

func (x OptOutType) String() string {
	return proto.EnumName(OptOutType_name, int32(x))
}

func (OptOutType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{4}
}

type VideoOptOutType int32

const (
	// No score will be provided for this video.
	VideoOptOutType_VIDEO_OPT_OUT_DETECTION VideoOptOutType = 0
	// No temporal information for manipulations are to be provided.
	VideoOptOutType_VIDEO_OPT_OUT_TEMPORAL VideoOptOutType = 1
	// No spatial information for manipulations are to be provided.
	VideoOptOutType_VIDEO_OPT_OUT_SPATIAL VideoOptOutType = 2
)

var VideoOptOutType_name = map[int32]string{
	0: "VIDEO_OPT_OUT_DETECTION",
	1: "VIDEO_OPT_OUT_TEMPORAL",
	2: "VIDEO_OPT_OUT_SPATIAL",
}

var VideoOptOutType_value = map[string]int32{
	"VIDEO_OPT_OUT_DETECTION": 0,
	"VIDEO_OPT_OUT_TEMPORAL":  1,
	"VIDEO_OPT_OUT_SPATIAL":   2,
}

func (x VideoOptOutType) String() string {
	return proto.EnumName(VideoOptOutType_name, int32(x))
}

func (VideoOptOutType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{5}
}

// Detection holds round-trip information for any of the "DetectFoo" request/response endpoints.
type Detection struct {
	// Standard RPC status - we stash the actual RPC error/non-error here.
	Status *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Round-trip request-response timings. Milliseconds since the Epoch.
	StartTimeMillis int64 `protobuf:"varint,2,opt,name=start_time_millis,json=startTimeMillis,proto3" json:"start_time_millis,omitempty"`
	EndTimeMillis   int64 `protobuf:"varint,3,opt,name=end_time_millis,json=endTimeMillis,proto3" json:"end_time_millis,omitempty"`
	// The request made to the analytic.
	//
	// Types that are valid to be assigned to Request:
	//	*Detection_ImgManipReq
	//	*Detection_VidManipReq
	//	*Detection_ImgSpliceReq
	//	*Detection_ImgCamMatchReq
	//	*Detection_ImgCamsReq
	//	*Detection_VidCamMatchReq
	Request isDetection_Request `protobuf_oneof:"request"`
	// The response received from the analytic.
	//
	// Types that are valid to be assigned to Response:
	//	*Detection_ImgManip
	//	*Detection_VidManip
	//	*Detection_ImgSplice
	//	*Detection_ImgCamMatch
	//	*Detection_ImgCams
	//	*Detection_VidCamMatch
	Response             isDetection_Response `protobuf_oneof:"response"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Detection) Reset()         { *m = Detection{} }
func (m *Detection) String() string { return proto.CompactTextString(m) }
func (*Detection) ProtoMessage()    {}
func (*Detection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{0}
}

func (m *Detection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Detection.Unmarshal(m, b)
}
func (m *Detection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Detection.Marshal(b, m, deterministic)
}
func (m *Detection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detection.Merge(m, src)
}
func (m *Detection) XXX_Size() int {
	return xxx_messageInfo_Detection.Size(m)
}
func (m *Detection) XXX_DiscardUnknown() {
	xxx_messageInfo_Detection.DiscardUnknown(m)
}

var xxx_messageInfo_Detection proto.InternalMessageInfo

func (m *Detection) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Detection) GetStartTimeMillis() int64 {
	if m != nil {
		return m.StartTimeMillis
	}
	return 0
}

func (m *Detection) GetEndTimeMillis() int64 {
	if m != nil {
		return m.EndTimeMillis
	}
	return 0
}

type isDetection_Request interface {
	isDetection_Request()
}

type Detection_ImgManipReq struct {
	ImgManipReq *ImageManipulationRequest `protobuf:"bytes,11,opt,name=img_manip_req,json=imgManipReq,proto3,oneof"`
}

type Detection_VidManipReq struct {
	VidManipReq *VideoManipulationRequest `protobuf:"bytes,12,opt,name=vid_manip_req,json=vidManipReq,proto3,oneof"`
}

type Detection_ImgSpliceReq struct {
	ImgSpliceReq *ImageSpliceRequest `protobuf:"bytes,13,opt,name=img_splice_req,json=imgSpliceReq,proto3,oneof"`
}

type Detection_ImgCamMatchReq struct {
	ImgCamMatchReq *ImageCameraMatchRequest `protobuf:"bytes,14,opt,name=img_cam_match_req,json=imgCamMatchReq,proto3,oneof"`
}

type Detection_ImgCamsReq struct {
	ImgCamsReq *ImageCamerasRequest `protobuf:"bytes,15,opt,name=img_cams_req,json=imgCamsReq,proto3,oneof"`
}

type Detection_VidCamMatchReq struct {
	VidCamMatchReq *VideoCameraMatchRequest `protobuf:"bytes,16,opt,name=vid_cam_match_req,json=vidCamMatchReq,proto3,oneof"`
}

func (*Detection_ImgManipReq) isDetection_Request() {}

func (*Detection_VidManipReq) isDetection_Request() {}

func (*Detection_ImgSpliceReq) isDetection_Request() {}

func (*Detection_ImgCamMatchReq) isDetection_Request() {}

func (*Detection_ImgCamsReq) isDetection_Request() {}

func (*Detection_VidCamMatchReq) isDetection_Request() {}

func (m *Detection) GetRequest() isDetection_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Detection) GetImgManipReq() *ImageManipulationRequest {
	if x, ok := m.GetRequest().(*Detection_ImgManipReq); ok {
		return x.ImgManipReq
	}
	return nil
}

func (m *Detection) GetVidManipReq() *VideoManipulationRequest {
	if x, ok := m.GetRequest().(*Detection_VidManipReq); ok {
		return x.VidManipReq
	}
	return nil
}

func (m *Detection) GetImgSpliceReq() *ImageSpliceRequest {
	if x, ok := m.GetRequest().(*Detection_ImgSpliceReq); ok {
		return x.ImgSpliceReq
	}
	return nil
}

func (m *Detection) GetImgCamMatchReq() *ImageCameraMatchRequest {
	if x, ok := m.GetRequest().(*Detection_ImgCamMatchReq); ok {
		return x.ImgCamMatchReq
	}
	return nil
}

func (m *Detection) GetImgCamsReq() *ImageCamerasRequest {
	if x, ok := m.GetRequest().(*Detection_ImgCamsReq); ok {
		return x.ImgCamsReq
	}
	return nil
}

func (m *Detection) GetVidCamMatchReq() *VideoCameraMatchRequest {
	if x, ok := m.GetRequest().(*Detection_VidCamMatchReq); ok {
		return x.VidCamMatchReq
	}
	return nil
}

type isDetection_Response interface {
	isDetection_Response()
}

type Detection_ImgManip struct {
	ImgManip *ImageManipulation `protobuf:"bytes,21,opt,name=img_manip,json=imgManip,proto3,oneof"`
}

type Detection_VidManip struct {
	VidManip *VideoManipulation `protobuf:"bytes,22,opt,name=vid_manip,json=vidManip,proto3,oneof"`
}

type Detection_ImgSplice struct {
	ImgSplice *ImageSplice `protobuf:"bytes,23,opt,name=img_splice,json=imgSplice,proto3,oneof"`
}

type Detection_ImgCamMatch struct {
	ImgCamMatch *ImageCameraMatch `protobuf:"bytes,24,opt,name=img_cam_match,json=imgCamMatch,proto3,oneof"`
}

type Detection_ImgCams struct {
	ImgCams *ImageCameras `protobuf:"bytes,25,opt,name=img_cams,json=imgCams,proto3,oneof"`
}

type Detection_VidCamMatch struct {
	VidCamMatch *VideoCameraMatch `protobuf:"bytes,26,opt,name=vid_cam_match,json=vidCamMatch,proto3,oneof"`
}

func (*Detection_ImgManip) isDetection_Response() {}

func (*Detection_VidManip) isDetection_Response() {}

func (*Detection_ImgSplice) isDetection_Response() {}

func (*Detection_ImgCamMatch) isDetection_Response() {}

func (*Detection_ImgCams) isDetection_Response() {}

func (*Detection_VidCamMatch) isDetection_Response() {}

func (m *Detection) GetResponse() isDetection_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Detection) GetImgManip() *ImageManipulation {
	if x, ok := m.GetResponse().(*Detection_ImgManip); ok {
		return x.ImgManip
	}
	return nil
}

func (m *Detection) GetVidManip() *VideoManipulation {
	if x, ok := m.GetResponse().(*Detection_VidManip); ok {
		return x.VidManip
	}
	return nil
}

func (m *Detection) GetImgSplice() *ImageSplice {
	if x, ok := m.GetResponse().(*Detection_ImgSplice); ok {
		return x.ImgSplice
	}
	return nil
}

func (m *Detection) GetImgCamMatch() *ImageCameraMatch {
	if x, ok := m.GetResponse().(*Detection_ImgCamMatch); ok {
		return x.ImgCamMatch
	}
	return nil
}

func (m *Detection) GetImgCams() *ImageCameras {
	if x, ok := m.GetResponse().(*Detection_ImgCams); ok {
		return x.ImgCams
	}
	return nil
}

func (m *Detection) GetVidCamMatch() *VideoCameraMatch {
	if x, ok := m.GetResponse().(*Detection_VidCamMatch); ok {
		return x.VidCamMatch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Detection) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Detection_OneofMarshaler, _Detection_OneofUnmarshaler, _Detection_OneofSizer, []interface{}{
		(*Detection_ImgManipReq)(nil),
		(*Detection_VidManipReq)(nil),
		(*Detection_ImgSpliceReq)(nil),
		(*Detection_ImgCamMatchReq)(nil),
		(*Detection_ImgCamsReq)(nil),
		(*Detection_VidCamMatchReq)(nil),
		(*Detection_ImgManip)(nil),
		(*Detection_VidManip)(nil),
		(*Detection_ImgSplice)(nil),
		(*Detection_ImgCamMatch)(nil),
		(*Detection_ImgCams)(nil),
		(*Detection_VidCamMatch)(nil),
	}
}

func _Detection_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Detection)
	// request
	switch x := m.Request.(type) {
	case *Detection_ImgManipReq:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgManipReq); err != nil {
			return err
		}
	case *Detection_VidManipReq:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VidManipReq); err != nil {
			return err
		}
	case *Detection_ImgSpliceReq:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgSpliceReq); err != nil {
			return err
		}
	case *Detection_ImgCamMatchReq:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgCamMatchReq); err != nil {
			return err
		}
	case *Detection_ImgCamsReq:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgCamsReq); err != nil {
			return err
		}
	case *Detection_VidCamMatchReq:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VidCamMatchReq); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Detection.Request has unexpected type %T", x)
	}
	// response
	switch x := m.Response.(type) {
	case *Detection_ImgManip:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgManip); err != nil {
			return err
		}
	case *Detection_VidManip:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VidManip); err != nil {
			return err
		}
	case *Detection_ImgSplice:
		b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgSplice); err != nil {
			return err
		}
	case *Detection_ImgCamMatch:
		b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgCamMatch); err != nil {
			return err
		}
	case *Detection_ImgCams:
		b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgCams); err != nil {
			return err
		}
	case *Detection_VidCamMatch:
		b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VidCamMatch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Detection.Response has unexpected type %T", x)
	}
	return nil
}

func _Detection_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Detection)
	switch tag {
	case 11: // request.img_manip_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageManipulationRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Detection_ImgManipReq{msg}
		return true, err
	case 12: // request.vid_manip_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoManipulationRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Detection_VidManipReq{msg}
		return true, err
	case 13: // request.img_splice_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageSpliceRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Detection_ImgSpliceReq{msg}
		return true, err
	case 14: // request.img_cam_match_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageCameraMatchRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Detection_ImgCamMatchReq{msg}
		return true, err
	case 15: // request.img_cams_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageCamerasRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Detection_ImgCamsReq{msg}
		return true, err
	case 16: // request.vid_cam_match_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoCameraMatchRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Detection_VidCamMatchReq{msg}
		return true, err
	case 21: // response.img_manip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageManipulation)
		err := b.DecodeMessage(msg)
		m.Response = &Detection_ImgManip{msg}
		return true, err
	case 22: // response.vid_manip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoManipulation)
		err := b.DecodeMessage(msg)
		m.Response = &Detection_VidManip{msg}
		return true, err
	case 23: // response.img_splice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageSplice)
		err := b.DecodeMessage(msg)
		m.Response = &Detection_ImgSplice{msg}
		return true, err
	case 24: // response.img_cam_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageCameraMatch)
		err := b.DecodeMessage(msg)
		m.Response = &Detection_ImgCamMatch{msg}
		return true, err
	case 25: // response.img_cams
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageCameras)
		err := b.DecodeMessage(msg)
		m.Response = &Detection_ImgCams{msg}
		return true, err
	case 26: // response.vid_cam_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoCameraMatch)
		err := b.DecodeMessage(msg)
		m.Response = &Detection_VidCamMatch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Detection_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Detection)
	// request
	switch x := m.Request.(type) {
	case *Detection_ImgManipReq:
		s := proto.Size(x.ImgManipReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_VidManipReq:
		s := proto.Size(x.VidManipReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_ImgSpliceReq:
		s := proto.Size(x.ImgSpliceReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_ImgCamMatchReq:
		s := proto.Size(x.ImgCamMatchReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_ImgCamsReq:
		s := proto.Size(x.ImgCamsReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_VidCamMatchReq:
		s := proto.Size(x.VidCamMatchReq)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// response
	switch x := m.Response.(type) {
	case *Detection_ImgManip:
		s := proto.Size(x.ImgManip)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_VidManip:
		s := proto.Size(x.VidManip)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_ImgSplice:
		s := proto.Size(x.ImgSplice)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_ImgCamMatch:
		s := proto.Size(x.ImgCamMatch)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_ImgCams:
		s := proto.Size(x.ImgCams)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Detection_VidCamMatch:
		s := proto.Size(x.VidCamMatch)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AnnotatedDetection annotates a detection with information about the analytic
// that produced it.
type AnnotatedDetection struct {
	Id        string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version   string     `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Detection *Detection `protobuf:"bytes,3,opt,name=detection,proto3" json:"detection,omitempty"`
	// This is not usually present. When there is no id field, check here to see if you have id_version.
	AnalyticId           string   `protobuf:"bytes,4,opt,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnnotatedDetection) Reset()         { *m = AnnotatedDetection{} }
func (m *AnnotatedDetection) String() string { return proto.CompactTextString(m) }
func (*AnnotatedDetection) ProtoMessage()    {}
func (*AnnotatedDetection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{1}
}

func (m *AnnotatedDetection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotatedDetection.Unmarshal(m, b)
}
func (m *AnnotatedDetection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotatedDetection.Marshal(b, m, deterministic)
}
func (m *AnnotatedDetection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedDetection.Merge(m, src)
}
func (m *AnnotatedDetection) XXX_Size() int {
	return xxx_messageInfo_AnnotatedDetection.Size(m)
}
func (m *AnnotatedDetection) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedDetection.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedDetection proto.InternalMessageInfo

func (m *AnnotatedDetection) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotatedDetection) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnnotatedDetection) GetDetection() *Detection {
	if m != nil {
		return m.Detection
	}
	return nil
}

func (m *AnnotatedDetection) GetAnalyticId() string {
	if m != nil {
		return m.AnalyticId
	}
	return ""
}

// Resource holds information about, typically, a blob of data. It references this
// data by URI, which might be a file path, for example.
type Resource struct {
	// The location of the media. For local files, this just looks like a file path.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The mime type of this resource (file).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Free-form notes about this resource.
	Notes                string   `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{2}
}

func (m *Resource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resource.Unmarshal(m, b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return xxx_messageInfo_Resource.Size(m)
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

func (m *Resource) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Resource) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Resource) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

type IntRange struct {
	Start                int32    `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  int32    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntRange) Reset()         { *m = IntRange{} }
func (m *IntRange) String() string { return proto.CompactTextString(m) }
func (*IntRange) ProtoMessage()    {}
func (*IntRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{3}
}

func (m *IntRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IntRange.Unmarshal(m, b)
}
func (m *IntRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IntRange.Marshal(b, m, deterministic)
}
func (m *IntRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntRange.Merge(m, src)
}
func (m *IntRange) XXX_Size() int {
	return xxx_messageInfo_IntRange.Size(m)
}
func (m *IntRange) XXX_DiscardUnknown() {
	xxx_messageInfo_IntRange.DiscardUnknown(m)
}

var xxx_messageInfo_IntRange proto.InternalMessageInfo

func (m *IntRange) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *IntRange) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

type ScoredIntRange struct {
	Range                *IntRange `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Score                float64   `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ScoredIntRange) Reset()         { *m = ScoredIntRange{} }
func (m *ScoredIntRange) String() string { return proto.CompactTextString(m) }
func (*ScoredIntRange) ProtoMessage()    {}
func (*ScoredIntRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{4}
}

func (m *ScoredIntRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ScoredIntRange.Unmarshal(m, b)
}
func (m *ScoredIntRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ScoredIntRange.Marshal(b, m, deterministic)
}
func (m *ScoredIntRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScoredIntRange.Merge(m, src)
}
func (m *ScoredIntRange) XXX_Size() int {
	return xxx_messageInfo_ScoredIntRange.Size(m)
}
func (m *ScoredIntRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ScoredIntRange.DiscardUnknown(m)
}

var xxx_messageInfo_ScoredIntRange proto.InternalMessageInfo

func (m *ScoredIntRange) GetRange() *IntRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *ScoredIntRange) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

type MaskIntRange struct {
	Range                *IntRange `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Mask                 *Resource `protobuf:"bytes,2,opt,name=mask,proto3" json:"mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MaskIntRange) Reset()         { *m = MaskIntRange{} }
func (m *MaskIntRange) String() string { return proto.CompactTextString(m) }
func (*MaskIntRange) ProtoMessage()    {}
func (*MaskIntRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{5}
}

func (m *MaskIntRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MaskIntRange.Unmarshal(m, b)
}
func (m *MaskIntRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MaskIntRange.Marshal(b, m, deterministic)
}
func (m *MaskIntRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaskIntRange.Merge(m, src)
}
func (m *MaskIntRange) XXX_Size() int {
	return xxx_messageInfo_MaskIntRange.Size(m)
}
func (m *MaskIntRange) XXX_DiscardUnknown() {
	xxx_messageInfo_MaskIntRange.DiscardUnknown(m)
}

var xxx_messageInfo_MaskIntRange proto.InternalMessageInfo

func (m *MaskIntRange) GetRange() *IntRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *MaskIntRange) GetMask() *Resource {
	if m != nil {
		return m.Mask
	}
	return nil
}

type FloatRange struct {
	Start                float64  `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  float64  `protobuf:"fixed64,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatRange) Reset()         { *m = FloatRange{} }
func (m *FloatRange) String() string { return proto.CompactTextString(m) }
func (*FloatRange) ProtoMessage()    {}
func (*FloatRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{6}
}

func (m *FloatRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FloatRange.Unmarshal(m, b)
}
func (m *FloatRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FloatRange.Marshal(b, m, deterministic)
}
func (m *FloatRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatRange.Merge(m, src)
}
func (m *FloatRange) XXX_Size() int {
	return xxx_messageInfo_FloatRange.Size(m)
}
func (m *FloatRange) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatRange.DiscardUnknown(m)
}

var xxx_messageInfo_FloatRange proto.InternalMessageInfo

func (m *FloatRange) GetStart() float64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FloatRange) GetEnd() float64 {
	if m != nil {
		return m.End
	}
	return 0
}

type ScoredFloatRange struct {
	Range                *FloatRange `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Score                float64     `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ScoredFloatRange) Reset()         { *m = ScoredFloatRange{} }
func (m *ScoredFloatRange) String() string { return proto.CompactTextString(m) }
func (*ScoredFloatRange) ProtoMessage()    {}
func (*ScoredFloatRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{7}
}

func (m *ScoredFloatRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ScoredFloatRange.Unmarshal(m, b)
}
func (m *ScoredFloatRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ScoredFloatRange.Marshal(b, m, deterministic)
}
func (m *ScoredFloatRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScoredFloatRange.Merge(m, src)
}
func (m *ScoredFloatRange) XXX_Size() int {
	return xxx_messageInfo_ScoredFloatRange.Size(m)
}
func (m *ScoredFloatRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ScoredFloatRange.DiscardUnknown(m)
}

var xxx_messageInfo_ScoredFloatRange proto.InternalMessageInfo

func (m *ScoredFloatRange) GetRange() *FloatRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *ScoredFloatRange) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ImageLocalization struct {
	// The grayscale image mask indicating where manipulations have been
	// detected. As of late January 2019, the range is [0, 255] and 0 means
	// "manipulated".
	//
	// TODO: After February 2019, the sense of this might be reversed. Document.
	Mask *Resource `protobuf:"bytes,1,opt,name=mask,proto3" json:"mask,omitempty"`
	// A grayscale mask indicating where no detection was attempted.
	// A value of 255 means "opted out for this pixel".
	MaskOptout *Resource `protobuf:"bytes,2,opt,name=mask_optout,json=maskOptout,proto3" json:"mask_optout,omitempty"`
	// If a pixel value in the mask parameter is at or below this threshold,
	// it is determined to be a "manipulated" pixel. Otherwise not.
	// In other words, manipulated = val <= threshold.
	// The equality allows the default 0 value to be meaningful in, e.g., binary
	// mask images.
	//
	// TODO: After February 2019, may become manipulated = val > threshold.
	MaskThreshold        float64  `protobuf:"fixed64,3,opt,name=mask_threshold,json=maskThreshold,proto3" json:"mask_threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageLocalization) Reset()         { *m = ImageLocalization{} }
func (m *ImageLocalization) String() string { return proto.CompactTextString(m) }
func (*ImageLocalization) ProtoMessage()    {}
func (*ImageLocalization) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{8}
}

func (m *ImageLocalization) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageLocalization.Unmarshal(m, b)
}
func (m *ImageLocalization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageLocalization.Marshal(b, m, deterministic)
}
func (m *ImageLocalization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageLocalization.Merge(m, src)
}
func (m *ImageLocalization) XXX_Size() int {
	return xxx_messageInfo_ImageLocalization.Size(m)
}
func (m *ImageLocalization) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageLocalization.DiscardUnknown(m)
}

var xxx_messageInfo_ImageLocalization proto.InternalMessageInfo

func (m *ImageLocalization) GetMask() *Resource {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *ImageLocalization) GetMaskOptout() *Resource {
	if m != nil {
		return m.MaskOptout
	}
	return nil
}

func (m *ImageLocalization) GetMaskThreshold() float64 {
	if m != nil {
		return m.MaskThreshold
	}
	return 0
}

// Next ID: 11
type ImageManipulation struct {
	// A value in [0, 1], where 1 indicates "definitely manipulated" and 0 means
	// "definitely not". Leave unset (default value) if not used, and indicate that
	// with an appropriate opt_out value.
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// A map of manipulation type names to confidence that they apply.
	Facets map[string]float64 `protobuf:"bytes,10,rep,name=facets,proto3" json:"facets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// Set has_confidence to true and set a confidence value between 0 and 1 if
	// you know how confident you are about your score. 0 is "not at all confident"
	// and 1 is "completely confident" in the *accuracy of your score*.
	Confidence    float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	HasConfidence bool    `protobuf:"varint,9,opt,name=has_confidence,json=hasConfidence,proto3" json:"has_confidence,omitempty"`
	// If any portion of processing was opted out, specify which here.
	// Opting out of detection indicates that the score is meaningless (leave it
	// as the default, please).
	// Opting out of localization means the localization parameter and masks are
	// not meaningful.
	OptOut OptOutType `protobuf:"varint,3,opt,name=opt_out,json=optOut,proto3,enum=mediforproto.OptOutType" json:"opt_out,omitempty"`
	// Any additional information that might be useful to analysts can go into this
	// free-form string field.
	Explanation string `protobuf:"bytes,4,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Localization information indicates *where* a manipulation appears to be.
	// Includes mask information.
	Localization *ImageLocalization `protobuf:"bytes,5,opt,name=localization,proto3" json:"localization,omitempty"`
	// If specified, incidates at what level the manipulation was found.
	Specificity SpecificityType `protobuf:"varint,6,opt,name=specificity,proto3,enum=mediforproto.SpecificityType" json:"specificity,omitempty"`
	// What kind of manipulation(s) were detected.
	ManipulationType []ManipulationType `protobuf:"varint,7,rep,packed,name=manipulation_type,json=manipulationType,proto3,enum=mediforproto.ManipulationType" json:"manipulation_type,omitempty"`
	// Supplemental information, if available (e.g., depictions of reasoning).
	// Any kind of file can be output and referenced here, including JSON
	// metadata, image data with graphs, etc.
	Supplement           []*Resource `protobuf:"bytes,8,rep,name=supplement,proto3" json:"supplement,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ImageManipulation) Reset()         { *m = ImageManipulation{} }
func (m *ImageManipulation) String() string { return proto.CompactTextString(m) }
func (*ImageManipulation) ProtoMessage()    {}
func (*ImageManipulation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{9}
}

func (m *ImageManipulation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageManipulation.Unmarshal(m, b)
}
func (m *ImageManipulation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageManipulation.Marshal(b, m, deterministic)
}
func (m *ImageManipulation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageManipulation.Merge(m, src)
}
func (m *ImageManipulation) XXX_Size() int {
	return xxx_messageInfo_ImageManipulation.Size(m)
}
func (m *ImageManipulation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageManipulation.DiscardUnknown(m)
}

var xxx_messageInfo_ImageManipulation proto.InternalMessageInfo

func (m *ImageManipulation) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ImageManipulation) GetFacets() map[string]float64 {
	if m != nil {
		return m.Facets
	}
	return nil
}

func (m *ImageManipulation) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *ImageManipulation) GetHasConfidence() bool {
	if m != nil {
		return m.HasConfidence
	}
	return false
}

func (m *ImageManipulation) GetOptOut() OptOutType {
	if m != nil {
		return m.OptOut
	}
	return OptOutType_OPT_OUT_NONE
}

func (m *ImageManipulation) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

func (m *ImageManipulation) GetLocalization() *ImageLocalization {
	if m != nil {
		return m.Localization
	}
	return nil
}

func (m *ImageManipulation) GetSpecificity() SpecificityType {
	if m != nil {
		return m.Specificity
	}
	return SpecificityType_SPEC_GLOBAL
}

func (m *ImageManipulation) GetManipulationType() []ManipulationType {
	if m != nil {
		return m.ManipulationType
	}
	return nil
}

func (m *ImageManipulation) GetSupplement() []*Resource {
	if m != nil {
		return m.Supplement
	}
	return nil
}

// ImageManipulationRequest is used to ask an analytic indicator whether
// a particular image is likely to have been manipulated after capture.
// NextID: 5
type ImageManipulationRequest struct {
	// A unique ID for each request. Usually a UUID4 is used here.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The image to check for manipulation.
	Image *Resource `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	// The location on the local file system where output masks and supplemental
	// files should be written. The locations of these must be referenced in the
	// response, or they will be lost. Similarly, any files written outside of
	// this directory are not guaranteed to survive the return trip: this
	// directory is an indicator of what the *caller* is able to pull from (but
	// the path is from the service's perspective), so writing outside of it may
	// render the files inaccessible.
	OutDir string `protobuf:"bytes,3,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The high-provenance device ID, if known, of the device that captured the
	// image.
	HpDeviceId           string   `protobuf:"bytes,4,opt,name=hp_device_id,json=hpDeviceId,proto3" json:"hp_device_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageManipulationRequest) Reset()         { *m = ImageManipulationRequest{} }
func (m *ImageManipulationRequest) String() string { return proto.CompactTextString(m) }
func (*ImageManipulationRequest) ProtoMessage()    {}
func (*ImageManipulationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{10}
}

func (m *ImageManipulationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageManipulationRequest.Unmarshal(m, b)
}
func (m *ImageManipulationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageManipulationRequest.Marshal(b, m, deterministic)
}
func (m *ImageManipulationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageManipulationRequest.Merge(m, src)
}
func (m *ImageManipulationRequest) XXX_Size() int {
	return xxx_messageInfo_ImageManipulationRequest.Size(m)
}
func (m *ImageManipulationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageManipulationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImageManipulationRequest proto.InternalMessageInfo

func (m *ImageManipulationRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ImageManipulationRequest) GetImage() *Resource {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ImageManipulationRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *ImageManipulationRequest) GetHpDeviceId() string {
	if m != nil {
		return m.HpDeviceId
	}
	return ""
}

type VideoLocalization struct {
	// A list of all start/end frame indices where manipulation was detected.
	FrameDetection []*ScoredIntRange `protobuf:"bytes,1,rep,name=frame_detection,json=frameDetection,proto3" json:"frame_detection,omitempty"`
	// Only used if detection optout = OPT_OUT_LOCALIZATION.
	FrameOptout []*IntRange `protobuf:"bytes,2,rep,name=frame_optout,json=frameOptout,proto3" json:"frame_optout,omitempty"`
	// A list of all audio time indices where manipulation was detected.
	AudioDetection []*ScoredFloatRange `protobuf:"bytes,3,rep,name=audio_detection,json=audioDetection,proto3" json:"audio_detection,omitempty"`
	// Only used if detection optout = OPT_OUT_LOCALIZATION.
	AudioOptout []*FloatRange `protobuf:"bytes,4,rep,name=audio_optout,json=audioOptout,proto3" json:"audio_optout,omitempty"`
	// Frame masks showing where and in what frames manipulation was detected.
	VideoMask []*MaskIntRange `protobuf:"bytes,5,rep,name=video_mask,json=videoMask,proto3" json:"video_mask,omitempty"`
	// Frame masks showing where and in what frames the algorithm opted to not
	// process anything.
	VideoMaskOptout []*MaskIntRange `protobuf:"bytes,6,rep,name=video_mask_optout,json=videoMaskOptout,proto3" json:"video_mask_optout,omitempty"`
	// A threshold in [0, 255] indicating how to interpret manipulation mask frames.
	// See the similar mask_threshold for images for more details.
	VideoMaskThreshold   float64  `protobuf:"fixed64,7,opt,name=video_mask_threshold,json=videoMaskThreshold,proto3" json:"video_mask_threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoLocalization) Reset()         { *m = VideoLocalization{} }
func (m *VideoLocalization) String() string { return proto.CompactTextString(m) }
func (*VideoLocalization) ProtoMessage()    {}
func (*VideoLocalization) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{11}
}

func (m *VideoLocalization) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoLocalization.Unmarshal(m, b)
}
func (m *VideoLocalization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoLocalization.Marshal(b, m, deterministic)
}
func (m *VideoLocalization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoLocalization.Merge(m, src)
}
func (m *VideoLocalization) XXX_Size() int {
	return xxx_messageInfo_VideoLocalization.Size(m)
}
func (m *VideoLocalization) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoLocalization.DiscardUnknown(m)
}

var xxx_messageInfo_VideoLocalization proto.InternalMessageInfo

func (m *VideoLocalization) GetFrameDetection() []*ScoredIntRange {
	if m != nil {
		return m.FrameDetection
	}
	return nil
}

func (m *VideoLocalization) GetFrameOptout() []*IntRange {
	if m != nil {
		return m.FrameOptout
	}
	return nil
}

func (m *VideoLocalization) GetAudioDetection() []*ScoredFloatRange {
	if m != nil {
		return m.AudioDetection
	}
	return nil
}

func (m *VideoLocalization) GetAudioOptout() []*FloatRange {
	if m != nil {
		return m.AudioOptout
	}
	return nil
}

func (m *VideoLocalization) GetVideoMask() []*MaskIntRange {
	if m != nil {
		return m.VideoMask
	}
	return nil
}

func (m *VideoLocalization) GetVideoMaskOptout() []*MaskIntRange {
	if m != nil {
		return m.VideoMaskOptout
	}
	return nil
}

func (m *VideoLocalization) GetVideoMaskThreshold() float64 {
	if m != nil {
		return m.VideoMaskThreshold
	}
	return 0
}

// Next ID: 11
type VideoManipulation struct {
	// A value in [0, 1] where 1 indicates "definitely manipulated".
	// Leave as the default if detection is opted out.
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// A map of manipulation type names to confidence that they apply.
	Facets map[string]float64 `protobuf:"bytes,10,rep,name=facets,proto3" json:"facets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// Set has_confidence to true and set a confidence value between 0 and 1 if
	// you know how confident you are about your score. 0 is "not at all confident"
	// and 1 is "completely confident" in the *accuracy of your score*.
	Confidence    float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	HasConfidence bool    `protobuf:"varint,9,opt,name=has_confidence,json=hasConfidence,proto3" json:"has_confidence,omitempty"`
	// Opt out of detection, temporal, or spatial localization. Empty means no opt outs.
	OptOut []VideoOptOutType `protobuf:"varint,3,rep,packed,name=opt_out,json=optOut,proto3,enum=mediforproto.VideoOptOutType" json:"opt_out,omitempty"`
	// A free-form explanation of why manipulation is detected. For human consumption.
	Explanation string `protobuf:"bytes,4,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Information about where and when manipulation occurred. If temporal and
	// spatial optouts are present, this is assumed to be meaningless.
	Localization *VideoLocalization `protobuf:"bytes,5,opt,name=localization,proto3" json:"localization,omitempty"`
	// How specific the detection is.
	Specificity SpecificityType `protobuf:"varint,6,opt,name=specificity,proto3,enum=mediforproto.SpecificityType" json:"specificity,omitempty"`
	// What kinds of manipulation were detected.
	ManipulationType []ManipulationType `protobuf:"varint,7,rep,packed,name=manipulation_type,json=manipulationType,proto3,enum=mediforproto.ManipulationType" json:"manipulation_type,omitempty"`
	// Supplemental information, if available (e.g., depictions of reasoning).
	Supplement           []*Resource `protobuf:"bytes,8,rep,name=supplement,proto3" json:"supplement,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VideoManipulation) Reset()         { *m = VideoManipulation{} }
func (m *VideoManipulation) String() string { return proto.CompactTextString(m) }
func (*VideoManipulation) ProtoMessage()    {}
func (*VideoManipulation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{12}
}

func (m *VideoManipulation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoManipulation.Unmarshal(m, b)
}
func (m *VideoManipulation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoManipulation.Marshal(b, m, deterministic)
}
func (m *VideoManipulation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoManipulation.Merge(m, src)
}
func (m *VideoManipulation) XXX_Size() int {
	return xxx_messageInfo_VideoManipulation.Size(m)
}
func (m *VideoManipulation) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoManipulation.DiscardUnknown(m)
}

var xxx_messageInfo_VideoManipulation proto.InternalMessageInfo

func (m *VideoManipulation) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *VideoManipulation) GetFacets() map[string]float64 {
	if m != nil {
		return m.Facets
	}
	return nil
}

func (m *VideoManipulation) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *VideoManipulation) GetHasConfidence() bool {
	if m != nil {
		return m.HasConfidence
	}
	return false
}

func (m *VideoManipulation) GetOptOut() []VideoOptOutType {
	if m != nil {
		return m.OptOut
	}
	return nil
}

func (m *VideoManipulation) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

func (m *VideoManipulation) GetLocalization() *VideoLocalization {
	if m != nil {
		return m.Localization
	}
	return nil
}

func (m *VideoManipulation) GetSpecificity() SpecificityType {
	if m != nil {
		return m.Specificity
	}
	return SpecificityType_SPEC_GLOBAL
}

func (m *VideoManipulation) GetManipulationType() []ManipulationType {
	if m != nil {
		return m.ManipulationType
	}
	return nil
}

func (m *VideoManipulation) GetSupplement() []*Resource {
	if m != nil {
		return m.Supplement
	}
	return nil
}

// Next ID: 10
type VideoManipulationRequest struct {
	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Pointer to the file URI, with type information.
	Video *Resource `protobuf:"bytes,2,opt,name=video,proto3" json:"video,omitempty"`
	// Location where data should be written by the analytic. See
	// ImageManipulationRequest's similar field for more detail.
	OutDir string `protobuf:"bytes,3,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The high-provenance device ID, if known, of the device that captured the
	// video.
	HpDeviceId           string   `protobuf:"bytes,9,opt,name=hp_device_id,json=hpDeviceId,proto3" json:"hp_device_id,omitempty"`
	KeepWorkspace        bool     `protobuf:"varint,4,opt,name=keep_workspace,json=keepWorkspace,proto3" json:"keep_workspace,omitempty"`
	SkipAudio            bool     `protobuf:"varint,5,opt,name=skip_audio,json=skipAudio,proto3" json:"skip_audio,omitempty"`
	SkipVisual           bool     `protobuf:"varint,6,opt,name=skip_visual,json=skipVisual,proto3" json:"skip_visual,omitempty"`
	DebugResources       bool     `protobuf:"varint,7,opt,name=debug_resources,json=debugResources,proto3" json:"debug_resources,omitempty"`
	GpuOrd               int32    `protobuf:"varint,8,opt,name=gpu_ord,json=gpuOrd,proto3" json:"gpu_ord,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoManipulationRequest) Reset()         { *m = VideoManipulationRequest{} }
func (m *VideoManipulationRequest) String() string { return proto.CompactTextString(m) }
func (*VideoManipulationRequest) ProtoMessage()    {}
func (*VideoManipulationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{13}
}

func (m *VideoManipulationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoManipulationRequest.Unmarshal(m, b)
}
func (m *VideoManipulationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoManipulationRequest.Marshal(b, m, deterministic)
}
func (m *VideoManipulationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoManipulationRequest.Merge(m, src)
}
func (m *VideoManipulationRequest) XXX_Size() int {
	return xxx_messageInfo_VideoManipulationRequest.Size(m)
}
func (m *VideoManipulationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoManipulationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VideoManipulationRequest proto.InternalMessageInfo

func (m *VideoManipulationRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *VideoManipulationRequest) GetVideo() *Resource {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *VideoManipulationRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *VideoManipulationRequest) GetHpDeviceId() string {
	if m != nil {
		return m.HpDeviceId
	}
	return ""
}

func (m *VideoManipulationRequest) GetKeepWorkspace() bool {
	if m != nil {
		return m.KeepWorkspace
	}
	return false
}

func (m *VideoManipulationRequest) GetSkipAudio() bool {
	if m != nil {
		return m.SkipAudio
	}
	return false
}

func (m *VideoManipulationRequest) GetSkipVisual() bool {
	if m != nil {
		return m.SkipVisual
	}
	return false
}

func (m *VideoManipulationRequest) GetDebugResources() bool {
	if m != nil {
		return m.DebugResources
	}
	return false
}

func (m *VideoManipulationRequest) GetGpuOrd() int32 {
	if m != nil {
		return m.GpuOrd
	}
	return 0
}

// Next ID: 10
type Link struct {
	// For provenance: source and target image URIs.
	FromUri string `protobuf:"bytes,1,opt,name=from_uri,json=fromUri,proto3" json:"from_uri,omitempty"`
	ToUri   string `protobuf:"bytes,2,opt,name=to_uri,json=toUri,proto3" json:"to_uri,omitempty"`
	// Value between 0 and 1 indicating that a given "from" image is spliced into
	// a given "to" image. If there is a known confidence level, mark
	// has_confidence true, and set the actual confidence value to a value
	// between 0 (not confident) and 1 (very confident).
	Score         float64 `protobuf:"fixed64,3,opt,name=score,proto3" json:"score,omitempty"`
	Confidence    float64 `protobuf:"fixed64,4,opt,name=confidence,proto3" json:"confidence,omitempty"`
	HasConfidence bool    `protobuf:"varint,9,opt,name=has_confidence,json=hasConfidence,proto3" json:"has_confidence,omitempty"`
	// Mask showing which part of the source media was used.
	FromMask *ImageLocalization `protobuf:"bytes,5,opt,name=from_mask,json=fromMask,proto3" json:"from_mask,omitempty"`
	// Mask showing where the source part was placed into the destination media.
	ToMask *ImageLocalization `protobuf:"bytes,6,opt,name=to_mask,json=toMask,proto3" json:"to_mask,omitempty"`
	// Optional explanation for why this link is believed to exist.
	Explanation          string             `protobuf:"bytes,7,opt,name=explanation,proto3" json:"explanation,omitempty"`
	ManipulationType     []ManipulationType `protobuf:"varint,8,rep,packed,name=manipulation_type,json=manipulationType,proto3,enum=mediforproto.ManipulationType" json:"manipulation_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{14}
}

func (m *Link) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link.Unmarshal(m, b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link.Marshal(b, m, deterministic)
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return xxx_messageInfo_Link.Size(m)
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetFromUri() string {
	if m != nil {
		return m.FromUri
	}
	return ""
}

func (m *Link) GetToUri() string {
	if m != nil {
		return m.ToUri
	}
	return ""
}

func (m *Link) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Link) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *Link) GetHasConfidence() bool {
	if m != nil {
		return m.HasConfidence
	}
	return false
}

func (m *Link) GetFromMask() *ImageLocalization {
	if m != nil {
		return m.FromMask
	}
	return nil
}

func (m *Link) GetToMask() *ImageLocalization {
	if m != nil {
		return m.ToMask
	}
	return nil
}

func (m *Link) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

func (m *Link) GetManipulationType() []ManipulationType {
	if m != nil {
		return m.ManipulationType
	}
	return nil
}

type ImageSplice struct {
	OptOut               OptOutType `protobuf:"varint,1,opt,name=opt_out,json=optOut,proto3,enum=mediforproto.OptOutType" json:"opt_out,omitempty"`
	Link                 *Link      `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ImageSplice) Reset()         { *m = ImageSplice{} }
func (m *ImageSplice) String() string { return proto.CompactTextString(m) }
func (*ImageSplice) ProtoMessage()    {}
func (*ImageSplice) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{15}
}

func (m *ImageSplice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageSplice.Unmarshal(m, b)
}
func (m *ImageSplice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageSplice.Marshal(b, m, deterministic)
}
func (m *ImageSplice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageSplice.Merge(m, src)
}
func (m *ImageSplice) XXX_Size() int {
	return xxx_messageInfo_ImageSplice.Size(m)
}
func (m *ImageSplice) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageSplice.DiscardUnknown(m)
}

var xxx_messageInfo_ImageSplice proto.InternalMessageInfo

func (m *ImageSplice) GetOptOut() OptOutType {
	if m != nil {
		return m.OptOut
	}
	return OptOutType_OPT_OUT_NONE
}

func (m *ImageSplice) GetLink() *Link {
	if m != nil {
		return m.Link
	}
	return nil
}

type ImageSpliceRequest struct {
	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The "main" image.
	ProbeImage *Resource `protobuf:"bytes,2,opt,name=probe_image,json=probeImage,proto3" json:"probe_image,omitempty"`
	// The "source" image, from which a piece is likely to have been taken to put
	// into the probe image.
	DonorImage *Resource `protobuf:"bytes,3,opt,name=donor_image,json=donorImage,proto3" json:"donor_image,omitempty"`
	// Location where files should be written. See ImageManipulationRequest's
	// out_dir for details.
	OutDir               string   `protobuf:"bytes,4,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageSpliceRequest) Reset()         { *m = ImageSpliceRequest{} }
func (m *ImageSpliceRequest) String() string { return proto.CompactTextString(m) }
func (*ImageSpliceRequest) ProtoMessage()    {}
func (*ImageSpliceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{16}
}

func (m *ImageSpliceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageSpliceRequest.Unmarshal(m, b)
}
func (m *ImageSpliceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageSpliceRequest.Marshal(b, m, deterministic)
}
func (m *ImageSpliceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageSpliceRequest.Merge(m, src)
}
func (m *ImageSpliceRequest) XXX_Size() int {
	return xxx_messageInfo_ImageSpliceRequest.Size(m)
}
func (m *ImageSpliceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageSpliceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImageSpliceRequest proto.InternalMessageInfo

func (m *ImageSpliceRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ImageSpliceRequest) GetProbeImage() *Resource {
	if m != nil {
		return m.ProbeImage
	}
	return nil
}

func (m *ImageSpliceRequest) GetDonorImage() *Resource {
	if m != nil {
		return m.DonorImage
	}
	return nil
}

func (m *ImageSpliceRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

type ImageCameraMatch struct {
	// A value in [0, 1] where 1 indicates "definitely this camera" and 0 menas "definitely not".
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// Set to true if a score can be set. Leaving it default means "opting out of producing a score".
	// Use the explanation field in that case to communicate whye no score was supplied.
	HasScore bool `protobuf:"varint,2,opt,name=has_score,json=hasScore,proto3" json:"has_score,omitempty"`
	// Any additional explanation for the given score.
	Explanation string `protobuf:"bytes,3,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Localization information (pixel mask) indicating any regions of interest
	// used in making the camera ID decision.
	Localization *ImageLocalization `protobuf:"bytes,4,opt,name=localization,proto3" json:"localization,omitempty"`
	// Set to true if localization information is specified. Leave at default if
	// no localization info is provided.
	HasLocalization bool `protobuf:"varint,5,opt,name=has_localization,json=hasLocalization,proto3" json:"has_localization,omitempty"`
	// Supplemental information, output any type of file, may be surfaced to a user.
	Supplement           []*Resource `protobuf:"bytes,6,rep,name=supplement,proto3" json:"supplement,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ImageCameraMatch) Reset()         { *m = ImageCameraMatch{} }
func (m *ImageCameraMatch) String() string { return proto.CompactTextString(m) }
func (*ImageCameraMatch) ProtoMessage()    {}
func (*ImageCameraMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{17}
}

func (m *ImageCameraMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCameraMatch.Unmarshal(m, b)
}
func (m *ImageCameraMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCameraMatch.Marshal(b, m, deterministic)
}
func (m *ImageCameraMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCameraMatch.Merge(m, src)
}
func (m *ImageCameraMatch) XXX_Size() int {
	return xxx_messageInfo_ImageCameraMatch.Size(m)
}
func (m *ImageCameraMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCameraMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCameraMatch proto.InternalMessageInfo

func (m *ImageCameraMatch) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ImageCameraMatch) GetHasScore() bool {
	if m != nil {
		return m.HasScore
	}
	return false
}

func (m *ImageCameraMatch) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

func (m *ImageCameraMatch) GetLocalization() *ImageLocalization {
	if m != nil {
		return m.Localization
	}
	return nil
}

func (m *ImageCameraMatch) GetHasLocalization() bool {
	if m != nil {
		return m.HasLocalization
	}
	return false
}

func (m *ImageCameraMatch) GetSupplement() []*Resource {
	if m != nil {
		return m.Supplement
	}
	return nil
}

type ImageCameraMatchRequest struct {
	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Location where data should be written by the analytic. See
	// ImageManipulationRequest's similar field for more detail.
	OutDir string `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The image to check.
	Image *Resource `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// The camera ID this image is assumed to have.
	CameraId             string   `protobuf:"bytes,4,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCameraMatchRequest) Reset()         { *m = ImageCameraMatchRequest{} }
func (m *ImageCameraMatchRequest) String() string { return proto.CompactTextString(m) }
func (*ImageCameraMatchRequest) ProtoMessage()    {}
func (*ImageCameraMatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{18}
}

func (m *ImageCameraMatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCameraMatchRequest.Unmarshal(m, b)
}
func (m *ImageCameraMatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCameraMatchRequest.Marshal(b, m, deterministic)
}
func (m *ImageCameraMatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCameraMatchRequest.Merge(m, src)
}
func (m *ImageCameraMatchRequest) XXX_Size() int {
	return xxx_messageInfo_ImageCameraMatchRequest.Size(m)
}
func (m *ImageCameraMatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCameraMatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCameraMatchRequest proto.InternalMessageInfo

func (m *ImageCameraMatchRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ImageCameraMatchRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *ImageCameraMatchRequest) GetImage() *Resource {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ImageCameraMatchRequest) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

type VideoCameraMatch struct {
	// A value in [0, 1][ where 1 indicates "definitely this camera" and 0 menas "definitely not".
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// Set to true if a score can be set. Leaving it default means "opting out of producing a score".
	// Use the explanation field in that case to communicate whye no score was supplied.
	HasScore bool `protobuf:"varint,2,opt,name=has_score,json=hasScore,proto3" json:"has_score,omitempty"`
	// Any additional explanation for the given score.
	Explanation string `protobuf:"bytes,3,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Localization information (pixel mask) indicating any regions of interest
	// used in making the camera ID decision.
	Localization *VideoLocalization `protobuf:"bytes,4,opt,name=localization,proto3" json:"localization,omitempty"`
	// Set to true if localization information is specified. Leave at default if
	// no localization info is provided.
	HasLocalization bool `protobuf:"varint,5,opt,name=has_localization,json=hasLocalization,proto3" json:"has_localization,omitempty"`
	// Supplemental information, output any type of file, may be surfaced to a user.
	Supplement           []*Resource `protobuf:"bytes,6,rep,name=supplement,proto3" json:"supplement,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VideoCameraMatch) Reset()         { *m = VideoCameraMatch{} }
func (m *VideoCameraMatch) String() string { return proto.CompactTextString(m) }
func (*VideoCameraMatch) ProtoMessage()    {}
func (*VideoCameraMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{19}
}

func (m *VideoCameraMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoCameraMatch.Unmarshal(m, b)
}
func (m *VideoCameraMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoCameraMatch.Marshal(b, m, deterministic)
}
func (m *VideoCameraMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoCameraMatch.Merge(m, src)
}
func (m *VideoCameraMatch) XXX_Size() int {
	return xxx_messageInfo_VideoCameraMatch.Size(m)
}
func (m *VideoCameraMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoCameraMatch.DiscardUnknown(m)
}

var xxx_messageInfo_VideoCameraMatch proto.InternalMessageInfo

func (m *VideoCameraMatch) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *VideoCameraMatch) GetHasScore() bool {
	if m != nil {
		return m.HasScore
	}
	return false
}

func (m *VideoCameraMatch) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

func (m *VideoCameraMatch) GetLocalization() *VideoLocalization {
	if m != nil {
		return m.Localization
	}
	return nil
}

func (m *VideoCameraMatch) GetHasLocalization() bool {
	if m != nil {
		return m.HasLocalization
	}
	return false
}

func (m *VideoCameraMatch) GetSupplement() []*Resource {
	if m != nil {
		return m.Supplement
	}
	return nil
}

type VideoCameraMatchRequest struct {
	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Location where data should be written by the analytic. See
	// VideoManipulationRequest's similar field for more detail.
	OutDir string `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The image to check.
	Image *Resource `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// The camera ID this image is assumed to have.
	CameraId             string   `protobuf:"bytes,4,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoCameraMatchRequest) Reset()         { *m = VideoCameraMatchRequest{} }
func (m *VideoCameraMatchRequest) String() string { return proto.CompactTextString(m) }
func (*VideoCameraMatchRequest) ProtoMessage()    {}
func (*VideoCameraMatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{20}
}

func (m *VideoCameraMatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoCameraMatchRequest.Unmarshal(m, b)
}
func (m *VideoCameraMatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoCameraMatchRequest.Marshal(b, m, deterministic)
}
func (m *VideoCameraMatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoCameraMatchRequest.Merge(m, src)
}
func (m *VideoCameraMatchRequest) XXX_Size() int {
	return xxx_messageInfo_VideoCameraMatchRequest.Size(m)
}
func (m *VideoCameraMatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoCameraMatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VideoCameraMatchRequest proto.InternalMessageInfo

func (m *VideoCameraMatchRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *VideoCameraMatchRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *VideoCameraMatchRequest) GetImage() *Resource {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *VideoCameraMatchRequest) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

type CameraScore struct {
	CameraId string `protobuf:"bytes,1,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	// A value in [0, 1] where 1 indicates "came from this camera".
	Score float64 `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
	// A human-readable explanation for the score given for this camera.
	// Example: "PRNU match likelihood high".
	Explanation          string   `protobuf:"bytes,3,opt,name=explanation,proto3" json:"explanation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CameraScore) Reset()         { *m = CameraScore{} }
func (m *CameraScore) String() string { return proto.CompactTextString(m) }
func (*CameraScore) ProtoMessage()    {}
func (*CameraScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{21}
}

func (m *CameraScore) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CameraScore.Unmarshal(m, b)
}
func (m *CameraScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CameraScore.Marshal(b, m, deterministic)
}
func (m *CameraScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CameraScore.Merge(m, src)
}
func (m *CameraScore) XXX_Size() int {
	return xxx_messageInfo_CameraScore.Size(m)
}
func (m *CameraScore) XXX_DiscardUnknown() {
	xxx_messageInfo_CameraScore.DiscardUnknown(m)
}

var xxx_messageInfo_CameraScore proto.InternalMessageInfo

func (m *CameraScore) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

func (m *CameraScore) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CameraScore) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

type ImageCameras struct {
	// Camera score messages. If empty, assumed opted out (or an error occurred).
	Scores []*CameraScore `protobuf:"bytes,1,rep,name=scores,proto3" json:"scores,omitempty"`
	// An explanation for why scores were or were not produced. Human-readable.
	// Example: "Could not score, unknown image type <foo>."
	Explanation          string   `protobuf:"bytes,2,opt,name=explanation,proto3" json:"explanation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCameras) Reset()         { *m = ImageCameras{} }
func (m *ImageCameras) String() string { return proto.CompactTextString(m) }
func (*ImageCameras) ProtoMessage()    {}
func (*ImageCameras) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{22}
}

func (m *ImageCameras) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCameras.Unmarshal(m, b)
}
func (m *ImageCameras) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCameras.Marshal(b, m, deterministic)
}
func (m *ImageCameras) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCameras.Merge(m, src)
}
func (m *ImageCameras) XXX_Size() int {
	return xxx_messageInfo_ImageCameras.Size(m)
}
func (m *ImageCameras) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCameras.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCameras proto.InternalMessageInfo

func (m *ImageCameras) GetScores() []*CameraScore {
	if m != nil {
		return m.Scores
	}
	return nil
}

func (m *ImageCameras) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

type ImageCamerasRequest struct {
	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Currently unused, but here for future use and consistency with other detection requests.
	OutDir string `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The image to find a camera ID for.
	Image                *Resource `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ImageCamerasRequest) Reset()         { *m = ImageCamerasRequest{} }
func (m *ImageCamerasRequest) String() string { return proto.CompactTextString(m) }
func (*ImageCamerasRequest) ProtoMessage()    {}
func (*ImageCamerasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5ef7e7fe4b6f71e, []int{23}
}

func (m *ImageCamerasRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCamerasRequest.Unmarshal(m, b)
}
func (m *ImageCamerasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCamerasRequest.Marshal(b, m, deterministic)
}
func (m *ImageCamerasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCamerasRequest.Merge(m, src)
}
func (m *ImageCamerasRequest) XXX_Size() int {
	return xxx_messageInfo_ImageCamerasRequest.Size(m)
}
func (m *ImageCamerasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCamerasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCamerasRequest proto.InternalMessageInfo

func (m *ImageCamerasRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ImageCamerasRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *ImageCamerasRequest) GetImage() *Resource {
	if m != nil {
		return m.Image
	}
	return nil
}

func init() {
	proto.RegisterEnum("mediforproto.ManipulationType", ManipulationType_name, ManipulationType_value)
	proto.RegisterEnum("mediforproto.SpecificityType", SpecificityType_name, SpecificityType_value)
	proto.RegisterEnum("mediforproto.DetectionStage", DetectionStage_name, DetectionStage_value)
	proto.RegisterEnum("mediforproto.DetectionStatus", DetectionStatus_name, DetectionStatus_value)
	proto.RegisterEnum("mediforproto.OptOutType", OptOutType_name, OptOutType_value)
	proto.RegisterEnum("mediforproto.VideoOptOutType", VideoOptOutType_name, VideoOptOutType_value)
	proto.RegisterType((*Detection)(nil), "mediforproto.Detection")
	proto.RegisterType((*AnnotatedDetection)(nil), "mediforproto.AnnotatedDetection")
	proto.RegisterType((*Resource)(nil), "mediforproto.Resource")
	proto.RegisterType((*IntRange)(nil), "mediforproto.IntRange")
	proto.RegisterType((*ScoredIntRange)(nil), "mediforproto.ScoredIntRange")
	proto.RegisterType((*MaskIntRange)(nil), "mediforproto.MaskIntRange")
	proto.RegisterType((*FloatRange)(nil), "mediforproto.FloatRange")
	proto.RegisterType((*ScoredFloatRange)(nil), "mediforproto.ScoredFloatRange")
	proto.RegisterType((*ImageLocalization)(nil), "mediforproto.ImageLocalization")
	proto.RegisterType((*ImageManipulation)(nil), "mediforproto.ImageManipulation")
	proto.RegisterMapType((map[string]float64)(nil), "mediforproto.ImageManipulation.FacetsEntry")
	proto.RegisterType((*ImageManipulationRequest)(nil), "mediforproto.ImageManipulationRequest")
	proto.RegisterType((*VideoLocalization)(nil), "mediforproto.VideoLocalization")
	proto.RegisterType((*VideoManipulation)(nil), "mediforproto.VideoManipulation")
	proto.RegisterMapType((map[string]float64)(nil), "mediforproto.VideoManipulation.FacetsEntry")
	proto.RegisterType((*VideoManipulationRequest)(nil), "mediforproto.VideoManipulationRequest")
	proto.RegisterType((*Link)(nil), "mediforproto.Link")
	proto.RegisterType((*ImageSplice)(nil), "mediforproto.ImageSplice")
	proto.RegisterType((*ImageSpliceRequest)(nil), "mediforproto.ImageSpliceRequest")
	proto.RegisterType((*ImageCameraMatch)(nil), "mediforproto.ImageCameraMatch")
	proto.RegisterType((*ImageCameraMatchRequest)(nil), "mediforproto.ImageCameraMatchRequest")
	proto.RegisterType((*VideoCameraMatch)(nil), "mediforproto.VideoCameraMatch")
	proto.RegisterType((*VideoCameraMatchRequest)(nil), "mediforproto.VideoCameraMatchRequest")
	proto.RegisterType((*CameraScore)(nil), "mediforproto.CameraScore")
	proto.RegisterType((*ImageCameras)(nil), "mediforproto.ImageCameras")
	proto.RegisterType((*ImageCamerasRequest)(nil), "mediforproto.ImageCamerasRequest")
}

func init() { proto.RegisterFile("analytic.proto", fileDescriptor_e5ef7e7fe4b6f71e) }

var fileDescriptor_e5ef7e7fe4b6f71e = []byte{
	// 2349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4f, 0x73, 0xe3, 0x48,
	0x15, 0x1f, 0xd9, 0x8e, 0xff, 0x3c, 0x3b, 0xb6, 0xd2, 0x33, 0x49, 0x14, 0xcf, 0xfe, 0x09, 0xae,
	0xda, 0x61, 0x08, 0x90, 0x61, 0x07, 0xd8, 0xd9, 0x59, 0x28, 0x40, 0xb1, 0x95, 0x44, 0x3b, 0xb6,
	0x65, 0x5a, 0xf2, 0xcc, 0xd6, 0x5c, 0x84, 0x62, 0x75, 0x6c, 0x55, 0x6c, 0x4b, 0x23, 0xc9, 0x81,
	0xc0, 0x89, 0x4f, 0xc0, 0x8d, 0x13, 0x55, 0x5b, 0xc5, 0xd7, 0xa0, 0x8a, 0x2f, 0xc0, 0x65, 0x2f,
	0x7c, 0x17, 0x0e, 0x1c, 0xa8, 0x6e, 0x49, 0x96, 0x2c, 0xdb, 0x63, 0xd7, 0x50, 0xbb, 0x70, 0xd8,
	0x93, 0xdd, 0xaf, 0xdf, 0xfb, 0xf5, 0xeb, 0xf7, 0xfa, 0xfd, 0xf4, 0xa4, 0x86, 0xaa, 0x31, 0x35,
	0xc6, 0x77, 0xbe, 0x35, 0x38, 0x75, 0x5c, 0xdb, 0xb7, 0x51, 0x65, 0x42, 0x4c, 0xeb, 0xda, 0x76,
	0xd9, 0xa8, 0x7e, 0x38, 0xb4, 0xed, 0xe1, 0x98, 0x3c, 0x71, 0x9d, 0xc1, 0x13, 0xcf, 0x37, 0xfc,
	0x99, 0x17, 0xa8, 0x35, 0xfe, 0x55, 0x80, 0x52, 0x8b, 0xf8, 0x64, 0xe0, 0x5b, 0xf6, 0x14, 0x9d,
	0x40, 0x3e, 0x98, 0x15, 0xb8, 0x63, 0xee, 0x71, 0xf9, 0x29, 0x3a, 0x0d, 0xec, 0x4e, 0x5d, 0x67,
	0x70, 0xaa, 0xb2, 0x19, 0x1c, 0x6a, 0xa0, 0x13, 0xd8, 0xf3, 0x7c, 0xc3, 0xf5, 0x75, 0xdf, 0x9a,
	0x10, 0x7d, 0x62, 0x8d, 0xc7, 0x96, 0x27, 0x64, 0x8e, 0xb9, 0xc7, 0x59, 0x5c, 0x63, 0x13, 0x9a,
	0x35, 0x21, 0x1d, 0x26, 0x46, 0x8f, 0xa0, 0x46, 0xa6, 0xe6, 0x82, 0x66, 0x96, 0x69, 0xee, 0x92,
	0xa9, 0x99, 0xd0, 0x6b, 0xc3, 0xae, 0x35, 0x19, 0xea, 0x13, 0x63, 0x6a, 0x39, 0xba, 0x4b, 0xde,
	0x08, 0x65, 0xe6, 0xc6, 0xa3, 0xd3, 0xe4, 0x66, 0x4e, 0xe5, 0x89, 0x31, 0x24, 0x1d, 0xaa, 0x33,
	0x1b, 0x1b, 0xd4, 0x6f, 0x4c, 0xde, 0xcc, 0x88, 0xe7, 0x5f, 0xde, 0xc3, 0x65, 0x6b, 0x32, 0x64,
	0x33, 0x98, 0xbc, 0xa1, 0x68, 0xb7, 0x96, 0x99, 0x40, 0xab, 0xac, 0x42, 0x7b, 0x69, 0x99, 0xc4,
	0x5e, 0x83, 0x76, 0x6b, 0x99, 0x73, 0xb4, 0x4b, 0xa8, 0x52, 0xdf, 0x3c, 0x67, 0x6c, 0x0d, 0x08,
	0x83, 0xdb, 0x65, 0x70, 0xc7, 0x2b, 0x9c, 0x53, 0x99, 0x52, 0x0c, 0x54, 0xb1, 0x26, 0xc3, 0xb9,
	0x0c, 0x61, 0xd8, 0xa3, 0x48, 0x03, 0x63, 0xa2, 0x4f, 0x0c, 0x7f, 0x30, 0x62, 0x60, 0x55, 0x06,
	0xf6, 0xd1, 0x0a, 0xb0, 0xa6, 0x31, 0x21, 0xae, 0xd1, 0xa1, 0x9a, 0x31, 0x22, 0xf5, 0xa5, 0x69,
	0x4c, 0x22, 0x29, 0x92, 0xa0, 0x12, 0x62, 0x7a, 0x0c, 0xae, 0xc6, 0xe0, 0xbe, 0xb3, 0x16, 0xce,
	0x8b, 0xa1, 0x20, 0x80, 0xf2, 0x42, 0xd7, 0x68, 0xc8, 0x16, 0x5d, 0xe3, 0x57, 0xb9, 0xc6, 0xc2,
	0xb6, 0xda, 0xb5, 0x5b, 0xcb, 0x4c, 0xba, 0xf6, 0x0b, 0x28, 0xcd, 0x93, 0x2a, 0xec, 0x33, 0xac,
	0x0f, 0x37, 0x24, 0xf4, 0x92, 0xc3, 0xc5, 0x28, 0x93, 0xd4, 0x7e, 0x9e, 0x46, 0xe1, 0x60, 0x95,
	0xfd, 0x52, 0x0a, 0xa9, 0x7d, 0x94, 0x3b, 0xf4, 0x19, 0x40, 0x9c, 0x38, 0xe1, 0x90, 0x01, 0x1c,
	0xad, 0x4d, 0xda, 0x25, 0x87, 0x4b, 0xf3, 0x6c, 0xa1, 0x56, 0x70, 0x20, 0xe7, 0xf1, 0x10, 0x04,
	0x66, 0xfe, 0xc1, 0xdb, 0xd3, 0x74, 0xc9, 0xb1, 0x83, 0x18, 0x05, 0x01, 0x3d, 0x83, 0x62, 0x94,
	0x1c, 0xe1, 0x88, 0x01, 0xd4, 0xd7, 0x27, 0xe6, 0x92, 0xc3, 0x85, 0x30, 0x23, 0x74, 0xf9, 0x85,
	0x74, 0x08, 0xf5, 0x55, 0xcb, 0xa7, 0x53, 0x41, 0x97, 0x4f, 0xe4, 0xe0, 0xac, 0x04, 0x05, 0x37,
	0xc8, 0xce, 0x19, 0x40, 0xd1, 0x25, 0x9e, 0x63, 0x4f, 0x3d, 0xd2, 0xf8, 0x33, 0x07, 0x48, 0x9c,
	0x4e, 0x6d, 0xdf, 0xf0, 0x89, 0x19, 0x73, 0x40, 0x15, 0x32, 0x96, 0xc9, 0xea, 0xbf, 0x84, 0x33,
	0x96, 0x89, 0x04, 0x28, 0xdc, 0x12, 0xd7, 0xb3, 0xec, 0x29, 0xab, 0xee, 0x12, 0x8e, 0x86, 0xe8,
	0xa7, 0x50, 0x32, 0x23, 0x33, 0x56, 0xcf, 0xe5, 0xa7, 0x87, 0x8b, 0x9e, 0xcd, 0x51, 0x71, 0xac,
	0x89, 0x3e, 0x84, 0x72, 0xc4, 0x55, 0xba, 0x65, 0x0a, 0x39, 0x06, 0x0a, 0x91, 0x48, 0x36, 0x1b,
	0xe7, 0x50, 0xc4, 0xc4, 0xb3, 0x67, 0xee, 0x80, 0x20, 0x1e, 0xb2, 0x33, 0xd7, 0x0a, 0xdd, 0xa1,
	0x7f, 0x11, 0x82, 0x9c, 0x7f, 0xe7, 0x90, 0xd0, 0x19, 0xf6, 0x1f, 0x3d, 0x80, 0x9d, 0xa9, 0xed,
	0x93, 0x80, 0x55, 0x4a, 0x38, 0x18, 0x34, 0x9e, 0x42, 0x51, 0x9e, 0xfa, 0xd8, 0x98, 0x0e, 0x99,
	0x06, 0x23, 0x25, 0x86, 0xb4, 0x83, 0x83, 0x01, 0x45, 0x27, 0x53, 0x93, 0x41, 0xed, 0x60, 0xfa,
	0xb7, 0xa1, 0x41, 0x55, 0x1d, 0xd8, 0x2e, 0x31, 0xe7, 0x96, 0x3f, 0x80, 0x1d, 0x97, 0xfe, 0x09,
	0x29, 0xf1, 0x20, 0x95, 0xb9, 0x50, 0x0d, 0x07, 0x4a, 0x6c, 0x1d, 0x6a, 0xcf, 0x30, 0x39, 0x1c,
	0x0c, 0x1a, 0x23, 0xa8, 0x74, 0x0c, 0xef, 0xe6, 0x1d, 0x31, 0x4f, 0x20, 0x37, 0x31, 0xbc, 0x1b,
	0x06, 0xb9, 0xa4, 0x1c, 0x45, 0x0a, 0x33, 0x9d, 0xc6, 0x4f, 0x00, 0xce, 0xc7, 0xb6, 0xb1, 0x6a,
	0xd7, 0xdc, 0x8a, 0x5d, 0x73, 0xc1, 0xae, 0xbf, 0x00, 0x3e, 0xd8, 0x75, 0xc2, 0xf6, 0x74, 0xd1,
	0x47, 0x61, 0x71, 0xd9, 0x58, 0xf1, 0xed, 0x3b, 0xff, 0x92, 0x83, 0x3d, 0x76, 0xba, 0xdb, 0xf6,
	0xc0, 0x18, 0x5b, 0xbf, 0x37, 0xc2, 0xe7, 0x4c, 0xb0, 0x23, 0x6e, 0xf3, 0x8e, 0xd0, 0x33, 0x28,
	0xd3, 0x5f, 0xdd, 0x76, 0x7c, 0x7b, 0xe6, 0x6f, 0x08, 0x02, 0x50, 0x55, 0x85, 0x69, 0xa2, 0x8f,
	0xa0, 0xca, 0x0c, 0xfd, 0x91, 0x4b, 0xbc, 0x91, 0x3d, 0x36, 0xd9, 0xe9, 0xe0, 0xf0, 0x2e, 0x95,
	0x6a, 0x91, 0xb0, 0xf1, 0x55, 0x2e, 0xf4, 0x30, 0x49, 0x20, 0xf1, 0x6e, 0xb8, 0xc4, 0x6e, 0x50,
	0x13, 0xf2, 0xd7, 0xc6, 0x80, 0xf8, 0x9e, 0x00, 0xc7, 0xd9, 0xc7, 0xe5, 0xa7, 0xdf, 0xdf, 0xc0,
	0x63, 0xa7, 0xe7, 0x4c, 0x5b, 0x9a, 0xfa, 0xee, 0x1d, 0x0e, 0x4d, 0xd1, 0x07, 0x00, 0x03, 0x7b,
	0x7a, 0x6d, 0x99, 0x64, 0x3a, 0x88, 0xa2, 0x95, 0x90, 0x50, 0xbf, 0x47, 0x86, 0xa7, 0x27, 0x74,
	0x4a, 0xc7, 0xdc, 0xe3, 0x22, 0xde, 0x1d, 0x19, 0x5e, 0x33, 0x56, 0xfb, 0x18, 0x0a, 0xb6, 0xe3,
	0xeb, 0x34, 0x26, 0x74, 0x5f, 0xd5, 0x74, 0x86, 0x14, 0xc7, 0x57, 0x66, 0xbe, 0x76, 0xe7, 0x10,
	0x9c, 0xb7, 0xd9, 0x7f, 0x74, 0x0c, 0x65, 0xf2, 0x3b, 0x67, 0x6c, 0x4c, 0x99, 0x73, 0x61, 0xe5,
	0x25, 0x45, 0xa8, 0x09, 0x95, 0x71, 0x22, 0x51, 0xc2, 0xce, 0x5a, 0xba, 0x4e, 0xe6, 0x13, 0x2f,
	0x18, 0xa1, 0x5f, 0x42, 0xd9, 0x73, 0xc8, 0xc0, 0xba, 0xb6, 0x06, 0x96, 0x7f, 0x27, 0xe4, 0x99,
	0x77, 0xef, 0x2f, 0x62, 0xa8, 0xb1, 0x02, 0x73, 0x31, 0x69, 0x81, 0x5e, 0xc0, 0xde, 0x24, 0x11,
	0x45, 0x9d, 0xd5, 0x7b, 0xe1, 0x38, 0xfb, 0xb8, 0x9a, 0xa6, 0xbe, 0x64, 0xb0, 0x19, 0x0e, 0x3f,
	0x49, 0x49, 0xd0, 0x27, 0x00, 0xde, 0xcc, 0x71, 0xc6, 0x64, 0x42, 0xa6, 0xbe, 0x50, 0x64, 0x79,
	0x5b, 0x7b, 0x7c, 0x62, 0xcd, 0xfa, 0x73, 0x28, 0x27, 0xb2, 0x47, 0x8b, 0xe6, 0x86, 0xdc, 0x45,
	0x44, 0x74, 0x43, 0xee, 0xe8, 0x11, 0xb9, 0x35, 0xc6, 0xb3, 0xf9, 0x81, 0x67, 0x83, 0xcf, 0x32,
	0x9f, 0x72, 0x8d, 0xbf, 0x72, 0x20, 0xac, 0x6b, 0x52, 0xd0, 0xfb, 0x00, 0x21, 0x1b, 0xeb, 0x73,
	0x9e, 0x2d, 0x85, 0x12, 0xd9, 0xa4, 0xd4, 0x60, 0x51, 0xd3, 0x0d, 0x07, 0x3d, 0x50, 0x42, 0x87,
	0x50, 0xb0, 0x67, 0xbe, 0x6e, 0x5a, 0x6e, 0x48, 0x7d, 0x79, 0x7b, 0xe6, 0xb7, 0x2c, 0x17, 0x1d,
	0x43, 0x65, 0xe4, 0xe8, 0x26, 0xb9, 0xa5, 0xcd, 0x4a, 0xcc, 0xb2, 0x23, 0xa7, 0xc5, 0x44, 0xb2,
	0xd9, 0xf8, 0x2a, 0x0b, 0x7b, 0xec, 0xc9, 0xb1, 0x50, 0x99, 0x12, 0xd4, 0xae, 0x5d, 0x63, 0x42,
	0xf4, 0x98, 0xd9, 0x39, 0x16, 0xb2, 0xf7, 0x52, 0xf9, 0x5b, 0x20, 0x49, 0x5c, 0x65, 0x46, 0xf1,
	0x43, 0xe4, 0x39, 0x54, 0x02, 0x98, 0x79, 0xd5, 0x66, 0xdf, 0xc2, 0x73, 0x65, 0xa6, 0x1b, 0x96,
	0xed, 0x05, 0xd4, 0x8c, 0x99, 0x69, 0xd9, 0x7a, 0xf2, 0xd9, 0x92, 0x5d, 0x7e, 0xea, 0xa5, 0x09,
	0x0b, 0x57, 0x99, 0x59, 0xec, 0xc3, 0xcf, 0xa0, 0x12, 0x00, 0x85, 0x3e, 0xe4, 0x18, 0xca, 0x7a,
	0x1e, 0x2b, 0x33, 0xed, 0xd0, 0x8b, 0xe7, 0x00, 0xb7, 0x34, 0x38, 0x3a, 0xe3, 0xa9, 0x1d, 0x66,
	0x5a, 0x4f, 0x9f, 0xbd, 0x98, 0xd1, 0x71, 0xe9, 0x36, 0xe8, 0x41, 0xbc, 0x1b, 0x74, 0xce, 0x7a,
	0xa8, 0xd0, 0x34, 0x5a, 0x3c, 0xbf, 0x11, 0xa1, 0x36, 0x47, 0x08, 0x5d, 0xf8, 0x11, 0x3c, 0x48,
	0xe0, 0xc4, 0x2c, 0x56, 0x60, 0xc7, 0x0d, 0xcd, 0xd5, 0x63, 0x2a, 0xfb, 0x67, 0x2e, 0x4c, 0xe9,
	0x7f, 0x4f, 0x65, 0x4b, 0x30, 0x5f, 0x27, 0x95, 0x7d, 0x92, 0xa4, 0xb2, 0xec, 0x32, 0x59, 0x30,
	0x67, 0xbe, 0x3e, 0x3e, 0x5b, 0xaa, 0x82, 0x6f, 0xf9, 0x6c, 0x91, 0xcf, 0xfe, 0x91, 0x01, 0x61,
	0xdd, 0x6b, 0xd2, 0x16, 0x7c, 0xc6, 0x4e, 0xea, 0x26, 0x3e, 0x63, 0x4a, 0xdb, 0xf3, 0x59, 0x29,
	0xcd, 0x67, 0xf4, 0xac, 0xdd, 0x10, 0xe2, 0xe8, 0xbf, 0xb5, 0xdd, 0x1b, 0xcf, 0x31, 0x06, 0x84,
	0x9d, 0x87, 0x22, 0xde, 0xa5, 0xd2, 0x57, 0x91, 0x90, 0xba, 0xeb, 0xdd, 0x58, 0x8e, 0xce, 0x8a,
	0x9d, 0x9d, 0x87, 0x22, 0x2e, 0x51, 0x89, 0x48, 0x05, 0xb4, 0x39, 0x65, 0xd3, 0xb7, 0x96, 0x37,
	0x33, 0xc6, 0x2c, 0xd7, 0x45, 0xcc, 0x2c, 0x5e, 0x32, 0x09, 0xfa, 0x2e, 0xd4, 0x4c, 0x72, 0x35,
	0x1b, 0xea, 0x6e, 0xe8, 0xba, 0xc7, 0x0a, 0xb2, 0x88, 0xab, 0x4c, 0x1c, 0x6d, 0xc8, 0xa3, 0x5b,
	0x19, 0x3a, 0x33, 0xdd, 0x76, 0x4d, 0xa1, 0xc8, 0xfa, 0xcb, 0xfc, 0xd0, 0x99, 0x29, 0xae, 0xd9,
	0xf8, 0x77, 0x06, 0x72, 0x6d, 0x6b, 0x7a, 0x83, 0x8e, 0xa0, 0x78, 0xed, 0xda, 0x13, 0x3d, 0x6e,
	0x70, 0x0b, 0x74, 0xdc, 0x77, 0x2d, 0xb4, 0x0f, 0x79, 0xdf, 0x66, 0x13, 0x41, 0x9b, 0xbb, 0xe3,
	0xdb, 0x54, 0x3c, 0x2f, 0xe5, 0x6c, 0xb2, 0x94, 0x17, 0xab, 0x30, 0xf7, 0xae, 0x55, 0xf8, 0x73,
	0x28, 0x31, 0x77, 0x42, 0xc6, 0xdb, 0xea, 0xc1, 0xcf, 0x36, 0xc0, 0x58, 0xef, 0x53, 0x28, 0xf8,
	0x21, 0x5b, 0xe6, 0xb7, 0xb3, 0xcd, 0xfb, 0x01, 0x5f, 0xa6, 0xaa, 0xb8, 0xb0, 0x5c, 0xc5, 0x2b,
	0xeb, 0xa7, 0xf8, 0x6e, 0xf5, 0xd3, 0x18, 0x41, 0x39, 0xf1, 0xba, 0x97, 0x6c, 0xa3, 0xb8, 0x2d,
	0xdb, 0xa8, 0x47, 0x90, 0x1b, 0x5b, 0xd3, 0xa8, 0x1f, 0x47, 0x8b, 0xfa, 0x34, 0xb3, 0x98, 0xcd,
	0x37, 0xfe, 0xce, 0x01, 0x5a, 0xfe, 0x1c, 0xb0, 0xa9, 0x60, 0x9e, 0x41, 0xd9, 0x71, 0xed, 0x2b,
	0xa2, 0x6f, 0xd3, 0x06, 0x00, 0x53, 0x65, 0x8b, 0x50, 0x43, 0xd3, 0x9e, 0xda, 0x6e, 0x68, 0x98,
	0x7d, 0xbb, 0x21, 0x53, 0x95, 0xd3, 0x4d, 0x44, 0x2e, 0x59, 0x74, 0x8d, 0x3f, 0x65, 0x80, 0x4f,
	0xbf, 0xdb, 0xae, 0x79, 0x9c, 0x3c, 0x84, 0x12, 0x3d, 0x63, 0xf1, 0x1b, 0x40, 0x11, 0x17, 0x47,
	0x86, 0xc7, 0x1e, 0xd2, 0xe9, 0x0c, 0x67, 0x37, 0xf3, 0x74, 0xee, 0x5d, 0xfa, 0xce, 0xef, 0x01,
	0x4f, 0x7d, 0x58, 0x22, 0xfc, 0x22, 0xae, 0x8d, 0x0c, 0x6f, 0xa1, 0xcd, 0x59, 0x24, 0xd1, 0xfc,
	0xb6, 0x24, 0xda, 0xf8, 0x0b, 0x07, 0x87, 0x6b, 0x3e, 0xca, 0x6c, 0xca, 0x6b, 0x22, 0xca, 0x99,
	0x05, 0x6a, 0x9b, 0x77, 0x7c, 0xd9, 0x6d, 0x3a, 0xbe, 0x87, 0x50, 0x1a, 0xb0, 0xb5, 0xe3, 0xae,
	0xae, 0x18, 0x08, 0x64, 0x93, 0x25, 0x2c, 0xfd, 0x35, 0xe0, 0x7f, 0x98, 0xb0, 0x4d, 0x0f, 0xd6,
	0x6f, 0x28, 0x61, 0x6b, 0x3e, 0x55, 0xfd, 0x3f, 0x24, 0xec, 0x0a, 0xca, 0x81, 0x63, 0x6a, 0x94,
	0x94, 0x58, 0x97, 0x5b, 0xd4, 0x5d, 0xfd, 0x82, 0xbd, 0x39, 0x55, 0x8d, 0x01, 0x54, 0x92, 0xdf,
	0x97, 0xd0, 0xc7, 0x90, 0x67, 0xa6, 0x5e, 0xd8, 0xd9, 0xa7, 0xbe, 0x85, 0x25, 0xfc, 0xc1, 0xa1,
	0x62, 0x7a, 0x91, 0xcc, 0xf2, 0x22, 0x7f, 0x80, 0xfb, 0x2b, 0xbe, 0x2e, 0x7e, 0x33, 0x21, 0x3e,
	0xf9, 0x32, 0x07, 0x7c, 0x9a, 0xf9, 0xd1, 0x1e, 0xec, 0x76, 0xc4, 0xae, 0xdc, 0xd3, 0xfb, 0xdd,
	0x17, 0x5d, 0xe5, 0x55, 0x97, 0xbf, 0x87, 0x78, 0xa8, 0x04, 0xa2, 0x73, 0xb9, 0xad, 0x49, 0x98,
	0xe7, 0xd0, 0x01, 0xa0, 0x40, 0x22, 0xb6, 0x3e, 0xef, 0xab, 0x9a, 0xde, 0x54, 0xda, 0x0a, 0xe6,
	0x33, 0xb1, 0x26, 0x96, 0x3a, 0xca, 0x4b, 0x89, 0xcf, 0xa2, 0xf7, 0x40, 0x08, 0x24, 0x4d, 0xa5,
	0xab, 0x49, 0x5d, 0x4d, 0x17, 0x5f, 0x89, 0x58, 0xa2, 0x48, 0x6d, 0x3e, 0x87, 0x8e, 0x60, 0x3f,
	0x98, 0xed, 0x89, 0x72, 0x57, 0x3b, 0xc3, 0x7d, 0xf5, 0x52, 0xd7, 0x14, 0xa5, 0xcd, 0xef, 0xa0,
	0x07, 0xc0, 0x47, 0x53, 0x5a, 0x33, 0x94, 0xe6, 0x51, 0x15, 0x20, 0x90, 0x9e, 0xb5, 0xfb, 0x98,
	0x2f, 0xc4, 0x0b, 0xaa, 0xbd, 0xb6, 0xdc, 0x94, 0xf8, 0x22, 0xaa, 0x41, 0x39, 0x5c, 0xb0, 0xad,
	0x74, 0x25, 0xbe, 0x14, 0x9b, 0x34, 0xb1, 0xd2, 0xe3, 0x21, 0x1e, 0x9f, 0xb7, 0xe5, 0x1e, 0x5f,
	0x4e, 0xfa, 0xac, 0xca, 0xaf, 0x25, 0xbe, 0x12, 0xef, 0x4e, 0x95, 0xc4, 0x8e, 0xde, 0x14, 0xf1,
	0x4b, 0xb9, 0x7b, 0xc1, 0xef, 0x26, 0x34, 0x15, 0x4d, 0xd4, 0x24, 0xbe, 0x1a, 0x63, 0xa9, 0x2f,
	0xa4, 0x57, 0x7c, 0x2d, 0x1e, 0xbf, 0x12, 0x71, 0x8f, 0xe7, 0x11, 0x82, 0x6a, 0x30, 0xee, 0x48,
	0x9a, 0xd8, 0x12, 0x35, 0x91, 0xdf, 0x43, 0x87, 0x70, 0x3f, 0x8c, 0x5d, 0x57, 0x93, 0xcf, 0x15,
	0x2c, 0x75, 0x55, 0xb9, 0xa9, 0xf2, 0x28, 0x0e, 0x86, 0xdc, 0x11, 0x2f, 0x24, 0x1d, 0x4b, 0x4d,
	0xb1, 0xa7, 0xf5, 0xb1, 0xc4, 0xdf, 0x47, 0xbb, 0x50, 0x0a, 0xf7, 0x70, 0x21, 0xf3, 0x0f, 0x62,
	0xcd, 0x73, 0x2c, 0x76, 0x24, 0x5d, 0xee, 0xaa, 0x12, 0xd6, 0x64, 0xa5, 0xcb, 0xef, 0xc7, 0x61,
	0x0b, 0xa6, 0x5a, 0x74, 0xcf, 0x07, 0x71, 0x50, 0xc4, 0x7e, 0x4b, 0x56, 0xf8, 0xc3, 0x58, 0xad,
	0xa5, 0xf4, 0xcf, 0xda, 0x92, 0xfe, 0x79, 0xef, 0x82, 0x17, 0x62, 0x35, 0x45, 0xbb, 0x94, 0x30,
	0x7f, 0x74, 0xd2, 0x87, 0x5a, 0xaa, 0x43, 0xa7, 0x3a, 0x6a, 0x4f, 0x6a, 0xea, 0x17, 0x6d, 0xe5,
	0x4c, 0x6c, 0xf3, 0xf7, 0xe8, 0x9e, 0x99, 0x80, 0x2d, 0xc8, 0x73, 0xf3, 0x71, 0x4f, 0xfe, 0x42,
	0x6a, 0xf3, 0x19, 0x7a, 0xa0, 0xd8, 0x78, 0x1e, 0x82, 0xec, 0xc9, 0x1f, 0x39, 0xa8, 0xce, 0x5f,
	0x38, 0x55, 0x9f, 0x96, 0xbb, 0x00, 0x0f, 0x5a, 0x92, 0x26, 0x35, 0xe9, 0x36, 0x74, 0x55, 0xa3,
	0x01, 0xe8, 0xd2, 0xfc, 0xdd, 0x43, 0x75, 0x38, 0x48, 0xcf, 0xfc, 0xba, 0x2f, 0xf5, 0xa5, 0x16,
	0xcf, 0xa1, 0x87, 0x70, 0x98, 0x9e, 0x6b, 0xb6, 0x45, 0xb9, 0x23, 0xb5, 0xf8, 0x0c, 0x3d, 0x7a,
	0xe9, 0xc9, 0x73, 0xb9, 0x2b, 0xab, 0x97, 0x52, 0x8b, 0xcf, 0x9e, 0x8c, 0xa0, 0x96, 0x74, 0xc1,
	0x9f, 0x79, 0x34, 0xac, 0x0b, 0x06, 0x5a, 0x5f, 0x8d, 0x9c, 0x48, 0x63, 0xd1, 0x29, 0xb5, 0xdf,
	0x6c, 0x4a, 0xaa, 0xca, 0x73, 0x2b, 0x67, 0xcf, 0x45, 0xb9, 0x4d, 0x93, 0x97, 0x39, 0xf9, 0x0d,
	0x40, 0xdc, 0x0d, 0xd1, 0x43, 0xa4, 0xf4, 0x34, 0x5d, 0xe9, 0x6b, 0x11, 0x76, 0x0d, 0xca, 0x91,
	0x44, 0x6c, 0xb7, 0x79, 0x0e, 0xed, 0xc3, 0x5e, 0x24, 0x98, 0xc3, 0xf2, 0x19, 0x1a, 0xa2, 0x48,
	0xdc, 0x56, 0x9a, 0x62, 0x5b, 0x7e, 0x2d, 0xb2, 0x99, 0xec, 0x09, 0x81, 0x5a, 0xea, 0x5d, 0x8f,
	0x46, 0xe6, 0xa5, 0xdc, 0x92, 0x14, 0x7d, 0x19, 0x89, 0x85, 0x74, 0x71, 0x52, 0x93, 0x3a, 0x3d,
	0x05, 0x8b, 0x74, 0xf1, 0x23, 0xd8, 0x5f, 0x9c, 0x53, 0x7b, 0xa2, 0x26, 0x8b, 0x6d, 0x3e, 0xf3,
	0xf4, 0x6f, 0x39, 0x28, 0x8a, 0xe1, 0xf7, 0x66, 0x74, 0x05, 0x87, 0x41, 0xfc, 0x96, 0x3f, 0x02,
	0x6e, 0x79, 0xef, 0x54, 0xdf, 0x74, 0x9d, 0x81, 0x7a, 0xb0, 0x97, 0x58, 0x23, 0xec, 0x3c, 0x37,
	0x5e, 0x1c, 0xd5, 0xd7, 0xdf, 0x52, 0xc4, 0x5e, 0x2f, 0xbf, 0xef, 0x6f, 0x79, 0xbf, 0x55, 0xdf,
	0x74, 0x89, 0x82, 0x74, 0x38, 0x48, 0x78, 0x9d, 0x6c, 0x29, 0xb6, 0xbb, 0xa6, 0xaa, 0x6f, 0xb8,
	0x26, 0x41, 0x2a, 0xa0, 0xa5, 0x05, 0x3c, 0xb4, 0xf9, 0xd2, 0xaa, 0xfe, 0x96, 0xeb, 0x93, 0xd8,
	0xeb, 0xa5, 0x46, 0x68, 0xbb, 0x1b, 0xac, 0xfa, 0x86, 0xdb, 0x95, 0xb3, 0x1b, 0x10, 0x06, 0xf6,
	0x24, 0xa1, 0x34, 0x74, 0x8d, 0x49, 0x70, 0x9d, 0x7a, 0xb6, 0x1b, 0x1d, 0xab, 0x1e, 0x1d, 0xbe,
	0xfe, 0xd5, 0xd0, 0xf2, 0xc7, 0xc6, 0x55, 0x5a, 0x77, 0x60, 0x4f, 0x9e, 0x84, 0xa2, 0xe8, 0xf7,
	0x87, 0xcc, 0xfe, 0x89, 0x73, 0x33, 0x7c, 0x92, 0x5c, 0xfd, 0x2a, 0xcf, 0x7e, 0x7e, 0xfc, 0x9f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x74, 0x46, 0xd6, 0x5a, 0xdf, 0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AnalyticClient is the client API for Analytic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnalyticClient interface {
	DetectImageManipulation(ctx context.Context, in *ImageManipulationRequest, opts ...grpc.CallOption) (*ImageManipulation, error)
	DetectImageSplice(ctx context.Context, in *ImageSpliceRequest, opts ...grpc.CallOption) (*ImageSplice, error)
	DetectVideoManipulation(ctx context.Context, in *VideoManipulationRequest, opts ...grpc.CallOption) (*VideoManipulation, error)
	DetectImageCameraMatch(ctx context.Context, in *ImageCameraMatchRequest, opts ...grpc.CallOption) (*ImageCameraMatch, error)
	DetectImageCameras(ctx context.Context, in *ImageCamerasRequest, opts ...grpc.CallOption) (*ImageCameras, error)
	DetectVideoCameraMatch(ctx context.Context, in *VideoCameraMatchRequest, opts ...grpc.CallOption) (*VideoCameraMatch, error)
}

type analyticClient struct {
	cc *grpc.ClientConn
}

func NewAnalyticClient(cc *grpc.ClientConn) AnalyticClient {
	return &analyticClient{cc}
}

func (c *analyticClient) DetectImageManipulation(ctx context.Context, in *ImageManipulationRequest, opts ...grpc.CallOption) (*ImageManipulation, error) {
	out := new(ImageManipulation)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageManipulation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectImageSplice(ctx context.Context, in *ImageSpliceRequest, opts ...grpc.CallOption) (*ImageSplice, error) {
	out := new(ImageSplice)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageSplice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectVideoManipulation(ctx context.Context, in *VideoManipulationRequest, opts ...grpc.CallOption) (*VideoManipulation, error) {
	out := new(VideoManipulation)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectVideoManipulation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectImageCameraMatch(ctx context.Context, in *ImageCameraMatchRequest, opts ...grpc.CallOption) (*ImageCameraMatch, error) {
	out := new(ImageCameraMatch)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageCameraMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectImageCameras(ctx context.Context, in *ImageCamerasRequest, opts ...grpc.CallOption) (*ImageCameras, error) {
	out := new(ImageCameras)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageCameras", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectVideoCameraMatch(ctx context.Context, in *VideoCameraMatchRequest, opts ...grpc.CallOption) (*VideoCameraMatch, error) {
	out := new(VideoCameraMatch)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectVideoCameraMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnalyticServer is the server API for Analytic service.
type AnalyticServer interface {
	DetectImageManipulation(context.Context, *ImageManipulationRequest) (*ImageManipulation, error)
	DetectImageSplice(context.Context, *ImageSpliceRequest) (*ImageSplice, error)
	DetectVideoManipulation(context.Context, *VideoManipulationRequest) (*VideoManipulation, error)
	DetectImageCameraMatch(context.Context, *ImageCameraMatchRequest) (*ImageCameraMatch, error)
	DetectImageCameras(context.Context, *ImageCamerasRequest) (*ImageCameras, error)
	DetectVideoCameraMatch(context.Context, *VideoCameraMatchRequest) (*VideoCameraMatch, error)
}

func RegisterAnalyticServer(s *grpc.Server, srv AnalyticServer) {
	s.RegisterService(&_Analytic_serviceDesc, srv)
}

func _Analytic_DetectImageManipulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageManipulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageManipulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageManipulation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageManipulation(ctx, req.(*ImageManipulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectImageSplice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageSpliceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageSplice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageSplice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageSplice(ctx, req.(*ImageSpliceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectVideoManipulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoManipulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectVideoManipulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectVideoManipulation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectVideoManipulation(ctx, req.(*VideoManipulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectImageCameraMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageCameraMatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageCameraMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageCameraMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageCameraMatch(ctx, req.(*ImageCameraMatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectImageCameras_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageCamerasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageCameras(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageCameras",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageCameras(ctx, req.(*ImageCamerasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectVideoCameraMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoCameraMatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectVideoCameraMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectVideoCameraMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectVideoCameraMatch(ctx, req.(*VideoCameraMatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Analytic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mediforproto.Analytic",
	HandlerType: (*AnalyticServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DetectImageManipulation",
			Handler:    _Analytic_DetectImageManipulation_Handler,
		},
		{
			MethodName: "DetectImageSplice",
			Handler:    _Analytic_DetectImageSplice_Handler,
		},
		{
			MethodName: "DetectVideoManipulation",
			Handler:    _Analytic_DetectVideoManipulation_Handler,
		},
		{
			MethodName: "DetectImageCameraMatch",
			Handler:    _Analytic_DetectImageCameraMatch_Handler,
		},
		{
			MethodName: "DetectImageCameras",
			Handler:    _Analytic_DetectImageCameras_Handler,
		},
		{
			MethodName: "DetectVideoCameraMatch",
			Handler:    _Analytic_DetectVideoCameraMatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "analytic.proto",
}
