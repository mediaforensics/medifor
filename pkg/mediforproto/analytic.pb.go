// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.6.1
// source: medifor/v1/analytic.proto

package mediforproto

import (
	context "context"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status1 "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ManipulationType int32

const (
	ManipulationType_MANIP_UNKNOWN            ManipulationType = 0
	ManipulationType_MANIP_FILTER             ManipulationType = 1
	ManipulationType_MANIP_ADJUST_COLOR       ManipulationType = 2
	ManipulationType_MANIP_REMOVE             ManipulationType = 3
	ManipulationType_MANIP_CONTENT_AWARE_FILL ManipulationType = 4
	ManipulationType_MANIP_PAINTBRUSH_TOOL    ManipulationType = 5
	ManipulationType_MANIP_PATCH_TOOL         ManipulationType = 6
	ManipulationType_MANIP_BLUR               ManipulationType = 7
	ManipulationType_MANIP_SPLICE             ManipulationType = 8
	ManipulationType_MANIP_CLONE              ManipulationType = 9
	ManipulationType_MANIP_CROP               ManipulationType = 10
	ManipulationType_MANIP_FLIP               ManipulationType = 11
	ManipulationType_MANIP_RESIZE             ManipulationType = 12
	ManipulationType_MANIP_SEAM_CARVING       ManipulationType = 13
	ManipulationType_MANIP_ROTATE             ManipulationType = 14
	ManipulationType_MANIP_SKEW               ManipulationType = 15
	ManipulationType_MANIP_WARP               ManipulationType = 16
	ManipulationType_MANIP_METADATA           ManipulationType = 17
	ManipulationType_MANIP_ANTIFORENSICS      ManipulationType = 18
	ManipulationType_MANIP_IMAGE_RECAPTURE    ManipulationType = 19
	ManipulationType_MANIP_CGI                ManipulationType = 20
	ManipulationType_MANIP_FRAME_INSERTION    ManipulationType = 21
	ManipulationType_MANIP_FRAME_DROP         ManipulationType = 22
	ManipulationType_MANIP_AUDIO              ManipulationType = 23
	ManipulationType_MANIP_DOUBLE_JPG         ManipulationType = 24
	ManipulationType_MANIP_OTHER              ManipulationType = 25
)

// Enum value maps for ManipulationType.
var (
	ManipulationType_name = map[int32]string{
		0:  "MANIP_UNKNOWN",
		1:  "MANIP_FILTER",
		2:  "MANIP_ADJUST_COLOR",
		3:  "MANIP_REMOVE",
		4:  "MANIP_CONTENT_AWARE_FILL",
		5:  "MANIP_PAINTBRUSH_TOOL",
		6:  "MANIP_PATCH_TOOL",
		7:  "MANIP_BLUR",
		8:  "MANIP_SPLICE",
		9:  "MANIP_CLONE",
		10: "MANIP_CROP",
		11: "MANIP_FLIP",
		12: "MANIP_RESIZE",
		13: "MANIP_SEAM_CARVING",
		14: "MANIP_ROTATE",
		15: "MANIP_SKEW",
		16: "MANIP_WARP",
		17: "MANIP_METADATA",
		18: "MANIP_ANTIFORENSICS",
		19: "MANIP_IMAGE_RECAPTURE",
		20: "MANIP_CGI",
		21: "MANIP_FRAME_INSERTION",
		22: "MANIP_FRAME_DROP",
		23: "MANIP_AUDIO",
		24: "MANIP_DOUBLE_JPG",
		25: "MANIP_OTHER",
	}
	ManipulationType_value = map[string]int32{
		"MANIP_UNKNOWN":            0,
		"MANIP_FILTER":             1,
		"MANIP_ADJUST_COLOR":       2,
		"MANIP_REMOVE":             3,
		"MANIP_CONTENT_AWARE_FILL": 4,
		"MANIP_PAINTBRUSH_TOOL":    5,
		"MANIP_PATCH_TOOL":         6,
		"MANIP_BLUR":               7,
		"MANIP_SPLICE":             8,
		"MANIP_CLONE":              9,
		"MANIP_CROP":               10,
		"MANIP_FLIP":               11,
		"MANIP_RESIZE":             12,
		"MANIP_SEAM_CARVING":       13,
		"MANIP_ROTATE":             14,
		"MANIP_SKEW":               15,
		"MANIP_WARP":               16,
		"MANIP_METADATA":           17,
		"MANIP_ANTIFORENSICS":      18,
		"MANIP_IMAGE_RECAPTURE":    19,
		"MANIP_CGI":                20,
		"MANIP_FRAME_INSERTION":    21,
		"MANIP_FRAME_DROP":         22,
		"MANIP_AUDIO":              23,
		"MANIP_DOUBLE_JPG":         24,
		"MANIP_OTHER":              25,
	}
)

func (x ManipulationType) Enum() *ManipulationType {
	p := new(ManipulationType)
	*p = x
	return p
}

func (x ManipulationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManipulationType) Descriptor() protoreflect.EnumDescriptor {
	return file_medifor_v1_analytic_proto_enumTypes[0].Descriptor()
}

func (ManipulationType) Type() protoreflect.EnumType {
	return &file_medifor_v1_analytic_proto_enumTypes[0]
}

func (x ManipulationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManipulationType.Descriptor instead.
func (ManipulationType) EnumDescriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{0}
}

type SpecificityType int32

const (
	SpecificityType_SPEC_GLOBAL   SpecificityType = 0
	SpecificityType_SPEC_FRAME    SpecificityType = 1
	SpecificityType_SPEC_PIXEL    SpecificityType = 2
	SpecificityType_SPEC_METADATA SpecificityType = 3
)

// Enum value maps for SpecificityType.
var (
	SpecificityType_name = map[int32]string{
		0: "SPEC_GLOBAL",
		1: "SPEC_FRAME",
		2: "SPEC_PIXEL",
		3: "SPEC_METADATA",
	}
	SpecificityType_value = map[string]int32{
		"SPEC_GLOBAL":   0,
		"SPEC_FRAME":    1,
		"SPEC_PIXEL":    2,
		"SPEC_METADATA": 3,
	}
)

func (x SpecificityType) Enum() *SpecificityType {
	p := new(SpecificityType)
	*p = x
	return p
}

func (x SpecificityType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SpecificityType) Descriptor() protoreflect.EnumDescriptor {
	return file_medifor_v1_analytic_proto_enumTypes[1].Descriptor()
}

func (SpecificityType) Type() protoreflect.EnumType {
	return &file_medifor_v1_analytic_proto_enumTypes[1]
}

func (x SpecificityType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SpecificityType.Descriptor instead.
func (SpecificityType) EnumDescriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{1}
}

type OptOutType int32

const (
	// Nothing was opted out (everything processed). The default value.
	OptOutType_OPT_OUT_NONE OptOutType = 0
	// Everything was opted out. No procesing was attempted. Note that this
	// should *not* be used to indicate "we tried but got an error". This is
	// a "look before you leap" value, indicating "we noticed that there
	// was no point in trying in the first place". A legitimate use of this
	// might be to indicate that the image's mime type is unknown, for example.
	OptOutType_OPT_OUT_ALL OptOutType = 1
	// No score will be provided for this image, but *localization information
	// will*. Use this if you know where things look suspicious, but don't
	// think you can produce a score.
	OptOutType_OPT_OUT_DETECTION OptOutType = 2
	// No masks will be provided for this image.
	OptOutType_OPT_OUT_LOCALIZATION OptOutType = 3
)

// Enum value maps for OptOutType.
var (
	OptOutType_name = map[int32]string{
		0: "OPT_OUT_NONE",
		1: "OPT_OUT_ALL",
		2: "OPT_OUT_DETECTION",
		3: "OPT_OUT_LOCALIZATION",
	}
	OptOutType_value = map[string]int32{
		"OPT_OUT_NONE":         0,
		"OPT_OUT_ALL":          1,
		"OPT_OUT_DETECTION":    2,
		"OPT_OUT_LOCALIZATION": 3,
	}
)

func (x OptOutType) Enum() *OptOutType {
	p := new(OptOutType)
	*p = x
	return p
}

func (x OptOutType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OptOutType) Descriptor() protoreflect.EnumDescriptor {
	return file_medifor_v1_analytic_proto_enumTypes[2].Descriptor()
}

func (OptOutType) Type() protoreflect.EnumType {
	return &file_medifor_v1_analytic_proto_enumTypes[2]
}

func (x OptOutType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OptOutType.Descriptor instead.
func (OptOutType) EnumDescriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{2}
}

type VideoOptOutType int32

const (
	// No score will be provided for this video.
	VideoOptOutType_VIDEO_OPT_OUT_DETECTION VideoOptOutType = 0
	// No temporal information for manipulations are to be provided.
	VideoOptOutType_VIDEO_OPT_OUT_TEMPORAL VideoOptOutType = 1
	// No spatial information for manipulations are to be provided.
	VideoOptOutType_VIDEO_OPT_OUT_SPATIAL VideoOptOutType = 2
)

// Enum value maps for VideoOptOutType.
var (
	VideoOptOutType_name = map[int32]string{
		0: "VIDEO_OPT_OUT_DETECTION",
		1: "VIDEO_OPT_OUT_TEMPORAL",
		2: "VIDEO_OPT_OUT_SPATIAL",
	}
	VideoOptOutType_value = map[string]int32{
		"VIDEO_OPT_OUT_DETECTION": 0,
		"VIDEO_OPT_OUT_TEMPORAL":  1,
		"VIDEO_OPT_OUT_SPATIAL":   2,
	}
)

func (x VideoOptOutType) Enum() *VideoOptOutType {
	p := new(VideoOptOutType)
	*p = x
	return p
}

func (x VideoOptOutType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VideoOptOutType) Descriptor() protoreflect.EnumDescriptor {
	return file_medifor_v1_analytic_proto_enumTypes[3].Descriptor()
}

func (VideoOptOutType) Type() protoreflect.EnumType {
	return &file_medifor_v1_analytic_proto_enumTypes[3]
}

func (x VideoOptOutType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VideoOptOutType.Descriptor instead.
func (VideoOptOutType) EnumDescriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{3}
}

// Detection holds round-trip information for any of the "DetectFoo" request/response endpoints.
type Detection struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Standard RPC status - we stash the actual RPC error/non-error here.
	Status *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Round-trip request-response timings. Milliseconds since the Epoch.
	StartTimeMillis int64 `protobuf:"varint,2,opt,name=start_time_millis,json=startTimeMillis,proto3" json:"start_time_millis,omitempty"`
	EndTimeMillis   int64 `protobuf:"varint,3,opt,name=end_time_millis,json=endTimeMillis,proto3" json:"end_time_millis,omitempty"`
	// The request made to the analytic.
	//
	// Types that are assignable to Request:
	//	*Detection_ImgManipReq
	//	*Detection_VidManipReq
	//	*Detection_ImgSpliceReq
	//	*Detection_ImgCamMatchReq
	//	*Detection_ImgCamsReq
	//	*Detection_VidCamMatchReq
	Request isDetection_Request `protobuf_oneof:"request"`
	// The response received from the analytic.
	//
	// Types that are assignable to Response:
	//	*Detection_ImgManip
	//	*Detection_VidManip
	//	*Detection_ImgSplice
	//	*Detection_ImgCamMatch
	//	*Detection_ImgCams
	//	*Detection_VidCamMatch
	Response isDetection_Response `protobuf_oneof:"response"`
}

func (x *Detection) Reset() {
	*x = Detection{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Detection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Detection) ProtoMessage() {}

func (x *Detection) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Detection.ProtoReflect.Descriptor instead.
func (*Detection) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{0}
}

func (x *Detection) GetStatus() *status.Status {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *Detection) GetStartTimeMillis() int64 {
	if x != nil {
		return x.StartTimeMillis
	}
	return 0
}

func (x *Detection) GetEndTimeMillis() int64 {
	if x != nil {
		return x.EndTimeMillis
	}
	return 0
}

func (m *Detection) GetRequest() isDetection_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (x *Detection) GetImgManipReq() *ImageManipulationRequest {
	if x, ok := x.GetRequest().(*Detection_ImgManipReq); ok {
		return x.ImgManipReq
	}
	return nil
}

func (x *Detection) GetVidManipReq() *VideoManipulationRequest {
	if x, ok := x.GetRequest().(*Detection_VidManipReq); ok {
		return x.VidManipReq
	}
	return nil
}

func (x *Detection) GetImgSpliceReq() *ImageSpliceRequest {
	if x, ok := x.GetRequest().(*Detection_ImgSpliceReq); ok {
		return x.ImgSpliceReq
	}
	return nil
}

func (x *Detection) GetImgCamMatchReq() *ImageCameraMatchRequest {
	if x, ok := x.GetRequest().(*Detection_ImgCamMatchReq); ok {
		return x.ImgCamMatchReq
	}
	return nil
}

func (x *Detection) GetImgCamsReq() *ImageCamerasRequest {
	if x, ok := x.GetRequest().(*Detection_ImgCamsReq); ok {
		return x.ImgCamsReq
	}
	return nil
}

func (x *Detection) GetVidCamMatchReq() *VideoCameraMatchRequest {
	if x, ok := x.GetRequest().(*Detection_VidCamMatchReq); ok {
		return x.VidCamMatchReq
	}
	return nil
}

func (m *Detection) GetResponse() isDetection_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (x *Detection) GetImgManip() *ImageManipulation {
	if x, ok := x.GetResponse().(*Detection_ImgManip); ok {
		return x.ImgManip
	}
	return nil
}

func (x *Detection) GetVidManip() *VideoManipulation {
	if x, ok := x.GetResponse().(*Detection_VidManip); ok {
		return x.VidManip
	}
	return nil
}

func (x *Detection) GetImgSplice() *ImageSplice {
	if x, ok := x.GetResponse().(*Detection_ImgSplice); ok {
		return x.ImgSplice
	}
	return nil
}

func (x *Detection) GetImgCamMatch() *ImageCameraMatch {
	if x, ok := x.GetResponse().(*Detection_ImgCamMatch); ok {
		return x.ImgCamMatch
	}
	return nil
}

func (x *Detection) GetImgCams() *ImageCameras {
	if x, ok := x.GetResponse().(*Detection_ImgCams); ok {
		return x.ImgCams
	}
	return nil
}

func (x *Detection) GetVidCamMatch() *VideoCameraMatch {
	if x, ok := x.GetResponse().(*Detection_VidCamMatch); ok {
		return x.VidCamMatch
	}
	return nil
}

type isDetection_Request interface {
	isDetection_Request()
}

type Detection_ImgManipReq struct {
	ImgManipReq *ImageManipulationRequest `protobuf:"bytes,11,opt,name=img_manip_req,json=imgManipReq,proto3,oneof"`
}

type Detection_VidManipReq struct {
	VidManipReq *VideoManipulationRequest `protobuf:"bytes,12,opt,name=vid_manip_req,json=vidManipReq,proto3,oneof"`
}

type Detection_ImgSpliceReq struct {
	ImgSpliceReq *ImageSpliceRequest `protobuf:"bytes,13,opt,name=img_splice_req,json=imgSpliceReq,proto3,oneof"`
}

type Detection_ImgCamMatchReq struct {
	ImgCamMatchReq *ImageCameraMatchRequest `protobuf:"bytes,14,opt,name=img_cam_match_req,json=imgCamMatchReq,proto3,oneof"`
}

type Detection_ImgCamsReq struct {
	ImgCamsReq *ImageCamerasRequest `protobuf:"bytes,15,opt,name=img_cams_req,json=imgCamsReq,proto3,oneof"`
}

type Detection_VidCamMatchReq struct {
	VidCamMatchReq *VideoCameraMatchRequest `protobuf:"bytes,16,opt,name=vid_cam_match_req,json=vidCamMatchReq,proto3,oneof"`
}

func (*Detection_ImgManipReq) isDetection_Request() {}

func (*Detection_VidManipReq) isDetection_Request() {}

func (*Detection_ImgSpliceReq) isDetection_Request() {}

func (*Detection_ImgCamMatchReq) isDetection_Request() {}

func (*Detection_ImgCamsReq) isDetection_Request() {}

func (*Detection_VidCamMatchReq) isDetection_Request() {}

type isDetection_Response interface {
	isDetection_Response()
}

type Detection_ImgManip struct {
	ImgManip *ImageManipulation `protobuf:"bytes,21,opt,name=img_manip,json=imgManip,proto3,oneof"`
}

type Detection_VidManip struct {
	VidManip *VideoManipulation `protobuf:"bytes,22,opt,name=vid_manip,json=vidManip,proto3,oneof"`
}

type Detection_ImgSplice struct {
	ImgSplice *ImageSplice `protobuf:"bytes,23,opt,name=img_splice,json=imgSplice,proto3,oneof"`
}

type Detection_ImgCamMatch struct {
	ImgCamMatch *ImageCameraMatch `protobuf:"bytes,24,opt,name=img_cam_match,json=imgCamMatch,proto3,oneof"`
}

type Detection_ImgCams struct {
	ImgCams *ImageCameras `protobuf:"bytes,25,opt,name=img_cams,json=imgCams,proto3,oneof"`
}

type Detection_VidCamMatch struct {
	VidCamMatch *VideoCameraMatch `protobuf:"bytes,26,opt,name=vid_cam_match,json=vidCamMatch,proto3,oneof"`
}

func (*Detection_ImgManip) isDetection_Response() {}

func (*Detection_VidManip) isDetection_Response() {}

func (*Detection_ImgSplice) isDetection_Response() {}

func (*Detection_ImgCamMatch) isDetection_Response() {}

func (*Detection_ImgCams) isDetection_Response() {}

func (*Detection_VidCamMatch) isDetection_Response() {}

// AnnotatedDetection annotates a detection with information about the analytic
// that produced it.
type AnnotatedDetection struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id        string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version   string     `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Detection *Detection `protobuf:"bytes,3,opt,name=detection,proto3" json:"detection,omitempty"`
	// This is not usually present. When there is no id field, check here to see if you have id_version.
	AnalyticId string `protobuf:"bytes,4,opt,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
}

func (x *AnnotatedDetection) Reset() {
	*x = AnnotatedDetection{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AnnotatedDetection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnnotatedDetection) ProtoMessage() {}

func (x *AnnotatedDetection) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AnnotatedDetection.ProtoReflect.Descriptor instead.
func (*AnnotatedDetection) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{1}
}

func (x *AnnotatedDetection) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AnnotatedDetection) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AnnotatedDetection) GetDetection() *Detection {
	if x != nil {
		return x.Detection
	}
	return nil
}

func (x *AnnotatedDetection) GetAnalyticId() string {
	if x != nil {
		return x.AnalyticId
	}
	return ""
}

// Resource holds information about, typically, a blob of data. It references this
// data by URI, which might be a file path, for example.
type Resource struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The location of the media. For local files, this just looks like a file path.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The mime type of this resource (file).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Free-form notes about this resource.
	Notes string `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
}

func (x *Resource) Reset() {
	*x = Resource{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Resource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Resource) ProtoMessage() {}

func (x *Resource) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Resource.ProtoReflect.Descriptor instead.
func (*Resource) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{2}
}

func (x *Resource) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *Resource) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Resource) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

type IntRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *IntRange) Reset() {
	*x = IntRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntRange) ProtoMessage() {}

func (x *IntRange) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntRange.ProtoReflect.Descriptor instead.
func (*IntRange) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{3}
}

func (x *IntRange) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *IntRange) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

type ScoredIntRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Range *IntRange `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Score float64   `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (x *ScoredIntRange) Reset() {
	*x = ScoredIntRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ScoredIntRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScoredIntRange) ProtoMessage() {}

func (x *ScoredIntRange) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScoredIntRange.ProtoReflect.Descriptor instead.
func (*ScoredIntRange) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{4}
}

func (x *ScoredIntRange) GetRange() *IntRange {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *ScoredIntRange) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

type MaskIntRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Range *IntRange `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Mask  *Resource `protobuf:"bytes,2,opt,name=mask,proto3" json:"mask,omitempty"`
}

func (x *MaskIntRange) Reset() {
	*x = MaskIntRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MaskIntRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaskIntRange) ProtoMessage() {}

func (x *MaskIntRange) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MaskIntRange.ProtoReflect.Descriptor instead.
func (*MaskIntRange) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{5}
}

func (x *MaskIntRange) GetRange() *IntRange {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *MaskIntRange) GetMask() *Resource {
	if x != nil {
		return x.Mask
	}
	return nil
}

type FloatRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start float64 `protobuf:"fixed64,1,opt,name=start,proto3" json:"start,omitempty"`
	End   float64 `protobuf:"fixed64,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *FloatRange) Reset() {
	*x = FloatRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FloatRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FloatRange) ProtoMessage() {}

func (x *FloatRange) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FloatRange.ProtoReflect.Descriptor instead.
func (*FloatRange) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{6}
}

func (x *FloatRange) GetStart() float64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *FloatRange) GetEnd() float64 {
	if x != nil {
		return x.End
	}
	return 0
}

type ScoredFloatRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Range *FloatRange `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Score float64     `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (x *ScoredFloatRange) Reset() {
	*x = ScoredFloatRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ScoredFloatRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScoredFloatRange) ProtoMessage() {}

func (x *ScoredFloatRange) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScoredFloatRange.ProtoReflect.Descriptor instead.
func (*ScoredFloatRange) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{7}
}

func (x *ScoredFloatRange) GetRange() *FloatRange {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *ScoredFloatRange) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

type ImageLocalization struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The grayscale image mask indicating where manipulations have been
	// detected. As of late January 2019, the range is [0, 255] and 0 means
	// "manipulated".
	//
	// TODO: After February 2019, the sense of this might be reversed. Document.
	Mask *Resource `protobuf:"bytes,1,opt,name=mask,proto3" json:"mask,omitempty"`
	// A grayscale mask indicating where no detection was attempted.
	// A value of 255 means "opted out for this pixel".
	MaskOptout *Resource `protobuf:"bytes,2,opt,name=mask_optout,json=maskOptout,proto3" json:"mask_optout,omitempty"`
	// If a pixel value in the mask parameter is at or below this threshold,
	// it is determined to be a "manipulated" pixel. Otherwise not.
	// In other words, manipulated = val <= threshold.
	// The equality allows the default 0 value to be meaningful in, e.g., binary
	// mask images.
	//
	// TODO: After February 2019, may become manipulated = val > threshold.
	MaskThreshold float64 `protobuf:"fixed64,3,opt,name=mask_threshold,json=maskThreshold,proto3" json:"mask_threshold,omitempty"`
}

func (x *ImageLocalization) Reset() {
	*x = ImageLocalization{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageLocalization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageLocalization) ProtoMessage() {}

func (x *ImageLocalization) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageLocalization.ProtoReflect.Descriptor instead.
func (*ImageLocalization) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{8}
}

func (x *ImageLocalization) GetMask() *Resource {
	if x != nil {
		return x.Mask
	}
	return nil
}

func (x *ImageLocalization) GetMaskOptout() *Resource {
	if x != nil {
		return x.MaskOptout
	}
	return nil
}

func (x *ImageLocalization) GetMaskThreshold() float64 {
	if x != nil {
		return x.MaskThreshold
	}
	return 0
}

// Next ID: 11
type ImageManipulation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A value in [0, 1], where 1 indicates "definitely manipulated" and 0 means
	// "definitely not". Leave unset (default value) if not used, and indicate that
	// with an appropriate opt_out value.
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// A map of manipulation type names to confidence that they apply.
	Facets map[string]float64 `protobuf:"bytes,10,rep,name=facets,proto3" json:"facets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// Set has_confidence to true and set a confidence value between 0 and 1 if
	// you know how confident you are about your score. 0 is "not at all confident"
	// and 1 is "completely confident" in the *accuracy of your score*.
	Confidence    float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	HasConfidence bool    `protobuf:"varint,9,opt,name=has_confidence,json=hasConfidence,proto3" json:"has_confidence,omitempty"`
	// If any portion of processing was opted out, specify which here.
	// Opting out of detection indicates that the score is meaningless (leave it
	// as the default, please).
	// Opting out of localization means the localization parameter and masks are
	// not meaningful.
	OptOut OptOutType `protobuf:"varint,3,opt,name=opt_out,json=optOut,proto3,enum=mediforproto.OptOutType" json:"opt_out,omitempty"`
	// Any additional information that might be useful to analysts can go into this
	// free-form string field.
	Explanation string `protobuf:"bytes,4,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Localization information indicates *where* a manipulation appears to be.
	// Includes mask information.
	Localization *ImageLocalization `protobuf:"bytes,5,opt,name=localization,proto3" json:"localization,omitempty"`
	// If specified, incidates at what level the manipulation was found.
	Specificity SpecificityType `protobuf:"varint,6,opt,name=specificity,proto3,enum=mediforproto.SpecificityType" json:"specificity,omitempty"`
	// What kind of manipulation(s) were detected.
	ManipulationType []ManipulationType `protobuf:"varint,7,rep,packed,name=manipulation_type,json=manipulationType,proto3,enum=mediforproto.ManipulationType" json:"manipulation_type,omitempty"`
	// Supplemental information, if available (e.g., depictions of reasoning).
	// Any kind of file can be output and referenced here, including JSON
	// metadata, image data with graphs, etc.
	Supplement []*Resource `protobuf:"bytes,8,rep,name=supplement,proto3" json:"supplement,omitempty"`
}

func (x *ImageManipulation) Reset() {
	*x = ImageManipulation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageManipulation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageManipulation) ProtoMessage() {}

func (x *ImageManipulation) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageManipulation.ProtoReflect.Descriptor instead.
func (*ImageManipulation) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{9}
}

func (x *ImageManipulation) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *ImageManipulation) GetFacets() map[string]float64 {
	if x != nil {
		return x.Facets
	}
	return nil
}

func (x *ImageManipulation) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *ImageManipulation) GetHasConfidence() bool {
	if x != nil {
		return x.HasConfidence
	}
	return false
}

func (x *ImageManipulation) GetOptOut() OptOutType {
	if x != nil {
		return x.OptOut
	}
	return OptOutType_OPT_OUT_NONE
}

func (x *ImageManipulation) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

func (x *ImageManipulation) GetLocalization() *ImageLocalization {
	if x != nil {
		return x.Localization
	}
	return nil
}

func (x *ImageManipulation) GetSpecificity() SpecificityType {
	if x != nil {
		return x.Specificity
	}
	return SpecificityType_SPEC_GLOBAL
}

func (x *ImageManipulation) GetManipulationType() []ManipulationType {
	if x != nil {
		return x.ManipulationType
	}
	return nil
}

func (x *ImageManipulation) GetSupplement() []*Resource {
	if x != nil {
		return x.Supplement
	}
	return nil
}

// ImageManipulationRequest is used to ask an analytic indicator whether
// a particular image is likely to have been manipulated after capture.
// NextID: 5
type ImageManipulationRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A unique ID for each request. Usually a UUID4 is used here.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The image to check for manipulation.
	Image *Resource `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	// The location on the local file system where output masks and supplemental
	// files should be written. The locations of these must be referenced in the
	// response, or they will be lost. Similarly, any files written outside of
	// this directory are not guaranteed to survive the return trip: this
	// directory is an indicator of what the *caller* is able to pull from (but
	// the path is from the service's perspective), so writing outside of it may
	// render the files inaccessible.
	OutDir string `protobuf:"bytes,3,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The high-provenance device ID, if known, of the device that captured the
	// image.
	HpDeviceId string `protobuf:"bytes,4,opt,name=hp_device_id,json=hpDeviceId,proto3" json:"hp_device_id,omitempty"`
}

func (x *ImageManipulationRequest) Reset() {
	*x = ImageManipulationRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageManipulationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageManipulationRequest) ProtoMessage() {}

func (x *ImageManipulationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageManipulationRequest.ProtoReflect.Descriptor instead.
func (*ImageManipulationRequest) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{10}
}

func (x *ImageManipulationRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ImageManipulationRequest) GetImage() *Resource {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *ImageManipulationRequest) GetOutDir() string {
	if x != nil {
		return x.OutDir
	}
	return ""
}

func (x *ImageManipulationRequest) GetHpDeviceId() string {
	if x != nil {
		return x.HpDeviceId
	}
	return ""
}

type VideoLocalization struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A list of all start/end frame indices where manipulation was detected.
	FrameDetection []*ScoredIntRange `protobuf:"bytes,1,rep,name=frame_detection,json=frameDetection,proto3" json:"frame_detection,omitempty"`
	// Only used if detection optout = OPT_OUT_LOCALIZATION.
	FrameOptout []*IntRange `protobuf:"bytes,2,rep,name=frame_optout,json=frameOptout,proto3" json:"frame_optout,omitempty"`
	// A list of all audio time indices where manipulation was detected.
	AudioDetection []*ScoredFloatRange `protobuf:"bytes,3,rep,name=audio_detection,json=audioDetection,proto3" json:"audio_detection,omitempty"`
	// Only used if detection optout = OPT_OUT_LOCALIZATION.
	AudioOptout []*FloatRange `protobuf:"bytes,4,rep,name=audio_optout,json=audioOptout,proto3" json:"audio_optout,omitempty"`
	// Frame masks showing where and in what frames manipulation was detected.
	VideoMask []*MaskIntRange `protobuf:"bytes,5,rep,name=video_mask,json=videoMask,proto3" json:"video_mask,omitempty"`
	// Frame masks showing where and in what frames the algorithm opted to not
	// process anything.
	VideoMaskOptout []*MaskIntRange `protobuf:"bytes,6,rep,name=video_mask_optout,json=videoMaskOptout,proto3" json:"video_mask_optout,omitempty"`
	// A threshold in [0, 255] indicating how to interpret manipulation mask frames.
	// See the similar mask_threshold for images for more details.
	VideoMaskThreshold float64 `protobuf:"fixed64,7,opt,name=video_mask_threshold,json=videoMaskThreshold,proto3" json:"video_mask_threshold,omitempty"`
}

func (x *VideoLocalization) Reset() {
	*x = VideoLocalization{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoLocalization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoLocalization) ProtoMessage() {}

func (x *VideoLocalization) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoLocalization.ProtoReflect.Descriptor instead.
func (*VideoLocalization) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{11}
}

func (x *VideoLocalization) GetFrameDetection() []*ScoredIntRange {
	if x != nil {
		return x.FrameDetection
	}
	return nil
}

func (x *VideoLocalization) GetFrameOptout() []*IntRange {
	if x != nil {
		return x.FrameOptout
	}
	return nil
}

func (x *VideoLocalization) GetAudioDetection() []*ScoredFloatRange {
	if x != nil {
		return x.AudioDetection
	}
	return nil
}

func (x *VideoLocalization) GetAudioOptout() []*FloatRange {
	if x != nil {
		return x.AudioOptout
	}
	return nil
}

func (x *VideoLocalization) GetVideoMask() []*MaskIntRange {
	if x != nil {
		return x.VideoMask
	}
	return nil
}

func (x *VideoLocalization) GetVideoMaskOptout() []*MaskIntRange {
	if x != nil {
		return x.VideoMaskOptout
	}
	return nil
}

func (x *VideoLocalization) GetVideoMaskThreshold() float64 {
	if x != nil {
		return x.VideoMaskThreshold
	}
	return 0
}

// Next ID: 11
type VideoManipulation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A value in [0, 1] where 1 indicates "definitely manipulated".
	// Leave as the default if detection is opted out.
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// A map of manipulation type names to confidence that they apply.
	Facets map[string]float64 `protobuf:"bytes,10,rep,name=facets,proto3" json:"facets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// Set has_confidence to true and set a confidence value between 0 and 1 if
	// you know how confident you are about your score. 0 is "not at all confident"
	// and 1 is "completely confident" in the *accuracy of your score*.
	Confidence    float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	HasConfidence bool    `protobuf:"varint,9,opt,name=has_confidence,json=hasConfidence,proto3" json:"has_confidence,omitempty"`
	// Opt out of detection, temporal, or spatial localization. Empty means no opt outs.
	OptOut []VideoOptOutType `protobuf:"varint,3,rep,packed,name=opt_out,json=optOut,proto3,enum=mediforproto.VideoOptOutType" json:"opt_out,omitempty"`
	// A free-form explanation of why manipulation is detected. For human consumption.
	Explanation string `protobuf:"bytes,4,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Information about where and when manipulation occurred. If temporal and
	// spatial optouts are present, this is assumed to be meaningless.
	Localization *VideoLocalization `protobuf:"bytes,5,opt,name=localization,proto3" json:"localization,omitempty"`
	// How specific the detection is.
	Specificity SpecificityType `protobuf:"varint,6,opt,name=specificity,proto3,enum=mediforproto.SpecificityType" json:"specificity,omitempty"`
	// What kinds of manipulation were detected.
	ManipulationType []ManipulationType `protobuf:"varint,7,rep,packed,name=manipulation_type,json=manipulationType,proto3,enum=mediforproto.ManipulationType" json:"manipulation_type,omitempty"`
	// Supplemental information, if available (e.g., depictions of reasoning).
	Supplement []*Resource `protobuf:"bytes,8,rep,name=supplement,proto3" json:"supplement,omitempty"`
}

func (x *VideoManipulation) Reset() {
	*x = VideoManipulation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoManipulation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoManipulation) ProtoMessage() {}

func (x *VideoManipulation) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoManipulation.ProtoReflect.Descriptor instead.
func (*VideoManipulation) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{12}
}

func (x *VideoManipulation) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *VideoManipulation) GetFacets() map[string]float64 {
	if x != nil {
		return x.Facets
	}
	return nil
}

func (x *VideoManipulation) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *VideoManipulation) GetHasConfidence() bool {
	if x != nil {
		return x.HasConfidence
	}
	return false
}

func (x *VideoManipulation) GetOptOut() []VideoOptOutType {
	if x != nil {
		return x.OptOut
	}
	return nil
}

func (x *VideoManipulation) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

func (x *VideoManipulation) GetLocalization() *VideoLocalization {
	if x != nil {
		return x.Localization
	}
	return nil
}

func (x *VideoManipulation) GetSpecificity() SpecificityType {
	if x != nil {
		return x.Specificity
	}
	return SpecificityType_SPEC_GLOBAL
}

func (x *VideoManipulation) GetManipulationType() []ManipulationType {
	if x != nil {
		return x.ManipulationType
	}
	return nil
}

func (x *VideoManipulation) GetSupplement() []*Resource {
	if x != nil {
		return x.Supplement
	}
	return nil
}

// Next ID: 10
type VideoManipulationRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Pointer to the file URI, with type information.
	Video *Resource `protobuf:"bytes,2,opt,name=video,proto3" json:"video,omitempty"`
	// Location where data should be written by the analytic. See
	// ImageManipulationRequest's similar field for more detail.
	OutDir string `protobuf:"bytes,3,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The high-provenance device ID, if known, of the device that captured the
	// video.
	HpDeviceId     string `protobuf:"bytes,9,opt,name=hp_device_id,json=hpDeviceId,proto3" json:"hp_device_id,omitempty"`
	KeepWorkspace  bool   `protobuf:"varint,4,opt,name=keep_workspace,json=keepWorkspace,proto3" json:"keep_workspace,omitempty"`
	SkipAudio      bool   `protobuf:"varint,5,opt,name=skip_audio,json=skipAudio,proto3" json:"skip_audio,omitempty"`
	SkipVisual     bool   `protobuf:"varint,6,opt,name=skip_visual,json=skipVisual,proto3" json:"skip_visual,omitempty"`
	DebugResources bool   `protobuf:"varint,7,opt,name=debug_resources,json=debugResources,proto3" json:"debug_resources,omitempty"`
	GpuOrd         int32  `protobuf:"varint,8,opt,name=gpu_ord,json=gpuOrd,proto3" json:"gpu_ord,omitempty"`
}

func (x *VideoManipulationRequest) Reset() {
	*x = VideoManipulationRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoManipulationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoManipulationRequest) ProtoMessage() {}

func (x *VideoManipulationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoManipulationRequest.ProtoReflect.Descriptor instead.
func (*VideoManipulationRequest) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{13}
}

func (x *VideoManipulationRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *VideoManipulationRequest) GetVideo() *Resource {
	if x != nil {
		return x.Video
	}
	return nil
}

func (x *VideoManipulationRequest) GetOutDir() string {
	if x != nil {
		return x.OutDir
	}
	return ""
}

func (x *VideoManipulationRequest) GetHpDeviceId() string {
	if x != nil {
		return x.HpDeviceId
	}
	return ""
}

func (x *VideoManipulationRequest) GetKeepWorkspace() bool {
	if x != nil {
		return x.KeepWorkspace
	}
	return false
}

func (x *VideoManipulationRequest) GetSkipAudio() bool {
	if x != nil {
		return x.SkipAudio
	}
	return false
}

func (x *VideoManipulationRequest) GetSkipVisual() bool {
	if x != nil {
		return x.SkipVisual
	}
	return false
}

func (x *VideoManipulationRequest) GetDebugResources() bool {
	if x != nil {
		return x.DebugResources
	}
	return false
}

func (x *VideoManipulationRequest) GetGpuOrd() int32 {
	if x != nil {
		return x.GpuOrd
	}
	return 0
}

// Next ID: 10
type Link struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For provenance: source and target image URIs.
	FromUri string `protobuf:"bytes,1,opt,name=from_uri,json=fromUri,proto3" json:"from_uri,omitempty"`
	ToUri   string `protobuf:"bytes,2,opt,name=to_uri,json=toUri,proto3" json:"to_uri,omitempty"`
	// Value between 0 and 1 indicating that a given "from" image is spliced into
	// a given "to" image. If there is a known confidence level, mark
	// has_confidence true, and set the actual confidence value to a value
	// between 0 (not confident) and 1 (very confident).
	Score         float64 `protobuf:"fixed64,3,opt,name=score,proto3" json:"score,omitempty"`
	Confidence    float64 `protobuf:"fixed64,4,opt,name=confidence,proto3" json:"confidence,omitempty"`
	HasConfidence bool    `protobuf:"varint,9,opt,name=has_confidence,json=hasConfidence,proto3" json:"has_confidence,omitempty"`
	// Mask showing which part of the source media was used.
	FromMask *ImageLocalization `protobuf:"bytes,5,opt,name=from_mask,json=fromMask,proto3" json:"from_mask,omitempty"`
	// Mask showing where the source part was placed into the destination media.
	ToMask *ImageLocalization `protobuf:"bytes,6,opt,name=to_mask,json=toMask,proto3" json:"to_mask,omitempty"`
	// Optional explanation for why this link is believed to exist.
	Explanation      string             `protobuf:"bytes,7,opt,name=explanation,proto3" json:"explanation,omitempty"`
	ManipulationType []ManipulationType `protobuf:"varint,8,rep,packed,name=manipulation_type,json=manipulationType,proto3,enum=mediforproto.ManipulationType" json:"manipulation_type,omitempty"`
}

func (x *Link) Reset() {
	*x = Link{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Link) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Link) ProtoMessage() {}

func (x *Link) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Link.ProtoReflect.Descriptor instead.
func (*Link) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{14}
}

func (x *Link) GetFromUri() string {
	if x != nil {
		return x.FromUri
	}
	return ""
}

func (x *Link) GetToUri() string {
	if x != nil {
		return x.ToUri
	}
	return ""
}

func (x *Link) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *Link) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *Link) GetHasConfidence() bool {
	if x != nil {
		return x.HasConfidence
	}
	return false
}

func (x *Link) GetFromMask() *ImageLocalization {
	if x != nil {
		return x.FromMask
	}
	return nil
}

func (x *Link) GetToMask() *ImageLocalization {
	if x != nil {
		return x.ToMask
	}
	return nil
}

func (x *Link) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

func (x *Link) GetManipulationType() []ManipulationType {
	if x != nil {
		return x.ManipulationType
	}
	return nil
}

type ImageSplice struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	OptOut OptOutType `protobuf:"varint,1,opt,name=opt_out,json=optOut,proto3,enum=mediforproto.OptOutType" json:"opt_out,omitempty"`
	Link   *Link      `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
}

func (x *ImageSplice) Reset() {
	*x = ImageSplice{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageSplice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageSplice) ProtoMessage() {}

func (x *ImageSplice) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageSplice.ProtoReflect.Descriptor instead.
func (*ImageSplice) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{15}
}

func (x *ImageSplice) GetOptOut() OptOutType {
	if x != nil {
		return x.OptOut
	}
	return OptOutType_OPT_OUT_NONE
}

func (x *ImageSplice) GetLink() *Link {
	if x != nil {
		return x.Link
	}
	return nil
}

type ImageSpliceRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The "main" image.
	ProbeImage *Resource `protobuf:"bytes,2,opt,name=probe_image,json=probeImage,proto3" json:"probe_image,omitempty"`
	// The "source" image, from which a piece is likely to have been taken to put
	// into the probe image.
	DonorImage *Resource `protobuf:"bytes,3,opt,name=donor_image,json=donorImage,proto3" json:"donor_image,omitempty"`
	// Location where files should be written. See ImageManipulationRequest's
	// out_dir for details.
	OutDir string `protobuf:"bytes,4,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
}

func (x *ImageSpliceRequest) Reset() {
	*x = ImageSpliceRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageSpliceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageSpliceRequest) ProtoMessage() {}

func (x *ImageSpliceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageSpliceRequest.ProtoReflect.Descriptor instead.
func (*ImageSpliceRequest) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{16}
}

func (x *ImageSpliceRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ImageSpliceRequest) GetProbeImage() *Resource {
	if x != nil {
		return x.ProbeImage
	}
	return nil
}

func (x *ImageSpliceRequest) GetDonorImage() *Resource {
	if x != nil {
		return x.DonorImage
	}
	return nil
}

func (x *ImageSpliceRequest) GetOutDir() string {
	if x != nil {
		return x.OutDir
	}
	return ""
}

type ImageCameraMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A value in [0, 1][ where 1 indicates "definitely this camera" and 0 menas "definitely not".
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// Set to true if a score can be set. Leaving it default means "opting out of producing a score".
	// Use the explanation field in that case to communicate whye no score was supplied.
	HasScore bool `protobuf:"varint,2,opt,name=has_score,json=hasScore,proto3" json:"has_score,omitempty"`
	// Any additional explanation for the given score.
	Explanation string `protobuf:"bytes,3,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Localization information (pixel mask) indicating any regions of interest
	// used in making the camera ID decision.
	Localization *ImageLocalization `protobuf:"bytes,4,opt,name=localization,proto3" json:"localization,omitempty"`
	// Set to true if localization information is specified. Leave at default if
	// no localization info is provided.
	HasLocalization bool `protobuf:"varint,5,opt,name=has_localization,json=hasLocalization,proto3" json:"has_localization,omitempty"`
	// Supplemental information, output any type of file, may be surfaced to a user.
	Supplement []*Resource `protobuf:"bytes,6,rep,name=supplement,proto3" json:"supplement,omitempty"`
}

func (x *ImageCameraMatch) Reset() {
	*x = ImageCameraMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageCameraMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageCameraMatch) ProtoMessage() {}

func (x *ImageCameraMatch) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageCameraMatch.ProtoReflect.Descriptor instead.
func (*ImageCameraMatch) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{17}
}

func (x *ImageCameraMatch) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *ImageCameraMatch) GetHasScore() bool {
	if x != nil {
		return x.HasScore
	}
	return false
}

func (x *ImageCameraMatch) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

func (x *ImageCameraMatch) GetLocalization() *ImageLocalization {
	if x != nil {
		return x.Localization
	}
	return nil
}

func (x *ImageCameraMatch) GetHasLocalization() bool {
	if x != nil {
		return x.HasLocalization
	}
	return false
}

func (x *ImageCameraMatch) GetSupplement() []*Resource {
	if x != nil {
		return x.Supplement
	}
	return nil
}

type ImageCameraMatchRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Location where data should be written by the analytic. See
	// ImageManipulationRequest's similar field for more detail.
	OutDir string `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The image to check.
	Image *Resource `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// The camera ID this image is assumed to have.
	CameraId string `protobuf:"bytes,4,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
}

func (x *ImageCameraMatchRequest) Reset() {
	*x = ImageCameraMatchRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageCameraMatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageCameraMatchRequest) ProtoMessage() {}

func (x *ImageCameraMatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageCameraMatchRequest.ProtoReflect.Descriptor instead.
func (*ImageCameraMatchRequest) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{18}
}

func (x *ImageCameraMatchRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ImageCameraMatchRequest) GetOutDir() string {
	if x != nil {
		return x.OutDir
	}
	return ""
}

func (x *ImageCameraMatchRequest) GetImage() *Resource {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *ImageCameraMatchRequest) GetCameraId() string {
	if x != nil {
		return x.CameraId
	}
	return ""
}

type VideoCameraMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A value in [0, 1][ where 1 indicates "definitely this camera" and 0 menas "definitely not".
	Score float64 `protobuf:"fixed64,1,opt,name=score,proto3" json:"score,omitempty"`
	// Set to true if a score can be set. Leaving it default means "opting out of producing a score".
	// Use the explanation field in that case to communicate whye no score was supplied.
	HasScore bool `protobuf:"varint,2,opt,name=has_score,json=hasScore,proto3" json:"has_score,omitempty"`
	// Any additional explanation for the given score.
	Explanation string `protobuf:"bytes,3,opt,name=explanation,proto3" json:"explanation,omitempty"`
	// Localization information (pixel mask) indicating any regions of interest
	// used in making the camera ID decision.
	Localization *VideoLocalization `protobuf:"bytes,4,opt,name=localization,proto3" json:"localization,omitempty"`
	// Set to true if localization information is specified. Leave at default if
	// no localization info is provided.
	HasLocalization bool `protobuf:"varint,5,opt,name=has_localization,json=hasLocalization,proto3" json:"has_localization,omitempty"`
	// Supplemental information, output any type of file, may be surfaced to a user.
	Supplement []*Resource `protobuf:"bytes,6,rep,name=supplement,proto3" json:"supplement,omitempty"`
}

func (x *VideoCameraMatch) Reset() {
	*x = VideoCameraMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoCameraMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoCameraMatch) ProtoMessage() {}

func (x *VideoCameraMatch) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoCameraMatch.ProtoReflect.Descriptor instead.
func (*VideoCameraMatch) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{19}
}

func (x *VideoCameraMatch) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *VideoCameraMatch) GetHasScore() bool {
	if x != nil {
		return x.HasScore
	}
	return false
}

func (x *VideoCameraMatch) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

func (x *VideoCameraMatch) GetLocalization() *VideoLocalization {
	if x != nil {
		return x.Localization
	}
	return nil
}

func (x *VideoCameraMatch) GetHasLocalization() bool {
	if x != nil {
		return x.HasLocalization
	}
	return false
}

func (x *VideoCameraMatch) GetSupplement() []*Resource {
	if x != nil {
		return x.Supplement
	}
	return nil
}

type VideoCameraMatchRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Location where data should be written by the analytic. See
	// VideoManipulationRequest's similar field for more detail.
	OutDir string `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The image to check.
	Image *Resource `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// The camera ID this image is assumed to have.
	CameraId string `protobuf:"bytes,4,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
}

func (x *VideoCameraMatchRequest) Reset() {
	*x = VideoCameraMatchRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoCameraMatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoCameraMatchRequest) ProtoMessage() {}

func (x *VideoCameraMatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoCameraMatchRequest.ProtoReflect.Descriptor instead.
func (*VideoCameraMatchRequest) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{20}
}

func (x *VideoCameraMatchRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *VideoCameraMatchRequest) GetOutDir() string {
	if x != nil {
		return x.OutDir
	}
	return ""
}

func (x *VideoCameraMatchRequest) GetImage() *Resource {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *VideoCameraMatchRequest) GetCameraId() string {
	if x != nil {
		return x.CameraId
	}
	return ""
}

type CameraScore struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CameraId string `protobuf:"bytes,1,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	// A value in [0, 1] where 1 indicates "came from this camera".
	Score float64 `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
	// A human-readable explanation for the score given for this camera.
	// Example: "PRNU match likelihood high".
	Explanation string `protobuf:"bytes,3,opt,name=explanation,proto3" json:"explanation,omitempty"`
}

func (x *CameraScore) Reset() {
	*x = CameraScore{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CameraScore) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CameraScore) ProtoMessage() {}

func (x *CameraScore) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CameraScore.ProtoReflect.Descriptor instead.
func (*CameraScore) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{21}
}

func (x *CameraScore) GetCameraId() string {
	if x != nil {
		return x.CameraId
	}
	return ""
}

func (x *CameraScore) GetScore() float64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *CameraScore) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

type ImageCameras struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Camera score messages. If empty, assumed opted out (or an error occurred).
	Scores []*CameraScore `protobuf:"bytes,1,rep,name=scores,proto3" json:"scores,omitempty"`
	// An explanation for why scores were or were not produced. Human-readable.
	// Example: "Could not score, unknown image type <foo>."
	Explanation string `protobuf:"bytes,2,opt,name=explanation,proto3" json:"explanation,omitempty"`
}

func (x *ImageCameras) Reset() {
	*x = ImageCameras{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageCameras) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageCameras) ProtoMessage() {}

func (x *ImageCameras) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageCameras.ProtoReflect.Descriptor instead.
func (*ImageCameras) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{22}
}

func (x *ImageCameras) GetScores() []*CameraScore {
	if x != nil {
		return x.Scores
	}
	return nil
}

func (x *ImageCameras) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

type ImageCamerasRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An ID unique to each request. Often a UUID4.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Currently unused, but here for future use and consistency with other detection requests.
	OutDir string `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// The image to find a camera ID for.
	Image *Resource `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *ImageCamerasRequest) Reset() {
	*x = ImageCamerasRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageCamerasRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageCamerasRequest) ProtoMessage() {}

func (x *ImageCamerasRequest) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageCamerasRequest.ProtoReflect.Descriptor instead.
func (*ImageCamerasRequest) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{23}
}

func (x *ImageCamerasRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ImageCamerasRequest) GetOutDir() string {
	if x != nil {
		return x.OutDir
	}
	return ""
}

func (x *ImageCamerasRequest) GetImage() *Resource {
	if x != nil {
		return x.Image
	}
	return nil
}

type Empty struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() {
	*x = Empty{}
	if protoimpl.UnsafeEnabled {
		mi := &file_medifor_v1_analytic_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Empty) ProtoMessage() {}

func (x *Empty) ProtoReflect() protoreflect.Message {
	mi := &file_medifor_v1_analytic_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) {
	return file_medifor_v1_analytic_proto_rawDescGZIP(), []int{24}
}

var File_medifor_v1_analytic_proto protoreflect.FileDescriptor

var file_medifor_v1_analytic_proto_rawDesc = []byte{
	0x0a, 0x19, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x6e, 0x61,
	0x6c, 0x79, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x6d, 0x65, 0x64,
	0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2f, 0x72, 0x70, 0x63, 0x2f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0xf8, 0x07, 0x0a, 0x09, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x2a, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x12, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2a, 0x0a, 0x11,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6d, 0x69, 0x6c, 0x6c, 0x69,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69,
	0x6d, 0x65, 0x4d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x65, 0x6e, 0x64, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0d, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x4d, 0x69, 0x6c, 0x6c, 0x69, 0x73,
	0x12, 0x4c, 0x0a, 0x0d, 0x69, 0x6d, 0x67, 0x5f, 0x6d, 0x61, 0x6e, 0x69, 0x70, 0x5f, 0x72, 0x65,
	0x71, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f,
	0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x6e, 0x69,
	0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48,
	0x00, 0x52, 0x0b, 0x69, 0x6d, 0x67, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x52, 0x65, 0x71, 0x12, 0x4c,
	0x0a, 0x0d, 0x76, 0x69, 0x64, 0x5f, 0x6d, 0x61, 0x6e, 0x69, 0x70, 0x5f, 0x72, 0x65, 0x71, 0x18,
	0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52,
	0x0b, 0x76, 0x69, 0x64, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x52, 0x65, 0x71, 0x12, 0x48, 0x0a, 0x0e,
	0x69, 0x6d, 0x67, 0x5f, 0x73, 0x70, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x6c, 0x69, 0x63, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0c, 0x69, 0x6d, 0x67, 0x53, 0x70, 0x6c,
	0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x12, 0x52, 0x0a, 0x11, 0x69, 0x6d, 0x67, 0x5f, 0x63, 0x61,
	0x6d, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x72, 0x65, 0x71, 0x18, 0x0e, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63,
	0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0e, 0x69, 0x6d, 0x67, 0x43,
	0x61, 0x6d, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x12, 0x45, 0x0a, 0x0c, 0x69, 0x6d,
	0x67, 0x5f, 0x63, 0x61, 0x6d, 0x73, 0x5f, 0x72, 0x65, 0x71, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x21, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0a, 0x69, 0x6d, 0x67, 0x43, 0x61, 0x6d, 0x73, 0x52, 0x65,
	0x71, 0x12, 0x52, 0x0a, 0x11, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x61, 0x6d, 0x5f, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x5f, 0x72, 0x65, 0x71, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6d,
	0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65,
	0x6f, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0e, 0x76, 0x69, 0x64, 0x43, 0x61, 0x6d, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x52, 0x65, 0x71, 0x12, 0x3e, 0x0a, 0x09, 0x69, 0x6d, 0x67, 0x5f, 0x6d, 0x61, 0x6e,
	0x69, 0x70, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x6e,
	0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x01, 0x52, 0x08, 0x69, 0x6d, 0x67,
	0x4d, 0x61, 0x6e, 0x69, 0x70, 0x12, 0x3e, 0x0a, 0x09, 0x76, 0x69, 0x64, 0x5f, 0x6d, 0x61, 0x6e,
	0x69, 0x70, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x61, 0x6e,
	0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x01, 0x52, 0x08, 0x76, 0x69, 0x64,
	0x4d, 0x61, 0x6e, 0x69, 0x70, 0x12, 0x3a, 0x0a, 0x0a, 0x69, 0x6d, 0x67, 0x5f, 0x73, 0x70, 0x6c,
	0x69, 0x63, 0x65, 0x18, 0x17, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x64, 0x69,
	0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70,
	0x6c, 0x69, 0x63, 0x65, 0x48, 0x01, 0x52, 0x09, 0x69, 0x6d, 0x67, 0x53, 0x70, 0x6c, 0x69, 0x63,
	0x65, 0x12, 0x44, 0x0a, 0x0d, 0x69, 0x6d, 0x67, 0x5f, 0x63, 0x61, 0x6d, 0x5f, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d,
	0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x01, 0x52, 0x0b, 0x69, 0x6d, 0x67, 0x43,
	0x61, 0x6d, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x37, 0x0a, 0x08, 0x69, 0x6d, 0x67, 0x5f, 0x63,
	0x61, 0x6d, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x64, 0x69,
	0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x73, 0x48, 0x01, 0x52, 0x07, 0x69, 0x6d, 0x67, 0x43, 0x61, 0x6d, 0x73,
	0x12, 0x44, 0x0a, 0x0d, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x61, 0x6d, 0x5f, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f,
	0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x61, 0x6d, 0x65,
	0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x01, 0x52, 0x0b, 0x76, 0x69, 0x64, 0x43, 0x61,
	0x6d, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x09, 0x0a, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x42, 0x0a, 0x0a, 0x08, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x96, 0x01,
	0x0a, 0x12, 0x41, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x64, 0x44, 0x65, 0x74, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x35,
	0x0a, 0x09, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x64, 0x65, 0x74, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69,
	0x63, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x6e, 0x61, 0x6c,
	0x79, 0x74, 0x69, 0x63, 0x49, 0x64, 0x22, 0x46, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x03, 0x75, 0x72, 0x69, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x65,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x22, 0x32,
	0x0a, 0x08, 0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x65,
	0x6e, 0x64, 0x22, 0x54, 0x0a, 0x0e, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x64, 0x49, 0x6e, 0x74, 0x52,
	0x61, 0x6e, 0x67, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x05, 0x72, 0x61, 0x6e,
	0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x01, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x68, 0x0a, 0x0c, 0x4d, 0x61, 0x73, 0x6b,
	0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f,
	0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52,
	0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x2a, 0x0a, 0x04, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x04, 0x6d, 0x61,
	0x73, 0x6b, 0x22, 0x34, 0x0a, 0x0a, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65,
	0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x22, 0x58, 0x0a, 0x10, 0x53, 0x63, 0x6f, 0x72,
	0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x2e, 0x0a, 0x05,
	0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x6c, 0x6f, 0x61, 0x74,
	0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x63, 0x6f,
	0x72, 0x65, 0x22, 0x9f, 0x01, 0x0a, 0x11, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4c, 0x6f, 0x63, 0x61,
	0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x04, 0x6d, 0x61, 0x73, 0x6b,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x04,
	0x6d, 0x61, 0x73, 0x6b, 0x12, 0x37, 0x0a, 0x0b, 0x6d, 0x61, 0x73, 0x6b, 0x5f, 0x6f, 0x70, 0x74,
	0x6f, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69,
	0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x52, 0x0a, 0x6d, 0x61, 0x73, 0x6b, 0x4f, 0x70, 0x74, 0x6f, 0x75, 0x74, 0x12, 0x25, 0x0a,
	0x0e, 0x6d, 0x61, 0x73, 0x6b, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0d, 0x6d, 0x61, 0x73, 0x6b, 0x54, 0x68, 0x72, 0x65, 0x73,
	0x68, 0x6f, 0x6c, 0x64, 0x22, 0xd0, 0x04, 0x0a, 0x11, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61,
	0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63,
	0x6f, 0x72, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65,
	0x12, 0x43, 0x0a, 0x06, 0x66, 0x61, 0x63, 0x65, 0x74, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2b, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x46, 0x61, 0x63, 0x65, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x66,
	0x61, 0x63, 0x65, 0x74, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65,
	0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69,
	0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x68, 0x61, 0x73, 0x5f, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x68,
	0x61, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x31, 0x0a, 0x07,
	0x6f, 0x70, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e,
	0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4f, 0x70, 0x74,
	0x4f, 0x75, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x06, 0x6f, 0x70, 0x74, 0x4f, 0x75, 0x74, 0x12,
	0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x43, 0x0a, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f,
	0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4c, 0x6f, 0x63, 0x61,
	0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69,
	0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3f, 0x0a, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
	0x69, 0x63, 0x69, 0x74, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1d, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x70, 0x65, 0x63, 0x69,
	0x66, 0x69, 0x63, 0x69, 0x74, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0b, 0x73, 0x70, 0x65, 0x63,
	0x69, 0x66, 0x69, 0x63, 0x69, 0x74, 0x79, 0x12, 0x4b, 0x0a, 0x11, 0x6d, 0x61, 0x6e, 0x69, 0x70,
	0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x07, 0x20, 0x03,
	0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x10, 0x6d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x36, 0x0a, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65,
	0x6e, 0x74, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x52, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x1a, 0x39, 0x0a, 0x0b,
	0x46, 0x61, 0x63, 0x65, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xa2, 0x01, 0x0a, 0x18, 0x49, 0x6d, 0x61, 0x67,
	0x65, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x49, 0x64, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67,
	0x65, 0x12, 0x17, 0x0a, 0x07, 0x6f, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x44, 0x69, 0x72, 0x12, 0x20, 0x0a, 0x0c, 0x68, 0x70,
	0x5f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0a, 0x68, 0x70, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x22, 0xd0, 0x03, 0x0a,
	0x11, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x45, 0x0a, 0x0f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x5f, 0x64, 0x65, 0x74, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x63, 0x6f, 0x72, 0x65,
	0x64, 0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0e, 0x66, 0x72, 0x61, 0x6d, 0x65,
	0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x39, 0x0a, 0x0c, 0x66, 0x72, 0x61,
	0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x74, 0x6f, 0x75, 0x74, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49,
	0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0b, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x4f, 0x70,
	0x74, 0x6f, 0x75, 0x74, 0x12, 0x47, 0x0a, 0x0f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x64, 0x65,
	0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e,
	0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x63, 0x6f,
	0x72, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0e, 0x61,
	0x75, 0x64, 0x69, 0x6f, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3b, 0x0a,
	0x0c, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x74, 0x6f, 0x75, 0x74, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2e, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0b, 0x61,
	0x75, 0x64, 0x69, 0x6f, 0x4f, 0x70, 0x74, 0x6f, 0x75, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x76, 0x69,
	0x64, 0x65, 0x6f, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4d, 0x61,
	0x73, 0x6b, 0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x09, 0x76, 0x69, 0x64, 0x65,
	0x6f, 0x4d, 0x61, 0x73, 0x6b, 0x12, 0x46, 0x0a, 0x11, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f, 0x6d,
	0x61, 0x73, 0x6b, 0x5f, 0x6f, 0x70, 0x74, 0x6f, 0x75, 0x74, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x4d, 0x61, 0x73, 0x6b, 0x49, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0f, 0x76, 0x69,
	0x64, 0x65, 0x6f, 0x4d, 0x61, 0x73, 0x6b, 0x4f, 0x70, 0x74, 0x6f, 0x75, 0x74, 0x12, 0x30, 0x0a,
	0x14, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x5f, 0x74, 0x68, 0x72, 0x65,
	0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x01, 0x52, 0x12, 0x76, 0x69, 0x64,
	0x65, 0x6f, 0x4d, 0x61, 0x73, 0x6b, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x22,
	0xd5, 0x04, 0x0a, 0x11, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x43, 0x0a, 0x06, 0x66,
	0x61, 0x63, 0x65, 0x74, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f,
	0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x46, 0x61, 0x63,
	0x65, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x66, 0x61, 0x63, 0x65, 0x74, 0x73,
	0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65,
	0x12, 0x25, 0x0a, 0x0e, 0x68, 0x61, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e,
	0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x68, 0x61, 0x73, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x5f, 0x6f,
	0x75, 0x74, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4f, 0x70, 0x74,
	0x4f, 0x75, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x06, 0x6f, 0x70, 0x74, 0x4f, 0x75, 0x74, 0x12,
	0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x43, 0x0a, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f,
	0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4c, 0x6f, 0x63, 0x61,
	0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69,
	0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3f, 0x0a, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
	0x69, 0x63, 0x69, 0x74, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1d, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x70, 0x65, 0x63, 0x69,
	0x66, 0x69, 0x63, 0x69, 0x74, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0b, 0x73, 0x70, 0x65, 0x63,
	0x69, 0x66, 0x69, 0x63, 0x69, 0x74, 0x79, 0x12, 0x4b, 0x0a, 0x11, 0x6d, 0x61, 0x6e, 0x69, 0x70,
	0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x07, 0x20, 0x03,
	0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x10, 0x6d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x36, 0x0a, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65,
	0x6e, 0x74, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x52, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x1a, 0x39, 0x0a, 0x0b,
	0x46, 0x61, 0x63, 0x65, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xcb, 0x02, 0x0a, 0x18, 0x56, 0x69, 0x64, 0x65,
	0x6f, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x49, 0x64, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x05, 0x76, 0x69, 0x64, 0x65,
	0x6f, 0x12, 0x17, 0x0a, 0x07, 0x6f, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x44, 0x69, 0x72, 0x12, 0x20, 0x0a, 0x0c, 0x68, 0x70,
	0x5f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0a, 0x68, 0x70, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x12, 0x25, 0x0a, 0x0e,
	0x6b, 0x65, 0x65, 0x70, 0x5f, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x6b, 0x65, 0x65, 0x70, 0x57, 0x6f, 0x72, 0x6b, 0x73, 0x70,
	0x61, 0x63, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x6b, 0x69, 0x70, 0x5f, 0x61, 0x75, 0x64, 0x69,
	0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x64,
	0x69, 0x6f, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x6b, 0x69, 0x70, 0x5f, 0x76, 0x69, 0x73, 0x75, 0x61,
	0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x6b, 0x69, 0x70, 0x56, 0x69, 0x73,
	0x75, 0x61, 0x6c, 0x12, 0x27, 0x0a, 0x0f, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5f, 0x72, 0x65, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x64, 0x65,
	0x62, 0x75, 0x67, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x17, 0x0a, 0x07,
	0x67, 0x70, 0x75, 0x5f, 0x6f, 0x72, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x67,
	0x70, 0x75, 0x4f, 0x72, 0x64, 0x22, 0xfc, 0x02, 0x0a, 0x04, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x19,
	0x0a, 0x08, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x75, 0x72, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x66, 0x72, 0x6f, 0x6d, 0x55, 0x72, 0x69, 0x12, 0x15, 0x0a, 0x06, 0x74, 0x6f, 0x5f,
	0x75, 0x72, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x55, 0x72, 0x69,
	0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64,
	0x65, 0x6e, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x68, 0x61, 0x73, 0x5f, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d,
	0x68, 0x61, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x3c, 0x0a,
	0x09, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x08, 0x66, 0x72, 0x6f, 0x6d, 0x4d, 0x61, 0x73, 0x6b, 0x12, 0x38, 0x0a, 0x07, 0x74,
	0x6f, 0x5f, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d,
	0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67,
	0x65, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x74,
	0x6f, 0x4d, 0x61, 0x73, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x78, 0x70, 0x6c,
	0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x4b, 0x0a, 0x11, 0x6d, 0x61, 0x6e, 0x69, 0x70,
	0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x08, 0x20, 0x03,
	0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x10, 0x6d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x54, 0x79, 0x70, 0x65, 0x22, 0x68, 0x0a, 0x0b, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x6c,
	0x69, 0x63, 0x65, 0x12, 0x31, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2e, 0x4f, 0x70, 0x74, 0x4f, 0x75, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x06,
	0x6f, 0x70, 0x74, 0x4f, 0x75, 0x74, 0x12, 0x26, 0x0a, 0x04, 0x6c, 0x69, 0x6e, 0x6b, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x69, 0x6e, 0x6b, 0x52, 0x04, 0x6c, 0x69, 0x6e, 0x6b, 0x22, 0xbe,
	0x01, 0x0a, 0x12, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x6c, 0x69, 0x63, 0x65, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x49, 0x64, 0x12, 0x37, 0x0a, 0x0b, 0x70, 0x72, 0x6f, 0x62, 0x65, 0x5f, 0x69, 0x6d,
	0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69,
	0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x52, 0x0a, 0x70, 0x72, 0x6f, 0x62, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x37, 0x0a,
	0x0b, 0x64, 0x6f, 0x6e, 0x6f, 0x72, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0a, 0x64, 0x6f, 0x6e, 0x6f,
	0x72, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x6f, 0x75, 0x74, 0x5f, 0x64, 0x69,
	0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x44, 0x69, 0x72, 0x22,
	0x8f, 0x02, 0x0a, 0x10, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x61,
	0x73, 0x5f, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x68,
	0x61, 0x73, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x78,
	0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x43, 0x0a, 0x0c, 0x6c, 0x6f, 0x63,
	0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x52, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x29,
	0x0a, 0x10, 0x68, 0x61, 0x73, 0x5f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x68, 0x61, 0x73, 0x4c, 0x6f, 0x63,
	0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x36, 0x0a, 0x0a, 0x73, 0x75, 0x70,
	0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e,
	0x74, 0x22, 0x9c, 0x01, 0x0a, 0x17, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72,
	0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
	0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07,
	0x6f, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6f,
	0x75, 0x74, 0x44, 0x69, 0x72, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x05, 0x69, 0x6d,
	0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x5f, 0x69, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x49, 0x64,
	0x22, 0x8f, 0x02, 0x0a, 0x10, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x68,
	0x61, 0x73, 0x5f, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
	0x68, 0x61, 0x73, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c,
	0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65,
	0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x43, 0x0a, 0x0c, 0x6c, 0x6f,
	0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x56, 0x69, 0x64, 0x65, 0x6f, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x29, 0x0a, 0x10, 0x68, 0x61, 0x73, 0x5f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x68, 0x61, 0x73, 0x4c, 0x6f,
	0x63, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x36, 0x0a, 0x0a, 0x73, 0x75,
	0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x6d, 0x65,
	0x6e, 0x74, 0x22, 0x9c, 0x01, 0x0a, 0x17, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x61, 0x6d, 0x65,
	0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d,
	0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x12, 0x17, 0x0a,
	0x07, 0x6f, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x6f, 0x75, 0x74, 0x44, 0x69, 0x72, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x05, 0x69,
	0x6d, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x5f, 0x69,
	0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x49,
	0x64, 0x22, 0x62, 0x0a, 0x0b, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x53, 0x63, 0x6f, 0x72, 0x65,
	0x12, 0x1b, 0x0a, 0x09, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x49, 0x64, 0x12, 0x14, 0x0a,
	0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x63,
	0x6f, 0x72, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x6e,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x63, 0x0a, 0x0c, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x73, 0x12, 0x31, 0x0a, 0x06, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x53, 0x63, 0x6f, 0x72, 0x65,
	0x52, 0x06, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x6c,
	0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65,
	0x78, 0x70, 0x6c, 0x61, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x7b, 0x0a, 0x13, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64,
	0x12, 0x17, 0x0a, 0x07, 0x6f, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x44, 0x69, 0x72, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79,
	0x2a, 0x9f, 0x04, 0x0a, 0x10, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x11, 0x0a, 0x0d, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x55,
	0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x4d, 0x41, 0x4e, 0x49,
	0x50, 0x5f, 0x46, 0x49, 0x4c, 0x54, 0x45, 0x52, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x4d, 0x41,
	0x4e, 0x49, 0x50, 0x5f, 0x41, 0x44, 0x4a, 0x55, 0x53, 0x54, 0x5f, 0x43, 0x4f, 0x4c, 0x4f, 0x52,
	0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x52, 0x45, 0x4d, 0x4f,
	0x56, 0x45, 0x10, 0x03, 0x12, 0x1c, 0x0a, 0x18, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x43, 0x4f,
	0x4e, 0x54, 0x45, 0x4e, 0x54, 0x5f, 0x41, 0x57, 0x41, 0x52, 0x45, 0x5f, 0x46, 0x49, 0x4c, 0x4c,
	0x10, 0x04, 0x12, 0x19, 0x0a, 0x15, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x50, 0x41, 0x49, 0x4e,
	0x54, 0x42, 0x52, 0x55, 0x53, 0x48, 0x5f, 0x54, 0x4f, 0x4f, 0x4c, 0x10, 0x05, 0x12, 0x14, 0x0a,
	0x10, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x50, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x54, 0x4f, 0x4f,
	0x4c, 0x10, 0x06, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x42, 0x4c, 0x55,
	0x52, 0x10, 0x07, 0x12, 0x10, 0x0a, 0x0c, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x53, 0x50, 0x4c,
	0x49, 0x43, 0x45, 0x10, 0x08, 0x12, 0x0f, 0x0a, 0x0b, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x43,
	0x4c, 0x4f, 0x4e, 0x45, 0x10, 0x09, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f,
	0x43, 0x52, 0x4f, 0x50, 0x10, 0x0a, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f,
	0x46, 0x4c, 0x49, 0x50, 0x10, 0x0b, 0x12, 0x10, 0x0a, 0x0c, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f,
	0x52, 0x45, 0x53, 0x49, 0x5a, 0x45, 0x10, 0x0c, 0x12, 0x16, 0x0a, 0x12, 0x4d, 0x41, 0x4e, 0x49,
	0x50, 0x5f, 0x53, 0x45, 0x41, 0x4d, 0x5f, 0x43, 0x41, 0x52, 0x56, 0x49, 0x4e, 0x47, 0x10, 0x0d,
	0x12, 0x10, 0x0a, 0x0c, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x52, 0x4f, 0x54, 0x41, 0x54, 0x45,
	0x10, 0x0e, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x53, 0x4b, 0x45, 0x57,
	0x10, 0x0f, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x57, 0x41, 0x52, 0x50,
	0x10, 0x10, 0x12, 0x12, 0x0a, 0x0e, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x4d, 0x45, 0x54, 0x41,
	0x44, 0x41, 0x54, 0x41, 0x10, 0x11, 0x12, 0x17, 0x0a, 0x13, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f,
	0x41, 0x4e, 0x54, 0x49, 0x46, 0x4f, 0x52, 0x45, 0x4e, 0x53, 0x49, 0x43, 0x53, 0x10, 0x12, 0x12,
	0x19, 0x0a, 0x15, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x5f, 0x52,
	0x45, 0x43, 0x41, 0x50, 0x54, 0x55, 0x52, 0x45, 0x10, 0x13, 0x12, 0x0d, 0x0a, 0x09, 0x4d, 0x41,
	0x4e, 0x49, 0x50, 0x5f, 0x43, 0x47, 0x49, 0x10, 0x14, 0x12, 0x19, 0x0a, 0x15, 0x4d, 0x41, 0x4e,
	0x49, 0x50, 0x5f, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x45, 0x52, 0x54, 0x49,
	0x4f, 0x4e, 0x10, 0x15, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x46, 0x52,
	0x41, 0x4d, 0x45, 0x5f, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x16, 0x12, 0x0f, 0x0a, 0x0b, 0x4d, 0x41,
	0x4e, 0x49, 0x50, 0x5f, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x10, 0x17, 0x12, 0x14, 0x0a, 0x10, 0x4d,
	0x41, 0x4e, 0x49, 0x50, 0x5f, 0x44, 0x4f, 0x55, 0x42, 0x4c, 0x45, 0x5f, 0x4a, 0x50, 0x47, 0x10,
	0x18, 0x12, 0x0f, 0x0a, 0x0b, 0x4d, 0x41, 0x4e, 0x49, 0x50, 0x5f, 0x4f, 0x54, 0x48, 0x45, 0x52,
	0x10, 0x19, 0x2a, 0x55, 0x0a, 0x0f, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x69, 0x74,
	0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0f, 0x0a, 0x0b, 0x53, 0x50, 0x45, 0x43, 0x5f, 0x47, 0x4c,
	0x4f, 0x42, 0x41, 0x4c, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x50, 0x45, 0x43, 0x5f, 0x46,
	0x52, 0x41, 0x4d, 0x45, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x50, 0x45, 0x43, 0x5f, 0x50,
	0x49, 0x58, 0x45, 0x4c, 0x10, 0x02, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x50, 0x45, 0x43, 0x5f, 0x4d,
	0x45, 0x54, 0x41, 0x44, 0x41, 0x54, 0x41, 0x10, 0x03, 0x2a, 0x60, 0x0a, 0x0a, 0x4f, 0x70, 0x74,
	0x4f, 0x75, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x0c, 0x4f, 0x50, 0x54, 0x5f, 0x4f,
	0x55, 0x54, 0x5f, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x4f, 0x50, 0x54,
	0x5f, 0x4f, 0x55, 0x54, 0x5f, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x4f, 0x50,
	0x54, 0x5f, 0x4f, 0x55, 0x54, 0x5f, 0x44, 0x45, 0x54, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x10,
	0x02, 0x12, 0x18, 0x0a, 0x14, 0x4f, 0x50, 0x54, 0x5f, 0x4f, 0x55, 0x54, 0x5f, 0x4c, 0x4f, 0x43,
	0x41, 0x4c, 0x49, 0x5a, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x2a, 0x65, 0x0a, 0x0f, 0x56,
	0x69, 0x64, 0x65, 0x6f, 0x4f, 0x70, 0x74, 0x4f, 0x75, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1b,
	0x0a, 0x17, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4f, 0x50, 0x54, 0x5f, 0x4f, 0x55, 0x54, 0x5f,
	0x44, 0x45, 0x54, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x56,
	0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4f, 0x50, 0x54, 0x5f, 0x4f, 0x55, 0x54, 0x5f, 0x54, 0x45, 0x4d,
	0x50, 0x4f, 0x52, 0x41, 0x4c, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x56, 0x49, 0x44, 0x45, 0x4f,
	0x5f, 0x4f, 0x50, 0x54, 0x5f, 0x4f, 0x55, 0x54, 0x5f, 0x53, 0x50, 0x41, 0x54, 0x49, 0x41, 0x4c,
	0x10, 0x02, 0x32, 0xed, 0x04, 0x0a, 0x08, 0x41, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x12,
	0x62, 0x0a, 0x17, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61,
	0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x26, 0x2e, 0x6d, 0x65, 0x64,
	0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d,
	0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x50, 0x0a, 0x11, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x53, 0x70, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x20, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53, 0x70, 0x6c,
	0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x6d, 0x65, 0x64,
	0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x53,
	0x70, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x62, 0x0a, 0x17, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x56,
	0x69, 0x64, 0x65, 0x6f, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x26, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x61, 0x6e, 0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x61, 0x6e,
	0x69, 0x70, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x5f, 0x0a, 0x16, 0x44, 0x65, 0x74,
	0x65, 0x63, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x12, 0x25, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x6d, 0x65, 0x64,
	0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43,
	0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x53, 0x0a, 0x12, 0x44, 0x65,
	0x74, 0x65, 0x63, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x73,
	0x12, 0x21, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x73, 0x12,
	0x5f, 0x0a, 0x16, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x25, 0x2e, 0x6d, 0x65, 0x64, 0x69,
	0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x1e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x12, 0x30, 0x0a, 0x04, 0x4b, 0x69, 0x6c, 0x6c, 0x12, 0x13, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x66,
	0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x13, 0x2e,
	0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x42, 0x34, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x66, 0x6f, 0x72, 0x65, 0x6e, 0x73, 0x69, 0x63, 0x73, 0x2f,
	0x6d, 0x65, 0x64, 0x69, 0x66, 0x6f, 0x72, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x6d, 0x65, 0x64, 0x69,
	0x66, 0x6f, 0x72, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_medifor_v1_analytic_proto_rawDescOnce sync.Once
	file_medifor_v1_analytic_proto_rawDescData = file_medifor_v1_analytic_proto_rawDesc
)

func file_medifor_v1_analytic_proto_rawDescGZIP() []byte {
	file_medifor_v1_analytic_proto_rawDescOnce.Do(func() {
		file_medifor_v1_analytic_proto_rawDescData = protoimpl.X.CompressGZIP(file_medifor_v1_analytic_proto_rawDescData)
	})
	return file_medifor_v1_analytic_proto_rawDescData
}

var file_medifor_v1_analytic_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_medifor_v1_analytic_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_medifor_v1_analytic_proto_goTypes = []interface{}{
	(ManipulationType)(0),            // 0: mediforproto.ManipulationType
	(SpecificityType)(0),             // 1: mediforproto.SpecificityType
	(OptOutType)(0),                  // 2: mediforproto.OptOutType
	(VideoOptOutType)(0),             // 3: mediforproto.VideoOptOutType
	(*Detection)(nil),                // 4: mediforproto.Detection
	(*AnnotatedDetection)(nil),       // 5: mediforproto.AnnotatedDetection
	(*Resource)(nil),                 // 6: mediforproto.Resource
	(*IntRange)(nil),                 // 7: mediforproto.IntRange
	(*ScoredIntRange)(nil),           // 8: mediforproto.ScoredIntRange
	(*MaskIntRange)(nil),             // 9: mediforproto.MaskIntRange
	(*FloatRange)(nil),               // 10: mediforproto.FloatRange
	(*ScoredFloatRange)(nil),         // 11: mediforproto.ScoredFloatRange
	(*ImageLocalization)(nil),        // 12: mediforproto.ImageLocalization
	(*ImageManipulation)(nil),        // 13: mediforproto.ImageManipulation
	(*ImageManipulationRequest)(nil), // 14: mediforproto.ImageManipulationRequest
	(*VideoLocalization)(nil),        // 15: mediforproto.VideoLocalization
	(*VideoManipulation)(nil),        // 16: mediforproto.VideoManipulation
	(*VideoManipulationRequest)(nil), // 17: mediforproto.VideoManipulationRequest
	(*Link)(nil),                     // 18: mediforproto.Link
	(*ImageSplice)(nil),              // 19: mediforproto.ImageSplice
	(*ImageSpliceRequest)(nil),       // 20: mediforproto.ImageSpliceRequest
	(*ImageCameraMatch)(nil),         // 21: mediforproto.ImageCameraMatch
	(*ImageCameraMatchRequest)(nil),  // 22: mediforproto.ImageCameraMatchRequest
	(*VideoCameraMatch)(nil),         // 23: mediforproto.VideoCameraMatch
	(*VideoCameraMatchRequest)(nil),  // 24: mediforproto.VideoCameraMatchRequest
	(*CameraScore)(nil),              // 25: mediforproto.CameraScore
	(*ImageCameras)(nil),             // 26: mediforproto.ImageCameras
	(*ImageCamerasRequest)(nil),      // 27: mediforproto.ImageCamerasRequest
	(*Empty)(nil),                    // 28: mediforproto.Empty
	nil,                              // 29: mediforproto.ImageManipulation.FacetsEntry
	nil,                              // 30: mediforproto.VideoManipulation.FacetsEntry
	(*status.Status)(nil),            // 31: google.rpc.Status
}
var file_medifor_v1_analytic_proto_depIdxs = []int32{
	31, // 0: mediforproto.Detection.status:type_name -> google.rpc.Status
	14, // 1: mediforproto.Detection.img_manip_req:type_name -> mediforproto.ImageManipulationRequest
	17, // 2: mediforproto.Detection.vid_manip_req:type_name -> mediforproto.VideoManipulationRequest
	20, // 3: mediforproto.Detection.img_splice_req:type_name -> mediforproto.ImageSpliceRequest
	22, // 4: mediforproto.Detection.img_cam_match_req:type_name -> mediforproto.ImageCameraMatchRequest
	27, // 5: mediforproto.Detection.img_cams_req:type_name -> mediforproto.ImageCamerasRequest
	24, // 6: mediforproto.Detection.vid_cam_match_req:type_name -> mediforproto.VideoCameraMatchRequest
	13, // 7: mediforproto.Detection.img_manip:type_name -> mediforproto.ImageManipulation
	16, // 8: mediforproto.Detection.vid_manip:type_name -> mediforproto.VideoManipulation
	19, // 9: mediforproto.Detection.img_splice:type_name -> mediforproto.ImageSplice
	21, // 10: mediforproto.Detection.img_cam_match:type_name -> mediforproto.ImageCameraMatch
	26, // 11: mediforproto.Detection.img_cams:type_name -> mediforproto.ImageCameras
	23, // 12: mediforproto.Detection.vid_cam_match:type_name -> mediforproto.VideoCameraMatch
	4,  // 13: mediforproto.AnnotatedDetection.detection:type_name -> mediforproto.Detection
	7,  // 14: mediforproto.ScoredIntRange.range:type_name -> mediforproto.IntRange
	7,  // 15: mediforproto.MaskIntRange.range:type_name -> mediforproto.IntRange
	6,  // 16: mediforproto.MaskIntRange.mask:type_name -> mediforproto.Resource
	10, // 17: mediforproto.ScoredFloatRange.range:type_name -> mediforproto.FloatRange
	6,  // 18: mediforproto.ImageLocalization.mask:type_name -> mediforproto.Resource
	6,  // 19: mediforproto.ImageLocalization.mask_optout:type_name -> mediforproto.Resource
	29, // 20: mediforproto.ImageManipulation.facets:type_name -> mediforproto.ImageManipulation.FacetsEntry
	2,  // 21: mediforproto.ImageManipulation.opt_out:type_name -> mediforproto.OptOutType
	12, // 22: mediforproto.ImageManipulation.localization:type_name -> mediforproto.ImageLocalization
	1,  // 23: mediforproto.ImageManipulation.specificity:type_name -> mediforproto.SpecificityType
	0,  // 24: mediforproto.ImageManipulation.manipulation_type:type_name -> mediforproto.ManipulationType
	6,  // 25: mediforproto.ImageManipulation.supplement:type_name -> mediforproto.Resource
	6,  // 26: mediforproto.ImageManipulationRequest.image:type_name -> mediforproto.Resource
	8,  // 27: mediforproto.VideoLocalization.frame_detection:type_name -> mediforproto.ScoredIntRange
	7,  // 28: mediforproto.VideoLocalization.frame_optout:type_name -> mediforproto.IntRange
	11, // 29: mediforproto.VideoLocalization.audio_detection:type_name -> mediforproto.ScoredFloatRange
	10, // 30: mediforproto.VideoLocalization.audio_optout:type_name -> mediforproto.FloatRange
	9,  // 31: mediforproto.VideoLocalization.video_mask:type_name -> mediforproto.MaskIntRange
	9,  // 32: mediforproto.VideoLocalization.video_mask_optout:type_name -> mediforproto.MaskIntRange
	30, // 33: mediforproto.VideoManipulation.facets:type_name -> mediforproto.VideoManipulation.FacetsEntry
	3,  // 34: mediforproto.VideoManipulation.opt_out:type_name -> mediforproto.VideoOptOutType
	15, // 35: mediforproto.VideoManipulation.localization:type_name -> mediforproto.VideoLocalization
	1,  // 36: mediforproto.VideoManipulation.specificity:type_name -> mediforproto.SpecificityType
	0,  // 37: mediforproto.VideoManipulation.manipulation_type:type_name -> mediforproto.ManipulationType
	6,  // 38: mediforproto.VideoManipulation.supplement:type_name -> mediforproto.Resource
	6,  // 39: mediforproto.VideoManipulationRequest.video:type_name -> mediforproto.Resource
	12, // 40: mediforproto.Link.from_mask:type_name -> mediforproto.ImageLocalization
	12, // 41: mediforproto.Link.to_mask:type_name -> mediforproto.ImageLocalization
	0,  // 42: mediforproto.Link.manipulation_type:type_name -> mediforproto.ManipulationType
	2,  // 43: mediforproto.ImageSplice.opt_out:type_name -> mediforproto.OptOutType
	18, // 44: mediforproto.ImageSplice.link:type_name -> mediforproto.Link
	6,  // 45: mediforproto.ImageSpliceRequest.probe_image:type_name -> mediforproto.Resource
	6,  // 46: mediforproto.ImageSpliceRequest.donor_image:type_name -> mediforproto.Resource
	12, // 47: mediforproto.ImageCameraMatch.localization:type_name -> mediforproto.ImageLocalization
	6,  // 48: mediforproto.ImageCameraMatch.supplement:type_name -> mediforproto.Resource
	6,  // 49: mediforproto.ImageCameraMatchRequest.image:type_name -> mediforproto.Resource
	15, // 50: mediforproto.VideoCameraMatch.localization:type_name -> mediforproto.VideoLocalization
	6,  // 51: mediforproto.VideoCameraMatch.supplement:type_name -> mediforproto.Resource
	6,  // 52: mediforproto.VideoCameraMatchRequest.image:type_name -> mediforproto.Resource
	25, // 53: mediforproto.ImageCameras.scores:type_name -> mediforproto.CameraScore
	6,  // 54: mediforproto.ImageCamerasRequest.image:type_name -> mediforproto.Resource
	14, // 55: mediforproto.Analytic.DetectImageManipulation:input_type -> mediforproto.ImageManipulationRequest
	20, // 56: mediforproto.Analytic.DetectImageSplice:input_type -> mediforproto.ImageSpliceRequest
	17, // 57: mediforproto.Analytic.DetectVideoManipulation:input_type -> mediforproto.VideoManipulationRequest
	22, // 58: mediforproto.Analytic.DetectImageCameraMatch:input_type -> mediforproto.ImageCameraMatchRequest
	27, // 59: mediforproto.Analytic.DetectImageCameras:input_type -> mediforproto.ImageCamerasRequest
	24, // 60: mediforproto.Analytic.DetectVideoCameraMatch:input_type -> mediforproto.VideoCameraMatchRequest
	28, // 61: mediforproto.Analytic.Kill:input_type -> mediforproto.Empty
	13, // 62: mediforproto.Analytic.DetectImageManipulation:output_type -> mediforproto.ImageManipulation
	19, // 63: mediforproto.Analytic.DetectImageSplice:output_type -> mediforproto.ImageSplice
	16, // 64: mediforproto.Analytic.DetectVideoManipulation:output_type -> mediforproto.VideoManipulation
	21, // 65: mediforproto.Analytic.DetectImageCameraMatch:output_type -> mediforproto.ImageCameraMatch
	26, // 66: mediforproto.Analytic.DetectImageCameras:output_type -> mediforproto.ImageCameras
	23, // 67: mediforproto.Analytic.DetectVideoCameraMatch:output_type -> mediforproto.VideoCameraMatch
	28, // 68: mediforproto.Analytic.Kill:output_type -> mediforproto.Empty
	62, // [62:69] is the sub-list for method output_type
	55, // [55:62] is the sub-list for method input_type
	55, // [55:55] is the sub-list for extension type_name
	55, // [55:55] is the sub-list for extension extendee
	0,  // [0:55] is the sub-list for field type_name
}

func init() { file_medifor_v1_analytic_proto_init() }
func file_medifor_v1_analytic_proto_init() {
	if File_medifor_v1_analytic_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_medifor_v1_analytic_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Detection); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AnnotatedDetection); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Resource); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ScoredIntRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MaskIntRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FloatRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ScoredFloatRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageLocalization); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageManipulation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageManipulationRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoLocalization); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoManipulation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoManipulationRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Link); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageSplice); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageSpliceRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageCameraMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageCameraMatchRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoCameraMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoCameraMatchRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CameraScore); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageCameras); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageCamerasRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_medifor_v1_analytic_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Empty); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_medifor_v1_analytic_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*Detection_ImgManipReq)(nil),
		(*Detection_VidManipReq)(nil),
		(*Detection_ImgSpliceReq)(nil),
		(*Detection_ImgCamMatchReq)(nil),
		(*Detection_ImgCamsReq)(nil),
		(*Detection_VidCamMatchReq)(nil),
		(*Detection_ImgManip)(nil),
		(*Detection_VidManip)(nil),
		(*Detection_ImgSplice)(nil),
		(*Detection_ImgCamMatch)(nil),
		(*Detection_ImgCams)(nil),
		(*Detection_VidCamMatch)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_medifor_v1_analytic_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_medifor_v1_analytic_proto_goTypes,
		DependencyIndexes: file_medifor_v1_analytic_proto_depIdxs,
		EnumInfos:         file_medifor_v1_analytic_proto_enumTypes,
		MessageInfos:      file_medifor_v1_analytic_proto_msgTypes,
	}.Build()
	File_medifor_v1_analytic_proto = out.File
	file_medifor_v1_analytic_proto_rawDesc = nil
	file_medifor_v1_analytic_proto_goTypes = nil
	file_medifor_v1_analytic_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// AnalyticClient is the client API for Analytic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnalyticClient interface {
	DetectImageManipulation(ctx context.Context, in *ImageManipulationRequest, opts ...grpc.CallOption) (*ImageManipulation, error)
	DetectImageSplice(ctx context.Context, in *ImageSpliceRequest, opts ...grpc.CallOption) (*ImageSplice, error)
	DetectVideoManipulation(ctx context.Context, in *VideoManipulationRequest, opts ...grpc.CallOption) (*VideoManipulation, error)
	DetectImageCameraMatch(ctx context.Context, in *ImageCameraMatchRequest, opts ...grpc.CallOption) (*ImageCameraMatch, error)
	DetectImageCameras(ctx context.Context, in *ImageCamerasRequest, opts ...grpc.CallOption) (*ImageCameras, error)
	DetectVideoCameraMatch(ctx context.Context, in *VideoCameraMatchRequest, opts ...grpc.CallOption) (*VideoCameraMatch, error)
	Kill(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type analyticClient struct {
	cc grpc.ClientConnInterface
}

func NewAnalyticClient(cc grpc.ClientConnInterface) AnalyticClient {
	return &analyticClient{cc}
}

func (c *analyticClient) DetectImageManipulation(ctx context.Context, in *ImageManipulationRequest, opts ...grpc.CallOption) (*ImageManipulation, error) {
	out := new(ImageManipulation)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageManipulation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectImageSplice(ctx context.Context, in *ImageSpliceRequest, opts ...grpc.CallOption) (*ImageSplice, error) {
	out := new(ImageSplice)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageSplice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectVideoManipulation(ctx context.Context, in *VideoManipulationRequest, opts ...grpc.CallOption) (*VideoManipulation, error) {
	out := new(VideoManipulation)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectVideoManipulation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectImageCameraMatch(ctx context.Context, in *ImageCameraMatchRequest, opts ...grpc.CallOption) (*ImageCameraMatch, error) {
	out := new(ImageCameraMatch)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageCameraMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectImageCameras(ctx context.Context, in *ImageCamerasRequest, opts ...grpc.CallOption) (*ImageCameras, error) {
	out := new(ImageCameras)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectImageCameras", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) DetectVideoCameraMatch(ctx context.Context, in *VideoCameraMatchRequest, opts ...grpc.CallOption) (*VideoCameraMatch, error) {
	out := new(VideoCameraMatch)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/DetectVideoCameraMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticClient) Kill(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/mediforproto.Analytic/Kill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnalyticServer is the server API for Analytic service.
type AnalyticServer interface {
	DetectImageManipulation(context.Context, *ImageManipulationRequest) (*ImageManipulation, error)
	DetectImageSplice(context.Context, *ImageSpliceRequest) (*ImageSplice, error)
	DetectVideoManipulation(context.Context, *VideoManipulationRequest) (*VideoManipulation, error)
	DetectImageCameraMatch(context.Context, *ImageCameraMatchRequest) (*ImageCameraMatch, error)
	DetectImageCameras(context.Context, *ImageCamerasRequest) (*ImageCameras, error)
	DetectVideoCameraMatch(context.Context, *VideoCameraMatchRequest) (*VideoCameraMatch, error)
	Kill(context.Context, *Empty) (*Empty, error)
}

// UnimplementedAnalyticServer can be embedded to have forward compatible implementations.
type UnimplementedAnalyticServer struct {
}

func (*UnimplementedAnalyticServer) DetectImageManipulation(context.Context, *ImageManipulationRequest) (*ImageManipulation, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method DetectImageManipulation not implemented")
}
func (*UnimplementedAnalyticServer) DetectImageSplice(context.Context, *ImageSpliceRequest) (*ImageSplice, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method DetectImageSplice not implemented")
}
func (*UnimplementedAnalyticServer) DetectVideoManipulation(context.Context, *VideoManipulationRequest) (*VideoManipulation, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method DetectVideoManipulation not implemented")
}
func (*UnimplementedAnalyticServer) DetectImageCameraMatch(context.Context, *ImageCameraMatchRequest) (*ImageCameraMatch, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method DetectImageCameraMatch not implemented")
}
func (*UnimplementedAnalyticServer) DetectImageCameras(context.Context, *ImageCamerasRequest) (*ImageCameras, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method DetectImageCameras not implemented")
}
func (*UnimplementedAnalyticServer) DetectVideoCameraMatch(context.Context, *VideoCameraMatchRequest) (*VideoCameraMatch, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method DetectVideoCameraMatch not implemented")
}
func (*UnimplementedAnalyticServer) Kill(context.Context, *Empty) (*Empty, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method Kill not implemented")
}

func RegisterAnalyticServer(s *grpc.Server, srv AnalyticServer) {
	s.RegisterService(&_Analytic_serviceDesc, srv)
}

func _Analytic_DetectImageManipulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageManipulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageManipulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageManipulation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageManipulation(ctx, req.(*ImageManipulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectImageSplice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageSpliceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageSplice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageSplice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageSplice(ctx, req.(*ImageSpliceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectVideoManipulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoManipulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectVideoManipulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectVideoManipulation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectVideoManipulation(ctx, req.(*VideoManipulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectImageCameraMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageCameraMatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageCameraMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageCameraMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageCameraMatch(ctx, req.(*ImageCameraMatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectImageCameras_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageCamerasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectImageCameras(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectImageCameras",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectImageCameras(ctx, req.(*ImageCamerasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_DetectVideoCameraMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoCameraMatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).DetectVideoCameraMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/DetectVideoCameraMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).DetectVideoCameraMatch(ctx, req.(*VideoCameraMatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Analytic_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Analytic/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticServer).Kill(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Analytic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mediforproto.Analytic",
	HandlerType: (*AnalyticServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DetectImageManipulation",
			Handler:    _Analytic_DetectImageManipulation_Handler,
		},
		{
			MethodName: "DetectImageSplice",
			Handler:    _Analytic_DetectImageSplice_Handler,
		},
		{
			MethodName: "DetectVideoManipulation",
			Handler:    _Analytic_DetectVideoManipulation_Handler,
		},
		{
			MethodName: "DetectImageCameraMatch",
			Handler:    _Analytic_DetectImageCameraMatch_Handler,
		},
		{
			MethodName: "DetectImageCameras",
			Handler:    _Analytic_DetectImageCameras_Handler,
		},
		{
			MethodName: "DetectVideoCameraMatch",
			Handler:    _Analytic_DetectVideoCameraMatch_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Analytic_Kill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "medifor/v1/analytic.proto",
}
