// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fusion.proto

package mediforproto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Fusion holds round-trip information for any of the "FuseFoo" request/response endpoints.
type Fusion struct {
	// Standard RPC status - we stash the actual RPC error/non-error here.
	Status *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Round-trip request-response timings. Milliseconds since the Epoch.
	StartTimeMillis int64 `protobuf:"varint,2,opt,name=start_time_millis,json=startTimeMillis,proto3" json:"start_time_millis,omitempty"`
	EndTimeMillis   int64 `protobuf:"varint,3,opt,name=end_time_millis,json=endTimeMillis,proto3" json:"end_time_millis,omitempty"`
	// The request made to the analytic.
	//
	// Types that are valid to be assigned to Request:
	//	*Fusion_ImgManipReq
	//	*Fusion_VidManipReq
	//	*Fusion_ImgSpliceReq
	//	*Fusion_ImgCamMatchReq
	Request isFusion_Request `protobuf_oneof:"request"`
	// The response received from the analytic.
	//
	// Types that are valid to be assigned to Response:
	//	*Fusion_ImgManip
	//	*Fusion_VidManip
	//	*Fusion_ImgSplice
	//	*Fusion_ImgCamMatch
	Response             isFusion_Response `protobuf_oneof:"response"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Fusion) Reset()         { *m = Fusion{} }
func (m *Fusion) String() string { return proto.CompactTextString(m) }
func (*Fusion) ProtoMessage()    {}
func (*Fusion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{0}
}

func (m *Fusion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Fusion.Unmarshal(m, b)
}
func (m *Fusion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Fusion.Marshal(b, m, deterministic)
}
func (m *Fusion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fusion.Merge(m, src)
}
func (m *Fusion) XXX_Size() int {
	return xxx_messageInfo_Fusion.Size(m)
}
func (m *Fusion) XXX_DiscardUnknown() {
	xxx_messageInfo_Fusion.DiscardUnknown(m)
}

var xxx_messageInfo_Fusion proto.InternalMessageInfo

func (m *Fusion) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Fusion) GetStartTimeMillis() int64 {
	if m != nil {
		return m.StartTimeMillis
	}
	return 0
}

func (m *Fusion) GetEndTimeMillis() int64 {
	if m != nil {
		return m.EndTimeMillis
	}
	return 0
}

type isFusion_Request interface {
	isFusion_Request()
}

type Fusion_ImgManipReq struct {
	ImgManipReq *FuseImageManipulationRequest `protobuf:"bytes,11,opt,name=img_manip_req,json=imgManipReq,proto3,oneof"`
}

type Fusion_VidManipReq struct {
	VidManipReq *FuseVideoManipulationRequest `protobuf:"bytes,12,opt,name=vid_manip_req,json=vidManipReq,proto3,oneof"`
}

type Fusion_ImgSpliceReq struct {
	ImgSpliceReq *FuseImageSpliceRequest `protobuf:"bytes,13,opt,name=img_splice_req,json=imgSpliceReq,proto3,oneof"`
}

type Fusion_ImgCamMatchReq struct {
	ImgCamMatchReq *FuseImageCameraMatchRequest `protobuf:"bytes,14,opt,name=img_cam_match_req,json=imgCamMatchReq,proto3,oneof"`
}

func (*Fusion_ImgManipReq) isFusion_Request() {}

func (*Fusion_VidManipReq) isFusion_Request() {}

func (*Fusion_ImgSpliceReq) isFusion_Request() {}

func (*Fusion_ImgCamMatchReq) isFusion_Request() {}

func (m *Fusion) GetRequest() isFusion_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Fusion) GetImgManipReq() *FuseImageManipulationRequest {
	if x, ok := m.GetRequest().(*Fusion_ImgManipReq); ok {
		return x.ImgManipReq
	}
	return nil
}

func (m *Fusion) GetVidManipReq() *FuseVideoManipulationRequest {
	if x, ok := m.GetRequest().(*Fusion_VidManipReq); ok {
		return x.VidManipReq
	}
	return nil
}

func (m *Fusion) GetImgSpliceReq() *FuseImageSpliceRequest {
	if x, ok := m.GetRequest().(*Fusion_ImgSpliceReq); ok {
		return x.ImgSpliceReq
	}
	return nil
}

func (m *Fusion) GetImgCamMatchReq() *FuseImageCameraMatchRequest {
	if x, ok := m.GetRequest().(*Fusion_ImgCamMatchReq); ok {
		return x.ImgCamMatchReq
	}
	return nil
}

type isFusion_Response interface {
	isFusion_Response()
}

type Fusion_ImgManip struct {
	ImgManip *ImageManipulation `protobuf:"bytes,21,opt,name=img_manip,json=imgManip,proto3,oneof"`
}

type Fusion_VidManip struct {
	VidManip *VideoManipulation `protobuf:"bytes,22,opt,name=vid_manip,json=vidManip,proto3,oneof"`
}

type Fusion_ImgSplice struct {
	ImgSplice *ImageSplice `protobuf:"bytes,23,opt,name=img_splice,json=imgSplice,proto3,oneof"`
}

type Fusion_ImgCamMatch struct {
	ImgCamMatch *ImageCameraMatch `protobuf:"bytes,24,opt,name=img_cam_match,json=imgCamMatch,proto3,oneof"`
}

func (*Fusion_ImgManip) isFusion_Response() {}

func (*Fusion_VidManip) isFusion_Response() {}

func (*Fusion_ImgSplice) isFusion_Response() {}

func (*Fusion_ImgCamMatch) isFusion_Response() {}

func (m *Fusion) GetResponse() isFusion_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Fusion) GetImgManip() *ImageManipulation {
	if x, ok := m.GetResponse().(*Fusion_ImgManip); ok {
		return x.ImgManip
	}
	return nil
}

func (m *Fusion) GetVidManip() *VideoManipulation {
	if x, ok := m.GetResponse().(*Fusion_VidManip); ok {
		return x.VidManip
	}
	return nil
}

func (m *Fusion) GetImgSplice() *ImageSplice {
	if x, ok := m.GetResponse().(*Fusion_ImgSplice); ok {
		return x.ImgSplice
	}
	return nil
}

func (m *Fusion) GetImgCamMatch() *ImageCameraMatch {
	if x, ok := m.GetResponse().(*Fusion_ImgCamMatch); ok {
		return x.ImgCamMatch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Fusion) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Fusion_OneofMarshaler, _Fusion_OneofUnmarshaler, _Fusion_OneofSizer, []interface{}{
		(*Fusion_ImgManipReq)(nil),
		(*Fusion_VidManipReq)(nil),
		(*Fusion_ImgSpliceReq)(nil),
		(*Fusion_ImgCamMatchReq)(nil),
		(*Fusion_ImgManip)(nil),
		(*Fusion_VidManip)(nil),
		(*Fusion_ImgSplice)(nil),
		(*Fusion_ImgCamMatch)(nil),
	}
}

func _Fusion_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Fusion)
	// request
	switch x := m.Request.(type) {
	case *Fusion_ImgManipReq:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgManipReq); err != nil {
			return err
		}
	case *Fusion_VidManipReq:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VidManipReq); err != nil {
			return err
		}
	case *Fusion_ImgSpliceReq:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgSpliceReq); err != nil {
			return err
		}
	case *Fusion_ImgCamMatchReq:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgCamMatchReq); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Fusion.Request has unexpected type %T", x)
	}
	// response
	switch x := m.Response.(type) {
	case *Fusion_ImgManip:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgManip); err != nil {
			return err
		}
	case *Fusion_VidManip:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VidManip); err != nil {
			return err
		}
	case *Fusion_ImgSplice:
		b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgSplice); err != nil {
			return err
		}
	case *Fusion_ImgCamMatch:
		b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImgCamMatch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Fusion.Response has unexpected type %T", x)
	}
	return nil
}

func _Fusion_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Fusion)
	switch tag {
	case 11: // request.img_manip_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FuseImageManipulationRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Fusion_ImgManipReq{msg}
		return true, err
	case 12: // request.vid_manip_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FuseVideoManipulationRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Fusion_VidManipReq{msg}
		return true, err
	case 13: // request.img_splice_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FuseImageSpliceRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Fusion_ImgSpliceReq{msg}
		return true, err
	case 14: // request.img_cam_match_req
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FuseImageCameraMatchRequest)
		err := b.DecodeMessage(msg)
		m.Request = &Fusion_ImgCamMatchReq{msg}
		return true, err
	case 21: // response.img_manip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageManipulation)
		err := b.DecodeMessage(msg)
		m.Response = &Fusion_ImgManip{msg}
		return true, err
	case 22: // response.vid_manip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoManipulation)
		err := b.DecodeMessage(msg)
		m.Response = &Fusion_VidManip{msg}
		return true, err
	case 23: // response.img_splice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageSplice)
		err := b.DecodeMessage(msg)
		m.Response = &Fusion_ImgSplice{msg}
		return true, err
	case 24: // response.img_cam_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageCameraMatch)
		err := b.DecodeMessage(msg)
		m.Response = &Fusion_ImgCamMatch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Fusion_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Fusion)
	// request
	switch x := m.Request.(type) {
	case *Fusion_ImgManipReq:
		s := proto.Size(x.ImgManipReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fusion_VidManipReq:
		s := proto.Size(x.VidManipReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fusion_ImgSpliceReq:
		s := proto.Size(x.ImgSpliceReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fusion_ImgCamMatchReq:
		s := proto.Size(x.ImgCamMatchReq)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// response
	switch x := m.Response.(type) {
	case *Fusion_ImgManip:
		s := proto.Size(x.ImgManip)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fusion_VidManip:
		s := proto.Size(x.VidManip)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fusion_ImgSplice:
		s := proto.Size(x.ImgSplice)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Fusion_ImgCamMatch:
		s := proto.Size(x.ImgCamMatch)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Next Tag: 4
type AnnotatedImageManipulation struct {
	Id                   string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version              string             `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Data                 *ImageManipulation `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AnnotatedImageManipulation) Reset()         { *m = AnnotatedImageManipulation{} }
func (m *AnnotatedImageManipulation) String() string { return proto.CompactTextString(m) }
func (*AnnotatedImageManipulation) ProtoMessage()    {}
func (*AnnotatedImageManipulation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{1}
}

func (m *AnnotatedImageManipulation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotatedImageManipulation.Unmarshal(m, b)
}
func (m *AnnotatedImageManipulation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotatedImageManipulation.Marshal(b, m, deterministic)
}
func (m *AnnotatedImageManipulation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedImageManipulation.Merge(m, src)
}
func (m *AnnotatedImageManipulation) XXX_Size() int {
	return xxx_messageInfo_AnnotatedImageManipulation.Size(m)
}
func (m *AnnotatedImageManipulation) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedImageManipulation.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedImageManipulation proto.InternalMessageInfo

func (m *AnnotatedImageManipulation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotatedImageManipulation) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnnotatedImageManipulation) GetData() *ImageManipulation {
	if m != nil {
		return m.Data
	}
	return nil
}

// Next Tag: 6
type FuseImageManipulationRequest struct {
	RequestId   string                        `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	OutDir      string                        `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	ImgManipReq *ImageManipulationRequest     `protobuf:"bytes,3,opt,name=img_manip_req,json=imgManipReq,proto3" json:"img_manip_req,omitempty"`
	ImgManip    []*AnnotatedImageManipulation `protobuf:"bytes,4,rep,name=img_manip,json=imgManip,proto3" json:"img_manip,omitempty"`
	// If this is set, the fusion algorithm should produce mask output. Otherwise
	// it should only produce a score.
	WantMasks            bool     `protobuf:"varint,5,opt,name=want_masks,json=wantMasks,proto3" json:"want_masks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseImageManipulationRequest) Reset()         { *m = FuseImageManipulationRequest{} }
func (m *FuseImageManipulationRequest) String() string { return proto.CompactTextString(m) }
func (*FuseImageManipulationRequest) ProtoMessage()    {}
func (*FuseImageManipulationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{2}
}

func (m *FuseImageManipulationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseImageManipulationRequest.Unmarshal(m, b)
}
func (m *FuseImageManipulationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseImageManipulationRequest.Marshal(b, m, deterministic)
}
func (m *FuseImageManipulationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseImageManipulationRequest.Merge(m, src)
}
func (m *FuseImageManipulationRequest) XXX_Size() int {
	return xxx_messageInfo_FuseImageManipulationRequest.Size(m)
}
func (m *FuseImageManipulationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseImageManipulationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseImageManipulationRequest proto.InternalMessageInfo

func (m *FuseImageManipulationRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *FuseImageManipulationRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *FuseImageManipulationRequest) GetImgManipReq() *ImageManipulationRequest {
	if m != nil {
		return m.ImgManipReq
	}
	return nil
}

func (m *FuseImageManipulationRequest) GetImgManip() []*AnnotatedImageManipulation {
	if m != nil {
		return m.ImgManip
	}
	return nil
}

func (m *FuseImageManipulationRequest) GetWantMasks() bool {
	if m != nil {
		return m.WantMasks
	}
	return false
}

// Next Tag: 4
type AnnotatedVideoManipulation struct {
	Id                   string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version              string             `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Data                 *VideoManipulation `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AnnotatedVideoManipulation) Reset()         { *m = AnnotatedVideoManipulation{} }
func (m *AnnotatedVideoManipulation) String() string { return proto.CompactTextString(m) }
func (*AnnotatedVideoManipulation) ProtoMessage()    {}
func (*AnnotatedVideoManipulation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{3}
}

func (m *AnnotatedVideoManipulation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotatedVideoManipulation.Unmarshal(m, b)
}
func (m *AnnotatedVideoManipulation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotatedVideoManipulation.Marshal(b, m, deterministic)
}
func (m *AnnotatedVideoManipulation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedVideoManipulation.Merge(m, src)
}
func (m *AnnotatedVideoManipulation) XXX_Size() int {
	return xxx_messageInfo_AnnotatedVideoManipulation.Size(m)
}
func (m *AnnotatedVideoManipulation) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedVideoManipulation.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedVideoManipulation proto.InternalMessageInfo

func (m *AnnotatedVideoManipulation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotatedVideoManipulation) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnnotatedVideoManipulation) GetData() *VideoManipulation {
	if m != nil {
		return m.Data
	}
	return nil
}

// Next Tag: 6
type FuseVideoManipulationRequest struct {
	RequestId   string                        `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	OutDir      string                        `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	VidManipReq *VideoManipulationRequest     `protobuf:"bytes,3,opt,name=vid_manip_req,json=vidManipReq,proto3" json:"vid_manip_req,omitempty"`
	VidManip    []*AnnotatedVideoManipulation `protobuf:"bytes,4,rep,name=vid_manip,json=vidManip,proto3" json:"vid_manip,omitempty"`
	// If this is set, the fusion algorithm should produce mask output. Otherwise
	// it should only produce a score.
	WantMasks            bool     `protobuf:"varint,5,opt,name=want_masks,json=wantMasks,proto3" json:"want_masks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseVideoManipulationRequest) Reset()         { *m = FuseVideoManipulationRequest{} }
func (m *FuseVideoManipulationRequest) String() string { return proto.CompactTextString(m) }
func (*FuseVideoManipulationRequest) ProtoMessage()    {}
func (*FuseVideoManipulationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{4}
}

func (m *FuseVideoManipulationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseVideoManipulationRequest.Unmarshal(m, b)
}
func (m *FuseVideoManipulationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseVideoManipulationRequest.Marshal(b, m, deterministic)
}
func (m *FuseVideoManipulationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseVideoManipulationRequest.Merge(m, src)
}
func (m *FuseVideoManipulationRequest) XXX_Size() int {
	return xxx_messageInfo_FuseVideoManipulationRequest.Size(m)
}
func (m *FuseVideoManipulationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseVideoManipulationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseVideoManipulationRequest proto.InternalMessageInfo

func (m *FuseVideoManipulationRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *FuseVideoManipulationRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *FuseVideoManipulationRequest) GetVidManipReq() *VideoManipulationRequest {
	if m != nil {
		return m.VidManipReq
	}
	return nil
}

func (m *FuseVideoManipulationRequest) GetVidManip() []*AnnotatedVideoManipulation {
	if m != nil {
		return m.VidManip
	}
	return nil
}

func (m *FuseVideoManipulationRequest) GetWantMasks() bool {
	if m != nil {
		return m.WantMasks
	}
	return false
}

// Next Tag: 4
type AnnotatedImageSplice struct {
	Id                   string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version              string       `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Data                 *ImageSplice `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AnnotatedImageSplice) Reset()         { *m = AnnotatedImageSplice{} }
func (m *AnnotatedImageSplice) String() string { return proto.CompactTextString(m) }
func (*AnnotatedImageSplice) ProtoMessage()    {}
func (*AnnotatedImageSplice) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{5}
}

func (m *AnnotatedImageSplice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotatedImageSplice.Unmarshal(m, b)
}
func (m *AnnotatedImageSplice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotatedImageSplice.Marshal(b, m, deterministic)
}
func (m *AnnotatedImageSplice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedImageSplice.Merge(m, src)
}
func (m *AnnotatedImageSplice) XXX_Size() int {
	return xxx_messageInfo_AnnotatedImageSplice.Size(m)
}
func (m *AnnotatedImageSplice) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedImageSplice.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedImageSplice proto.InternalMessageInfo

func (m *AnnotatedImageSplice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotatedImageSplice) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnnotatedImageSplice) GetData() *ImageSplice {
	if m != nil {
		return m.Data
	}
	return nil
}

// Next Tag: 6
type FuseImageSpliceRequest struct {
	RequestId    string                  `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	OutDir       string                  `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	ImgSpliceReq *ImageSpliceRequest     `protobuf:"bytes,3,opt,name=img_splice_req,json=imgSpliceReq,proto3" json:"img_splice_req,omitempty"`
	ImgSplice    []*AnnotatedImageSplice `protobuf:"bytes,4,rep,name=img_splice,json=imgSplice,proto3" json:"img_splice,omitempty"`
	// If this is set, the fusion algorithm should produce mask output. Otherwise
	// it should only produce a score.
	WantMasks            bool     `protobuf:"varint,5,opt,name=want_masks,json=wantMasks,proto3" json:"want_masks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseImageSpliceRequest) Reset()         { *m = FuseImageSpliceRequest{} }
func (m *FuseImageSpliceRequest) String() string { return proto.CompactTextString(m) }
func (*FuseImageSpliceRequest) ProtoMessage()    {}
func (*FuseImageSpliceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{6}
}

func (m *FuseImageSpliceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseImageSpliceRequest.Unmarshal(m, b)
}
func (m *FuseImageSpliceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseImageSpliceRequest.Marshal(b, m, deterministic)
}
func (m *FuseImageSpliceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseImageSpliceRequest.Merge(m, src)
}
func (m *FuseImageSpliceRequest) XXX_Size() int {
	return xxx_messageInfo_FuseImageSpliceRequest.Size(m)
}
func (m *FuseImageSpliceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseImageSpliceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseImageSpliceRequest proto.InternalMessageInfo

func (m *FuseImageSpliceRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *FuseImageSpliceRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *FuseImageSpliceRequest) GetImgSpliceReq() *ImageSpliceRequest {
	if m != nil {
		return m.ImgSpliceReq
	}
	return nil
}

func (m *FuseImageSpliceRequest) GetImgSplice() []*AnnotatedImageSplice {
	if m != nil {
		return m.ImgSplice
	}
	return nil
}

func (m *FuseImageSpliceRequest) GetWantMasks() bool {
	if m != nil {
		return m.WantMasks
	}
	return false
}

// Next Tag: 4
type AnnotatedImageCameraMatch struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version              string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Data                 *ImageCameraMatch `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AnnotatedImageCameraMatch) Reset()         { *m = AnnotatedImageCameraMatch{} }
func (m *AnnotatedImageCameraMatch) String() string { return proto.CompactTextString(m) }
func (*AnnotatedImageCameraMatch) ProtoMessage()    {}
func (*AnnotatedImageCameraMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{7}
}

func (m *AnnotatedImageCameraMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotatedImageCameraMatch.Unmarshal(m, b)
}
func (m *AnnotatedImageCameraMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotatedImageCameraMatch.Marshal(b, m, deterministic)
}
func (m *AnnotatedImageCameraMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedImageCameraMatch.Merge(m, src)
}
func (m *AnnotatedImageCameraMatch) XXX_Size() int {
	return xxx_messageInfo_AnnotatedImageCameraMatch.Size(m)
}
func (m *AnnotatedImageCameraMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedImageCameraMatch.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedImageCameraMatch proto.InternalMessageInfo

func (m *AnnotatedImageCameraMatch) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotatedImageCameraMatch) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnnotatedImageCameraMatch) GetData() *ImageCameraMatch {
	if m != nil {
		return m.Data
	}
	return nil
}

// Next Tag: 6
type FuseImageCameraMatchRequest struct {
	RequestId      string                       `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	OutDir         string                       `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	ImgCamMatchReq *ImageCameraMatchRequest     `protobuf:"bytes,3,opt,name=img_cam_match_req,json=imgCamMatchReq,proto3" json:"img_cam_match_req,omitempty"`
	ImgCamMatch    []*AnnotatedImageCameraMatch `protobuf:"bytes,4,rep,name=img_cam_match,json=imgCamMatch,proto3" json:"img_cam_match,omitempty"`
	// If this is set, the fusion algorithm should produce mask output. Otherwise
	// it should only produce a score.
	WantMasks            bool     `protobuf:"varint,5,opt,name=want_masks,json=wantMasks,proto3" json:"want_masks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseImageCameraMatchRequest) Reset()         { *m = FuseImageCameraMatchRequest{} }
func (m *FuseImageCameraMatchRequest) String() string { return proto.CompactTextString(m) }
func (*FuseImageCameraMatchRequest) ProtoMessage()    {}
func (*FuseImageCameraMatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{8}
}

func (m *FuseImageCameraMatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseImageCameraMatchRequest.Unmarshal(m, b)
}
func (m *FuseImageCameraMatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseImageCameraMatchRequest.Marshal(b, m, deterministic)
}
func (m *FuseImageCameraMatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseImageCameraMatchRequest.Merge(m, src)
}
func (m *FuseImageCameraMatchRequest) XXX_Size() int {
	return xxx_messageInfo_FuseImageCameraMatchRequest.Size(m)
}
func (m *FuseImageCameraMatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseImageCameraMatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseImageCameraMatchRequest proto.InternalMessageInfo

func (m *FuseImageCameraMatchRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *FuseImageCameraMatchRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *FuseImageCameraMatchRequest) GetImgCamMatchReq() *ImageCameraMatchRequest {
	if m != nil {
		return m.ImgCamMatchReq
	}
	return nil
}

func (m *FuseImageCameraMatchRequest) GetImgCamMatch() []*AnnotatedImageCameraMatch {
	if m != nil {
		return m.ImgCamMatch
	}
	return nil
}

func (m *FuseImageCameraMatchRequest) GetWantMasks() bool {
	if m != nil {
		return m.WantMasks
	}
	return false
}

// Next Tag: 4
type AnnotatedVideoCameraMatch struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version              string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Data                 *VideoCameraMatch `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AnnotatedVideoCameraMatch) Reset()         { *m = AnnotatedVideoCameraMatch{} }
func (m *AnnotatedVideoCameraMatch) String() string { return proto.CompactTextString(m) }
func (*AnnotatedVideoCameraMatch) ProtoMessage()    {}
func (*AnnotatedVideoCameraMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{9}
}

func (m *AnnotatedVideoCameraMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotatedVideoCameraMatch.Unmarshal(m, b)
}
func (m *AnnotatedVideoCameraMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotatedVideoCameraMatch.Marshal(b, m, deterministic)
}
func (m *AnnotatedVideoCameraMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotatedVideoCameraMatch.Merge(m, src)
}
func (m *AnnotatedVideoCameraMatch) XXX_Size() int {
	return xxx_messageInfo_AnnotatedVideoCameraMatch.Size(m)
}
func (m *AnnotatedVideoCameraMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotatedVideoCameraMatch.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotatedVideoCameraMatch proto.InternalMessageInfo

func (m *AnnotatedVideoCameraMatch) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotatedVideoCameraMatch) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnnotatedVideoCameraMatch) GetData() *VideoCameraMatch {
	if m != nil {
		return m.Data
	}
	return nil
}

// Next Tag: 6
type FuseVideoCameraMatchRequest struct {
	RequestId      string                       `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	OutDir         string                       `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	VidCamMatchReq *VideoCameraMatchRequest     `protobuf:"bytes,3,opt,name=vid_cam_match_req,json=vidCamMatchReq,proto3" json:"vid_cam_match_req,omitempty"`
	VidCamMatch    []*AnnotatedVideoCameraMatch `protobuf:"bytes,4,rep,name=vid_cam_match,json=vidCamMatch,proto3" json:"vid_cam_match,omitempty"`
	// If this is set, the fusion algorithm should produce mask output. Otherwise
	// it should only produce a score.
	WantMasks            bool     `protobuf:"varint,5,opt,name=want_masks,json=wantMasks,proto3" json:"want_masks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseVideoCameraMatchRequest) Reset()         { *m = FuseVideoCameraMatchRequest{} }
func (m *FuseVideoCameraMatchRequest) String() string { return proto.CompactTextString(m) }
func (*FuseVideoCameraMatchRequest) ProtoMessage()    {}
func (*FuseVideoCameraMatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae7b01781c07efe2, []int{10}
}

func (m *FuseVideoCameraMatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseVideoCameraMatchRequest.Unmarshal(m, b)
}
func (m *FuseVideoCameraMatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseVideoCameraMatchRequest.Marshal(b, m, deterministic)
}
func (m *FuseVideoCameraMatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseVideoCameraMatchRequest.Merge(m, src)
}
func (m *FuseVideoCameraMatchRequest) XXX_Size() int {
	return xxx_messageInfo_FuseVideoCameraMatchRequest.Size(m)
}
func (m *FuseVideoCameraMatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseVideoCameraMatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseVideoCameraMatchRequest proto.InternalMessageInfo

func (m *FuseVideoCameraMatchRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *FuseVideoCameraMatchRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *FuseVideoCameraMatchRequest) GetVidCamMatchReq() *VideoCameraMatchRequest {
	if m != nil {
		return m.VidCamMatchReq
	}
	return nil
}

func (m *FuseVideoCameraMatchRequest) GetVidCamMatch() []*AnnotatedVideoCameraMatch {
	if m != nil {
		return m.VidCamMatch
	}
	return nil
}

func (m *FuseVideoCameraMatchRequest) GetWantMasks() bool {
	if m != nil {
		return m.WantMasks
	}
	return false
}

func init() {
	proto.RegisterType((*Fusion)(nil), "mediforproto.Fusion")
	proto.RegisterType((*AnnotatedImageManipulation)(nil), "mediforproto.AnnotatedImageManipulation")
	proto.RegisterType((*FuseImageManipulationRequest)(nil), "mediforproto.FuseImageManipulationRequest")
	proto.RegisterType((*AnnotatedVideoManipulation)(nil), "mediforproto.AnnotatedVideoManipulation")
	proto.RegisterType((*FuseVideoManipulationRequest)(nil), "mediforproto.FuseVideoManipulationRequest")
	proto.RegisterType((*AnnotatedImageSplice)(nil), "mediforproto.AnnotatedImageSplice")
	proto.RegisterType((*FuseImageSpliceRequest)(nil), "mediforproto.FuseImageSpliceRequest")
	proto.RegisterType((*AnnotatedImageCameraMatch)(nil), "mediforproto.AnnotatedImageCameraMatch")
	proto.RegisterType((*FuseImageCameraMatchRequest)(nil), "mediforproto.FuseImageCameraMatchRequest")
	proto.RegisterType((*AnnotatedVideoCameraMatch)(nil), "mediforproto.AnnotatedVideoCameraMatch")
	proto.RegisterType((*FuseVideoCameraMatchRequest)(nil), "mediforproto.FuseVideoCameraMatchRequest")
}

func init() { proto.RegisterFile("fusion.proto", fileDescriptor_ae7b01781c07efe2) }

var fileDescriptor_ae7b01781c07efe2 = []byte{
	// 870 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x5b, 0x4f, 0xe3, 0x46,
	0x18, 0xad, 0x13, 0x08, 0xe4, 0x4b, 0x08, 0x62, 0xc4, 0xc5, 0xa4, 0xa5, 0x8d, 0xa2, 0x96, 0x06,
	0x24, 0x12, 0x29, 0xbc, 0xf5, 0xa1, 0x2a, 0xe1, 0xa2, 0xd0, 0x36, 0x12, 0x32, 0x2b, 0x1e, 0xf6,
	0xc5, 0x1a, 0xec, 0xc1, 0x3b, 0x22, 0x63, 0x07, 0x7b, 0x92, 0x15, 0xda, 0x3f, 0xb0, 0xef, 0xfb,
	0x33, 0x57, 0xfb, 0x07, 0xf6, 0x69, 0xe5, 0xb1, 0x9d, 0xf8, 0x1a, 0x27, 0xb0, 0xfb, 0x14, 0x79,
	0xfc, 0xcd, 0x99, 0x93, 0x73, 0xbe, 0xcb, 0x18, 0xaa, 0x0f, 0x63, 0x87, 0x5a, 0x66, 0x7b, 0x64,
	0x5b, 0xdc, 0x42, 0x55, 0x46, 0x74, 0xfa, 0x60, 0xd9, 0xe2, 0xa9, 0xbe, 0x67, 0x58, 0x96, 0x31,
	0x24, 0x1d, 0x7b, 0xa4, 0x75, 0x1c, 0x8e, 0xf9, 0xd8, 0xf1, 0xc2, 0xea, 0x35, 0x6c, 0xe2, 0xe1,
	0x33, 0xa7, 0x9a, 0xf7, 0xdc, 0xfc, 0xbc, 0x0a, 0xa5, 0x2b, 0x81, 0x83, 0x8e, 0xa1, 0xe4, 0x85,
	0xca, 0x52, 0x43, 0x6a, 0x55, 0xba, 0xa8, 0xed, 0x81, 0xb4, 0xed, 0x91, 0xd6, 0xbe, 0x15, 0x6f,
	0x14, 0x3f, 0x02, 0x1d, 0xc3, 0x96, 0xc3, 0xb1, 0xcd, 0x55, 0x4e, 0x19, 0x51, 0x19, 0x1d, 0x0e,
	0xa9, 0x23, 0x17, 0x1a, 0x52, 0xab, 0xa8, 0x6c, 0x8a, 0x17, 0x6f, 0x28, 0x23, 0x03, 0xb1, 0x8c,
	0x0e, 0x61, 0x93, 0x98, 0x7a, 0x24, 0xb2, 0x28, 0x22, 0x37, 0x88, 0xa9, 0x87, 0xe2, 0x6e, 0x60,
	0x83, 0x32, 0x43, 0x65, 0xd8, 0xa4, 0x23, 0xd5, 0x26, 0x4f, 0x72, 0x45, 0xd0, 0x38, 0x6e, 0x87,
	0xff, 0x59, 0xfb, 0x6a, 0xec, 0x90, 0x6b, 0x86, 0x0d, 0x32, 0x70, 0xe3, 0xc6, 0x43, 0xcc, 0xa9,
	0x65, 0x2a, 0xe4, 0x69, 0x4c, 0x1c, 0xde, 0xff, 0x49, 0xa9, 0x50, 0x66, 0x88, 0x37, 0x0a, 0x79,
	0x72, 0x11, 0x27, 0x54, 0x0f, 0x21, 0x56, 0xb3, 0x10, 0xef, 0xa8, 0x4e, 0xac, 0x0c, 0xc4, 0x09,
	0xd5, 0xa7, 0x88, 0xff, 0x43, 0xcd, 0xe5, 0xe8, 0x8c, 0x86, 0x54, 0x23, 0x02, 0x72, 0x43, 0x40,
	0xfe, 0x9e, 0x41, 0xf2, 0x56, 0x04, 0xce, 0xc0, 0xaa, 0x94, 0x19, 0xd3, 0x35, 0x74, 0x07, 0x5b,
	0x2e, 0x9a, 0x86, 0x99, 0xca, 0x30, 0xd7, 0xde, 0x09, 0xc0, 0x9a, 0x00, 0x3c, 0xca, 0x00, 0x3c,
	0xc7, 0x8c, 0xd8, 0x78, 0xe0, 0x46, 0xcf, 0x50, 0x5d, 0x4e, 0xe7, 0x98, 0x05, 0xab, 0xe8, 0x6f,
	0x28, 0x4f, 0x95, 0x94, 0x77, 0x04, 0xde, 0x6f, 0x51, 0xbc, 0x84, 0x82, 0x7d, 0x49, 0x59, 0x0f,
	0xa4, 0x73, 0xf7, 0x4f, 0x75, 0x93, 0x77, 0xd3, 0xf6, 0x27, 0xf4, 0x72, 0xf7, 0x07, 0x42, 0xa1,
	0xbf, 0x00, 0x66, 0x2a, 0xc9, 0x7b, 0x02, 0x60, 0x3f, 0x85, 0x80, 0xa7, 0x44, 0x5f, 0x52, 0xca,
	0x53, 0x59, 0xd0, 0x85, 0x97, 0x05, 0x53, 0x4d, 0x64, 0x59, 0x6c, 0xff, 0x35, 0x65, 0x7b, 0x48,
	0x8b, 0xbe, 0x24, 0x9c, 0x0f, 0x44, 0xe8, 0x95, 0x61, 0xcd, 0xf6, 0xe4, 0xe9, 0x01, 0xac, 0xdb,
	0xc4, 0x19, 0x59, 0xa6, 0x43, 0x9a, 0x1f, 0xa0, 0x7e, 0x66, 0x9a, 0x16, 0xc7, 0x9c, 0xe8, 0x09,
	0x09, 0x50, 0x0d, 0x0a, 0x54, 0x17, 0xc9, 0x5f, 0x56, 0x0a, 0x54, 0x47, 0x32, 0xac, 0x4d, 0x88,
	0xed, 0xd6, 0x86, 0x48, 0xed, 0xb2, 0x12, 0x3c, 0xa2, 0x53, 0x58, 0xd1, 0x31, 0xc7, 0x22, 0x8f,
	0xf3, 0xb5, 0x55, 0x44, 0x70, 0xf3, 0x63, 0x01, 0x7e, 0x99, 0x97, 0xbd, 0xe8, 0x00, 0xc0, 0x27,
	0xad, 0x4e, 0x79, 0x94, 0xfd, 0x95, 0x6b, 0x1d, 0xed, 0xc1, 0x9a, 0x35, 0xe6, 0xaa, 0x4e, 0x6d,
	0x9f, 0x4e, 0xc9, 0x1a, 0xf3, 0x0b, 0x6a, 0xa3, 0x7f, 0xe3, 0x85, 0xe3, 0xd1, 0x3a, 0xcc, 0xa3,
	0xe5, 0x21, 0x47, 0x4b, 0xe6, 0x32, 0x9c, 0x3a, 0x2b, 0x8d, 0x62, 0xab, 0xd2, 0x6d, 0x45, 0x71,
	0xb2, 0x05, 0x0c, 0x65, 0xd0, 0x01, 0xc0, 0x7b, 0x6c, 0x72, 0x95, 0x61, 0xe7, 0xd1, 0x91, 0x57,
	0x1b, 0x52, 0x6b, 0x5d, 0x29, 0xbb, 0x2b, 0x03, 0x77, 0x21, 0xe2, 0x43, 0x22, 0x95, 0xbe, 0x97,
	0x0f, 0xc9, 0x9a, 0x8e, 0xfa, 0x90, 0x55, 0xf3, 0xaf, 0xf1, 0x21, 0xda, 0x6e, 0x52, 0x7d, 0xc8,
	0x3a, 0x36, 0xda, 0x68, 0x2e, 0xc3, 0x25, 0x38, 0xdf, 0x87, 0x24, 0xe0, 0xac, 0x12, 0x73, 0x7c,
	0xb0, 0x60, 0x3b, 0x6a, 0xa7, 0x5f, 0x84, 0x8b, 0x3b, 0x70, 0x12, 0x71, 0x20, 0xbb, 0xc8, 0x7d,
	0xed, 0xbf, 0x4a, 0xb0, 0x9b, 0xde, 0x1c, 0x5f, 0xac, 0xfa, 0x55, 0xa2, 0x25, 0x7b, 0x5c, 0x1a,
	0xd9, 0x5c, 0x7c, 0xc1, 0xa3, 0xcd, 0xf8, 0x2c, 0xd2, 0xb4, 0x3c, 0xc9, 0x9b, 0xf3, 0x52, 0xdf,
	0xdf, 0x1a, 0xea, 0x5d, 0x39, 0x6a, 0x3f, 0xc3, 0x7e, 0x14, 0x21, 0xd4, 0xc0, 0x96, 0x90, 0xbc,
	0x1b, 0x91, 0x3c, 0xa7, 0x31, 0xfa, 0xba, 0x7f, 0x2a, 0xc0, 0xcf, 0x73, 0x66, 0xc8, 0x8b, 0xc5,
	0xbf, 0x49, 0x9b, 0x60, 0x1e, 0xb1, 0x3f, 0x72, 0x88, 0xf9, 0x26, 0xc4, 0x67, 0xd7, 0x7f, 0xf1,
	0xfe, 0xef, 0x39, 0xf1, 0xe7, 0x3c, 0x27, 0xc2, 0xb0, 0xe1, 0x31, 0xb0, 0x8c, 0x21, 0xa2, 0x8a,
	0x7e, 0x80, 0x21, 0x71, 0xdc, 0x98, 0x21, 0x89, 0xd7, 0xaf, 0x37, 0xc4, 0xed, 0x1b, 0x0b, 0x18,
	0x92, 0x71, 0xb2, 0x52, 0x9b, 0x50, 0x3d, 0x66, 0x48, 0x04, 0x31, 0xc7, 0x90, 0x04, 0x6c, 0x25,
	0x84, 0x97, 0x63, 0x48, 0xf7, 0x4b, 0x11, 0x56, 0x5d, 0x55, 0x6c, 0xa4, 0xc3, 0x4e, 0xea, 0xac,
	0x44, 0x4b, 0x5c, 0x07, 0xeb, 0x79, 0x83, 0x19, 0x29, 0xb0, 0x19, 0xeb, 0x46, 0x68, 0xa1, 0x9b,
	0x5c, 0x3d, 0xbb, 0xd1, 0x05, 0xcc, 0x93, 0x63, 0x6d, 0x89, 0x6b, 0x67, 0x3d, 0x6f, 0x94, 0x21,
	0x0c, 0xdb, 0x69, 0xf5, 0x8c, 0x16, 0xbf, 0x37, 0xd6, 0x73, 0x3a, 0x47, 0x70, 0x44, 0xa2, 0x30,
	0x8e, 0x32, 0xfe, 0x47, 0xfe, 0x11, 0xf1, 0xb0, 0x1e, 0x05, 0x59, 0xb3, 0x58, 0x28, 0xc8, 0xb0,
	0x31, 0xf3, 0xbe, 0x4c, 0x7a, 0x15, 0xef, 0xb3, 0xe4, 0xc6, 0x7d, 0x78, 0xfb, 0x8f, 0x41, 0xf9,
	0x10, 0xdf, 0xc7, 0x23, 0x35, 0x8b, 0x75, 0xfc, 0xa5, 0xe0, 0xf7, 0x44, 0xec, 0xee, 0x8c, 0x1e,
	0x8d, 0x4e, 0xf8, 0xec, 0xfb, 0x92, 0xf8, 0x39, 0xfd, 0x16, 0x00, 0x00, 0xff, 0xff, 0x53, 0xe2,
	0x60, 0x87, 0x36, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FuserClient is the client API for Fuser service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FuserClient interface {
	FuseImageManipulation(ctx context.Context, in *FuseImageManipulationRequest, opts ...grpc.CallOption) (*ImageManipulation, error)
	FuseImageSplice(ctx context.Context, in *FuseImageSpliceRequest, opts ...grpc.CallOption) (*ImageSplice, error)
	FuseVideoManipulation(ctx context.Context, in *FuseVideoManipulationRequest, opts ...grpc.CallOption) (*VideoManipulation, error)
	FuseImageCameraMatch(ctx context.Context, in *FuseImageCameraMatchRequest, opts ...grpc.CallOption) (*ImageCameraMatch, error)
	FuseVideoCameraMatch(ctx context.Context, in *FuseVideoCameraMatchRequest, opts ...grpc.CallOption) (*VideoCameraMatch, error)
}

type fuserClient struct {
	cc *grpc.ClientConn
}

func NewFuserClient(cc *grpc.ClientConn) FuserClient {
	return &fuserClient{cc}
}

func (c *fuserClient) FuseImageManipulation(ctx context.Context, in *FuseImageManipulationRequest, opts ...grpc.CallOption) (*ImageManipulation, error) {
	out := new(ImageManipulation)
	err := c.cc.Invoke(ctx, "/mediforproto.Fuser/FuseImageManipulation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuserClient) FuseImageSplice(ctx context.Context, in *FuseImageSpliceRequest, opts ...grpc.CallOption) (*ImageSplice, error) {
	out := new(ImageSplice)
	err := c.cc.Invoke(ctx, "/mediforproto.Fuser/FuseImageSplice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuserClient) FuseVideoManipulation(ctx context.Context, in *FuseVideoManipulationRequest, opts ...grpc.CallOption) (*VideoManipulation, error) {
	out := new(VideoManipulation)
	err := c.cc.Invoke(ctx, "/mediforproto.Fuser/FuseVideoManipulation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuserClient) FuseImageCameraMatch(ctx context.Context, in *FuseImageCameraMatchRequest, opts ...grpc.CallOption) (*ImageCameraMatch, error) {
	out := new(ImageCameraMatch)
	err := c.cc.Invoke(ctx, "/mediforproto.Fuser/FuseImageCameraMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuserClient) FuseVideoCameraMatch(ctx context.Context, in *FuseVideoCameraMatchRequest, opts ...grpc.CallOption) (*VideoCameraMatch, error) {
	out := new(VideoCameraMatch)
	err := c.cc.Invoke(ctx, "/mediforproto.Fuser/FuseVideoCameraMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FuserServer is the server API for Fuser service.
type FuserServer interface {
	FuseImageManipulation(context.Context, *FuseImageManipulationRequest) (*ImageManipulation, error)
	FuseImageSplice(context.Context, *FuseImageSpliceRequest) (*ImageSplice, error)
	FuseVideoManipulation(context.Context, *FuseVideoManipulationRequest) (*VideoManipulation, error)
	FuseImageCameraMatch(context.Context, *FuseImageCameraMatchRequest) (*ImageCameraMatch, error)
	FuseVideoCameraMatch(context.Context, *FuseVideoCameraMatchRequest) (*VideoCameraMatch, error)
}

func RegisterFuserServer(s *grpc.Server, srv FuserServer) {
	s.RegisterService(&_Fuser_serviceDesc, srv)
}

func _Fuser_FuseImageManipulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseImageManipulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuserServer).FuseImageManipulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Fuser/FuseImageManipulation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuserServer).FuseImageManipulation(ctx, req.(*FuseImageManipulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fuser_FuseImageSplice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseImageSpliceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuserServer).FuseImageSplice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Fuser/FuseImageSplice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuserServer).FuseImageSplice(ctx, req.(*FuseImageSpliceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fuser_FuseVideoManipulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseVideoManipulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuserServer).FuseVideoManipulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Fuser/FuseVideoManipulation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuserServer).FuseVideoManipulation(ctx, req.(*FuseVideoManipulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fuser_FuseImageCameraMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseImageCameraMatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuserServer).FuseImageCameraMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Fuser/FuseImageCameraMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuserServer).FuseImageCameraMatch(ctx, req.(*FuseImageCameraMatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fuser_FuseVideoCameraMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseVideoCameraMatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuserServer).FuseVideoCameraMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Fuser/FuseVideoCameraMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuserServer).FuseVideoCameraMatch(ctx, req.(*FuseVideoCameraMatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Fuser_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mediforproto.Fuser",
	HandlerType: (*FuserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FuseImageManipulation",
			Handler:    _Fuser_FuseImageManipulation_Handler,
		},
		{
			MethodName: "FuseImageSplice",
			Handler:    _Fuser_FuseImageSplice_Handler,
		},
		{
			MethodName: "FuseVideoManipulation",
			Handler:    _Fuser_FuseVideoManipulation_Handler,
		},
		{
			MethodName: "FuseImageCameraMatch",
			Handler:    _Fuser_FuseImageCameraMatch_Handler,
		},
		{
			MethodName: "FuseVideoCameraMatch",
			Handler:    _Fuser_FuseVideoCameraMatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fusion.proto",
}
