syntax = "proto3";

package mediforproto;

option go_package = "github.com/mediaforensics/medifor/pkg/mediforproto";

import "medifor/v1/analytic.proto";
import "medifor/v1/fusion.proto";

enum DetectionStage {
  DETECTION_STAGE_NONE = 0;
  DETECTION_STAGE_QUEUED = 1;
  DETECTION_STAGE_CLAIMED = 2;
  DETECTION_STAGE_FINISHED = 3;
}

enum DetectionStatus {
  DETECTION_STATUS_NONE = 0;
  DETECTION_STATUS_SUCCESS = 1;
  DETECTION_STATUS_FAILURE = 2;
}

enum SortKey {
  SCORE = 0;
  META = 1;
  META_QUERY = 2;
}

enum FusionThresholdType {
  FUSION_NO_THRESHOLD = 0;
  FUSION_LT_THRESHOLD = 1;
  FUSION_GT_THRESHOLD = 2;
}

enum MediaType {
  IMAGE = 0;
  VIDEO = 1;
  FUSION_IMAGE = 2;
  FUSION_VIDEO = 3;
}

// SortCol identifies the column to sort by and whether to sort in ascending order
// Next tag: 6
message SortCol {
  // Column to sort on
  SortKey key = 1;

  // Bool for sorting in ascending order (if false sorts in descending order)
  bool is_asc = 2;

  // What type to cast the key into if necessary
  string type_cast = 3;

  // Metadata key to sort by if using metadata
  string meta_key = 4;

  // // Fuser ID on which to sort by score
  // string fuser_id = 5;
}

// DetectionRequest contains a MediFor detection object as well as a list of
// analytic ids and fusion ids. TODO: if none specified, default to all?
// Next Tag: 9
message DetectionRequest {
  // An optional ID for this detection. If not provided, one will be assigned.
  // Must be unique from any other provided ID: a collision will prevent
  // this request from being fulfilled.
  string id = 3;

  // A Detection proto with just the important request parts filled out.
  Detection request = 1;

  // The analytics to run.
  repeated string analytic_id = 2;

  // Fusers to run automatically when all analytics are done.
  repeated string fuser_id = 8;

  // Tags to apply to this detection. When in doubt, use user_tags instead.
  map<string, string> tags = 4;

  // User tags to apply to this detection. When in doubt, use this one.
  map<string, string> user_tags = 6;

  // Metadata table as needed. Pass-through.
  map<string, string> meta = 7;

  // Timeout in seconds after which an analytic worker will die waiting for the
  // analytic to respond. Default is "no timeout" (0 seconds).
  int64 analytic_timeout_sec = 5;
}

// AnalyticDetectionInfo provides details on the status of a detection being
// performed by a given analytic.
// Next ID: 5
message AnalyticDetectionInfo {
  // The analytic that produced this result.
  string analytic_id = 1;

  // Current processing stage for the entire detection event (all analytics) if
  // in progress, or PT_STAGE_FINISHED if completed. When complete, the status
  // field will have a non-default value.
  DetectionStage stage = 2;

  // Final status when we are in PT_STAGE_FINISHED.
  DetectionStatus status = 3;

  // The Detection with the result and status filled out (and the request).
  // If the response and status are empty (default), then it is not finished.
  Detection detection = 4;
}

// DetectionInfo provides details on a given detection event specified by the id.
// Next Tag: 11
message DetectionInfo {
  // The detection event ID.
  string id = 1;

  // A list of input resources for this detection. Usually a singleton, but can
  // contain multiple if multiple are accepted for this particular kind of
  // request
  repeated Resource req_resources = 11;

  // Results for individual analytics.
  repeated AnalyticDetectionInfo analytic_info = 2;

  // Results for fusion analytics
  repeated FuserFusionInfo fusion_info = 8;

  // Tags for the requested detection.
  map<string, string> tags = 3;
  map<string, string> user_tags = 6;
  map<string, string> meta = 7;

  // A fused score, if requested.
  bool has_fused = 4;
  double fused_score = 5;

  // Progress indicator across all analytics.
  int32 analytics_total = 9;
  int32 analytics_finished = 10;
}

// DetectionInfoRequest contains the ID of an individual detection event.
message DetectionInfoRequest {
  // The ID of the detection, as returned by Detect or GetDetectionList.
  string id = 1;

  // If specified, fused scores will be returned as well.
  bool want_fused = 2;
}

message DateRange {
  // Inclusive start time in seconds since the Epoch UTC.
  int64 start_seconds_utc = 1;

  // Inclusive end time in seconds since the Epoch UTC.
  int64 end_seconds_utc = 2;
}

enum DetectionListVerbosity {
  DETECTION_VERBOSITY_FULL = 0;
  DETECTION_VERBOSITY_MINIMAL = 1;
}

// Next Tag: 10
message DetectionListRequest {
  // How much should be returned? Default: all.
  DetectionListVerbosity verbosity = 12;

  // If specified (can be empty), all listed tags (both key and value) must be
  // simultaneously present for a detection ID to be returned.
  map<string, string> tags = 1;

  // This contains a "fuzzy meta search" query. It will look through
  // detection metatags for string values that match the given query.
  string meta_query = 10;

  // Filter on dates
  // If start time is present (nonzero), all detections must have at least one analytic with a create time >= start.
  // If end time is present (nonzero), all detections must have at least one analytic create time <= end.
  // If either is zero (not present), then the filter is unbounded in that direction.
  DateRange date_range = 11;

  // If specified, only returns results from the given list of detection IDs.
  // Good for returning a single detection or one of a few. Not great for very
  // long lists (thousands).
  repeated string detection_ids = 7;

  // Specify that detection info objects should have fusion scores.
  bool want_fused = 4;

  // A series of keys to sort on, with the first key being the primary sort key
  // and following ones being seconday, tertiary, etc...
  repeated SortCol order_by = 5;

  // Fusion ID on which to sort by fusion score.
  string fuser_id = 6;

  // Fusion score threshold, if needed. Only used if the threshold type is not the default value (no threshold).
  FusionThresholdType fusion_threshold_type = 8;
  float fusion_threshold_value = 9;

  // Maximum number of items in the response. Optional.
  int32 page_size = 2;

  // If a token was returned in the response, this can be used to continue
  // where the previous response left off.
  string page_token = 3;
}

// DetectionList provides a list of DetectionInfo objects.
// Next Tag: 4
message DetectionList {
  repeated DetectionInfo detections = 1;

  // Total detections in the filtered list.
  int32 total = 3;

  // If this is non-empty, there are more results to be returned. Pass it into
  // a DetectionListRequest to obtain remaining results.
  string page_token = 2;
}

// FusionRequest contains a fusion object or a list of detectionIDs to be fused.
// Next ID: 7
message FusionRequest{
  // An optional ID for this fusion. If not provided, one will be assigned.
  // Must be unique from any other provided ID: a collision will prevent
  // this request from being fulfilled.
  string id = 1;

  // A Fusion Proto containing the original probe as well as the detection objects from
  // each analytic that ran over that probe.
  Fusion request = 2;

  // IDs for the fusion analytics
  repeated string fuser_id = 4;

  // Tags to apply to this fusion.  To be inserted into the database as json.
  map<string, string> tags = 3;

  // DetectionID for the probes on which to perform fusion if no request is specified
  string detection_id = 5;

  // Output directory to use ONLY if building request from a detection ID
  string detection_id_out_dir = 6;
}

// AnalyticDetectionInfo provides details on the status of a detection being
// performed by a given analytic.
// Next ID: 5
message FuserFusionInfo {
  // The fusion algorithmc that produced this result.
  string fuser_id = 1;

  // Current processing stage for the entire detection event (all analytics) if
  // in progress, or PT_STAGE_FINISHED if completed. When complete, the status
  // field will have a non-default value.
  DetectionStage stage = 2;

  // Final status when we are in PT_STAGE_FINISHED.
  DetectionStatus status = 3;

  // The Fusion with the result and status filled out (and the request).
  // If the response and status are empty (default), then it is not finished.
  Fusion fusion = 4;
}

// FusionInfo provides details on a given fusion event specified by the ID.
message FusionInfo {
  // Fusion event ID.
  string id = 1;

  // Results for individual fusion analytics.
  repeated FuserFusionInfo fusion_infos = 2;

  // Tags for the requested fusion.
  map<string, string> tags = 3;

  // A fused score, if requested.
  bool has_fused = 4;
  double fused_score = 5;
}

message FuseAllIDsRequest {
  repeated string fuser_id = 1;
  string out_dir = 2;
}

message FuseAllIDsResponse {
}

// UpdateDetectionTagsRequest contains new tags to replace or merge with existing tags.
// Next Tag: 5
message UpdateDetectionTagsRequest {
  // The detection ID to update.
  string detection_id = 1;

  // If true, replaces all user tags with the given tag set. Default is to
  // merge (replacing any duplicates, but leaving unmentioned tag keys alone).
  // Ignores delete_tags if set.
  bool replace = 2;

  // Tags to use in the request. Only updates user tags, not bare system tags.
  map<string, string> tags = 3;

  // Tag keys to delete. Only used if replace is false.
  repeated string delete_tags = 4;
}

// DetectionTagInfoRequest asks for high-level information about detection tags.
message DetectionTagInfoRequest {
  // If specified, only tags that coexist with the given required tags will
  // be returned. One possible use of this is to limit tags returned by login
  // group.
  map<string, string> require_tags = 1;

  // If specified, all keys prefixed with any value in this list will
  // not be returned in the result.
  repeated string skip_prefixes = 2;
}

// DetectionTagInfo contains high-level information about detection tags.
message DetectionTagInfo {
  // Contains mapping from "key=value" to number of times that specific key/value pair is found.
  map<string, int32> tag_counts = 1;

  // Contains mapping from "key=value" in *user tags* to number of times they appear.
  // Note that this can have overlap with system tags, and it will report these separately.
  map<string, int32> user_tag_counts = 2;
}

message DeleteDetectionRequest {
  string detection_id = 1;
}

// AnalyticMeta containes analytic metadata defining which analytics are currently active
// on the system, what they do, and their resource requirements
message AnalyticMeta {
  string id = 1;
  string version = 2;
  double cpu = 3;
  double ram = 4;
  int32 gpu = 5;
  repeated MediaType media = 6;
  string description = 7;
  string name = 8;

  map<string, string> user_fields = 9;
}

// AnalyticList holds a list of AnalyticMeta configuration metadata objects
message AnalyticList {
  repeated AnalyticMeta analytics = 1;
}

// Lists detections
message ListDetectionsRequest {
  // Filter results by score
  ScoreFilter score_filter = 1;

  // Filter results by metadata
  repeated MetaFilter meta_filters = 2;

  // Filter results by tags
  map<string, string> tags = 3;

  // Exclude results with the specified tags
  map<string, string> exclude_tags = 9;

  // Filter results by metadata query
  string meta_query = 10;

  // Sort results
  repeated SortCol order_by = 4;

  // Analytic whose score is used for filtering and sorting results. If not
  // specified, fuser_id is used instead.
  string analytic_id = 5;

  // Fuser whose score is used for filtering and sorting results. Only used
  // if analytic_id is not specified.
  string fuser_id = 6;

  // Return at most the specified number of results
  int32 page_size = 7;

  // Return the specified page of results
  string page_token = 8;
}

message ScoreFilter {
  // Whether the `min` field is valid
  bool has_min = 1;

  // Minimum score (inclusive)
  double min = 2;

  // Whether the `max` field is valid
  bool has_max = 3;

  // Maximum score (inclusive)
  double max = 4;
}

message MetaFilter {
  // Metadata key
  string meta_key = 1;

  // Whether the `min` field is valid
  bool has_min = 2;

  // Minimum value (inclusive)
  string min = 3;

  // Whether the `max` field is valid
  bool has_max = 4;

  // Maximum value (inclusive)
  string max = 5;
}

// Updates a detection's metadata
message UpdateDetectionMetadataRequest {
  // Detection ID
  string detection_id = 1;

  // Metadata to be merged with the detection's existing metadata
  map<string, string> metadata = 2;
}

// Gets analytic and fuser stats
message GetAnalyticStatsRequest {
  // Analytics to get. If empty, returns all analytics.
  repeated string analytic_ids = 1;

  // Fusers to get. If empty, returns all fusers.
  repeated string fuser_ids = 2;
}

message GetAnalyticStatsResponse {
  // Analytic stats
  repeated AnalyticStats analytic_stats = 1;

  // Fuser stats
  repeated AnalyticStats fuser_stats = 2;
}

message AnalyticStats {
  // Analytic/fuser ID
  string id = 1;

  // Number of tasks that are pending
  int32 pending = 2;

  // Number of tasks that are running
  int32 running = 3;

  // Number of tasks that succeeded and produced a score
  int32 succeeded = 4;

  // Number of tasks that succeeded but did not produce a score
  int32 opted_out = 6;

  // Number of tasks that failed
  int32 failed = 5;
}

// Gets histogram for the specified analytic
message GetHistogramRequest {
  // Analytic ID. If empty, use fuser instead.
  string analytic_id = 1;

  // Fuser ID
  string fuser_id = 2;

  // Filters detections by system and/or user tags
  map<string, string> tags = 3;

  // Excludes detections with the specified tags
  map<string, string> exclude_tags = 5;

  // Number of histogram buckets (default 10)
  int32 num_buckets = 4;
}

message GetHistogramResponse {
  repeated Bucket buckets = 1;
}

message Bucket {
  double min = 1;
  double max = 2;
  int32 frequency = 3;
}

// Deletes detection tasks that failed
message DeleteFailedAnalyticsRequest {
}

message DeleteFailedAnalyticsResponse {
  // Maps detection IDs to deleted analytics
  map<string, DeletedAnalytics> deleted_analytics = 1;
}

message DeletedAnalytics {
  // Deleted analytic IDs
  repeated string deleted_analytic_ids = 1;
}

// Gets analytics and fusers that produced a score for at least one detection
message GetAnalyticsWithScoresRequest {
  // Filters detections by system and/or user tags
  map<string, string> tags = 1;

  // Excludes detections with the specified tags
  map<string, string> exclude_tags = 2;
}

message GetAnalyticsWithScoresResponse {
  // Analytic IDs with scores
  repeated string analytic_ids = 1;

  // Fuser IDs with scores
  repeated string fuser_ids = 2;
}

service Pipeline {
  rpc Detect(DetectionRequest) returns (DetectionInfo);
  rpc GetDetectionInfo(DetectionInfoRequest) returns (DetectionInfo);
  rpc GetDetectionList(DetectionListRequest) returns (DetectionList);
  rpc DeleteDetection(DeleteDetectionRequest) returns (Empty);
  rpc Fuse(FusionRequest) returns (FusionInfo);
  rpc FuseByID(FusionRequest) returns (FusionInfo);
  rpc FuseAllIDs(FuseAllIDsRequest) returns (FuseAllIDsResponse);
  rpc UpdateDetectionTags(UpdateDetectionTagsRequest) returns (DetectionInfo);
  rpc GetDetectionTagInfo(DetectionTagInfoRequest) returns (DetectionTagInfo);
  rpc GetAnalyticMeta(Empty) returns (AnalyticList);
  rpc ListDetections(ListDetectionsRequest) returns (DetectionList);
  rpc UpdateDetectionMetadata(UpdateDetectionMetadataRequest) returns (DetectionInfo);
  rpc GetAnalyticStats(GetAnalyticStatsRequest) returns (GetAnalyticStatsResponse);
  rpc GetHistogram(GetHistogramRequest) returns (GetHistogramResponse);
  rpc DeleteFailedAnalytics(DeleteFailedAnalyticsRequest) returns (DeleteFailedAnalyticsResponse);
  rpc GetAnalyticsWithScores(GetAnalyticsWithScoresRequest) returns (GetAnalyticsWithScoresResponse);
}
